<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>B2.C++类和对象 | wumo学习分享仓库</title><meta name="author" content="wumo"><meta name="copyright" content="wumo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="类和对象的基本知识类和对象的概述类和对象的理解  每个对象都有两个特征，分别是属性(静态特征)和行为(动态特征),即对象拥有自己的属性和行为。将一组对象抽象为一个类，就是将这一组对象的共同属性和共同行为归纳成一类，类就拥有这一组对象共有属性和行为。在C++中 行为即为函数，属性即为数据。 以汽车类为例子，它具有品牌、生产厂、型号、颜色等静态特征,称为属性( Attribute);此外,它还具有行">
<meta property="og:type" content="article">
<meta property="og:title" content="B2.C++类和对象">
<meta property="og:url" content="http://xingwumo.github.io/blog/2023/07/01/B2.C++%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/index.html">
<meta property="og:site_name" content="wumo学习分享仓库">
<meta property="og:description" content="类和对象的基本知识类和对象的概述类和对象的理解  每个对象都有两个特征，分别是属性(静态特征)和行为(动态特征),即对象拥有自己的属性和行为。将一组对象抽象为一个类，就是将这一组对象的共同属性和共同行为归纳成一类，类就拥有这一组对象共有属性和行为。在C++中 行为即为函数，属性即为数据。 以汽车类为例子，它具有品牌、生产厂、型号、颜色等静态特征,称为属性( Attribute);此外,它还具有行">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://xingwumo.github.io/blog/fujian/c18a5aebdee3f6a9262f3536aece0d16.jpg">
<meta property="article:published_time" content="2023-06-30T16:00:00.000Z">
<meta property="article:modified_time" content="2023-06-30T18:03:20.455Z">
<meta property="article:author" content="wumo">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://xingwumo.github.io/blog/fujian/c18a5aebdee3f6a9262f3536aece0d16.jpg"><link rel="shortcut icon" href="/blog/img/favicon.png"><link rel="canonical" href="http://xingwumo.github.io/blog/2023/07/01/B2.C++%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/blog/css/index.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/blog/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://fastly.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://fastly.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'B2.C++类和对象',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-01 02:03:20'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/blog/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/blog/fujian/c18a5aebdee3f6a9262f3536aece0d16.jpg')"><nav id="nav"><span id="blog-info"><a href="/blog/" title="wumo学习分享仓库"><span class="site-name">wumo学习分享仓库</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">B2.C++类和对象</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-30T16:00:00.000Z" title="发表于 2023-07-01 00:00:00">2023-07-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-30T18:03:20.455Z" title="更新于 2023-07-01 02:03:20">2023-07-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/blog/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="B2.C++类和对象"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><img src="/blog/fujian/c18a5aebdee3f6a9262f3536aece0d16.jpg"></p>
<h1 id="类和对象的基本知识"><a href="#类和对象的基本知识" class="headerlink" title="类和对象的基本知识"></a>类和对象的基本知识</h1><h2 id="类和对象的概述"><a href="#类和对象的概述" class="headerlink" title="类和对象的概述"></a>类和对象的概述</h2><p>类和对象的理解</p>
<blockquote>
<p>每个对象都有两个特征，分别是属性(静态特征)和行为(动态特征),即对象拥有自己的属性和行为。<br>将一组对象抽象为一个类，就是将这一组对象的共同属性和共同行为归纳成一类，类就拥有这一组对象共有属性和行为。在C++中 行为即为函数，属性即为数据。</p>
<p>以汽车类为例子，它具有品牌、生产厂、型号、颜色等静态特征,称为属性( Attribute);此外,它还具有行驶、转弯、鸣笛、刹车等动态特征,称为行为(Behavior)。一辆具体的汽车，品牌、生产厂、型号、颜色等属性都有具体的属性，那么这这辆汽车就是这个汽车类的对象。</p>
</blockquote>
<p>类和对象的关系</p>
<blockquote>
<p>类在C++中是对象的类型,是抽象的,不占用内存单元,而对象是该类型的一个变量,是具体的,占用内存空间。对象和类的关系相当于一般的程序设计语言中变量和变量数据类型的关系。</p>
</blockquote>
<h2 id="面向对象基本特征"><a href="#面向对象基本特征" class="headerlink" title="面向对象基本特征"></a>面向对象基本特征</h2><p>抽象特征</p>
<blockquote>
<p><strong>抽象</strong>对于一组具有相同属性和行为的对象，可以把它们抽象成一种类型。在C++中.这种类型就称为类(Class )。类是对象的抽象,而对象是类的实例,是类的具体表现形式。</p>
<p>举一个例子，一个学校的学生，就是一组具有相同属性和行为的对象，我们可以把这些对象抽象成一个学生类，我们定义学生类具有姓名、班级、学号、成绩等属性（类有哪些属性可以由设计者自己去定义）。此时一个具体的学生对象，就是这个类的实例，而这个学生类就是具体学生对象的抽象。</p>
</blockquote>
<p>封装特征 ^b27b51</p>
<blockquote>
<p><strong>当我们将某个事物抽象成一个类的时候，那么这个事物的属性和行为就被封装在这个类当中。使用这个类的人不需要知道这个类的内部的实现细节，只需要知道怎么用就可以了。</strong><br>日常生活中人们操作某个对象时,只需了解其外部的功能,而不必知道对象内部的细节。例如,使用数码相机时,对照相机的光学成像原理、镜头内部结构、电路组成以及压缩算法等可以一无所知,只需要调整取景框按动快门即可照相,这就是应用封装原理的典型例子。对象的一部分属性和功能对外界屏蔽,具体的操作细节在内部实现,对外界是透明的,从外界看不到甚至感觉不到它的存在。这样,把对象的内部实现和外部行为分割开来,人们在外部进行控制,可以大幅降低人们操作对象的复杂程度。</p>
<p>封装(Encapsulation)性是面向对象程序设计方法的一个重要特性。封装包含有两层含义，一是将抽象得到的有关数据和操作代码相结合,形成一个有机的整体,对象之间相对独立,互不干扰;第二,封装将对象封闭保护起来,对象中某些部分对外隐蔽,隐藏内部实现细节,只留下一些接口接收外界的消息,与外界联系,这种方法称为信息隐蔽( Information Hiding)。信息隐蔽有利于数据安全,防止无关的人了解和修改数据。</p>
<p>封装保证了类具有较好的独立性,防止外部程序破坏类的内部数据,使得程序维护修改比较容易。对应用程序的修改仅限于类的内部,因而可以将应用程序修改带来的影响减少到最低限度。</p>
</blockquote>
<p>继承特征</p>
<blockquote>
<p>在面向对象程序设计中,如果已经建立了一个类A,又需要建立另一个与A基本相同,但增加了一些属性和方法的类B,这时没有必要从头设计一个新类,只需在类A的基础上增加一些新的内容即可。<strong>即一个新类可以从现有的类中派生,这个过程称为类继承( Inheritance)。新类继承了原来类的特性,称为原来类的派生类(子类),而原来类称为新类的基类(父类)。</strong><br>利用继承可以简化程序设计的步骤,程序员能通过只对新类与已有类之间的差异进行编码而很快地建立新类,当然也可以对其进行修改或增加新的方法使其更适合特殊的需要。</p>
<p>继承是一种联结类与类的层次模型。继承机制可以方便地利用一个已有的类建立新类,这样可以重用已有软件中的一部分甚至很大的部分,减少了编程工作量,这就是软件重用(SoftwareReusability)的思想。继承提供了一种明确表述共性的方法,允许和鼓励类的重用,不仅可以利用自己建立的类,还可以使用别人建立的或者存放在类库中的类,从而大幅缩短了软件开发的周期;同时,这些已有的类通常都已经进行了反复的测试,无须再进行调试,可以提高软件的质量。</p>
</blockquote>
<p>多态性特征</p>
<blockquote>
<p><strong>多态性(Polymorphism)是指允许不同的对象对同一消息做出不同的响应,执行不同的操作。</strong><br>例如,用同样的加法把两个时间加在一起和把两个整数加在一起的内涵肯定完全不同。</p>
<p>多态性是通过函数重载和虚函数等技术来实现的,第7章介绍的函数重载就是实现多态性的一种手段。利用多态性,可以在基类和派生类中使用同样的函数名,而定义不同的操作,从而实现“一个接口,多种方法”,这是一种在运行时出现的多态性,它通过派生类和虚函数来实现。</p>
</blockquote>
<h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><p>类和结构体类型的关系</p>
<blockquote>
<p>C++的类是由C语言中的结构体类型演变而来的</p>
</blockquote>
<p>类的相关概念</p>
<blockquote>
<p>类的数据部分称为数据成员(Data Member)或者属性( Atribute ) ,类的函数部分称为成员函数(Member Func-tion) ,有时也称为方法。</p>
</blockquote>
<p>类的定义形式</p>
<blockquote>
<p><img src="/blog/fujian/eca925dc9c5a011046d23561dc21acd0.png"><br>在C++中,使用关键字class来定义这种包含数据成员和成员函数的类。类的定义就相当于声明。<br>在声明类时,声明为private , protected和声明为public成员的顺序可以是任意的,可以先出现private部分,也可以先出现public部分,甚至可以包含多个private , protected和 public部分,当然也可以只有 private或只有public 部分。如果没有显式地指定,在类中声明的成员都是私有的。声明为private的成员对外界是隐蔽的,在类外不能直接访问,充分体现了类的封装性。但如果一个类的所有成员都声明为私有的,即只有 private部分,那么该类将完全与外界隔绝,这样的类没有实际意义。一般的做法是在声明类时把数据隐藏起来,而把访问数据的成员函数声明为public ,作为对外界的接口。</p>
</blockquote>
<p>类的定义举例</p>
<blockquote>
<p><img src="/blog/fujian/febb45e28c5f03445485a06cb5b9fc29.png"><br>其中,类的定义以关键字class开始, Point为类的名字,类定义体放在左右花括号之间,用分号终止。Point类定义包含两个无符号整形数据成员x,y和一个成员函数ShowMe( )。<br>类的声明中列出了类的全部成员,包括数据成员和对这些数据操作的函数,数据和操作封装在一起。注意,类的定义体必须用一对花括号括起来,类的声明以分号结束。</p>
<p>Person类的定义<br><img src="/blog/fujian/4ccee257ca86d9762c9f9d81bf3a45a5.png"></p>
</blockquote>
<p>类的定义格式</p>
<p><img src="/blog/fujian/708def421bf54ebbe282fe1b62bdb6b6.jpg"></p>
<p><img src="/blog/fujian/56f14acc1ab8bef82444f70e2d0a1474.jpg"></p>
<h2 id="对象的定义"><a href="#对象的定义" class="headerlink" title="对象的定义"></a>对象的定义</h2><p>对象的定义形式</p>
<blockquote>
<p>&lt;类名&gt;&lt;对象1&gt;，&lt;对象2&gt;,… ;<br>如：Person personl , person2 ;<br>声明了两个名为personl和 person2的Person类的对象。<br>对象是类的实例,声明了类之后,就可以用类名定义该类的对象。一般来说,一个对象就是一个具有某种类型的变量。与普通变量一样,对象也必须先经声明才可以使用。</p>
</blockquote>
<h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><p>成员函数的理解</p>
<blockquote>
<p>类的成员函数是函数的一种,它也有函数名,返回值类型声明和参数表,其操作与普通函数没有任何区别,只是它属于一个类的成员,可以被指定为私有的、保护的或公有的。其中,私有的成员函数只能被本类中其他成员函数所调用,不能被类外调用。某些情况下,一些成员函数只用来支持本类中其他函数的操作,称为工具函数(Utility Function) ,此时可以将它们指定为private,类外用户不能使用这些私有的工具函数。需要被外界调用的成员函数必须被指定为public ,它们是类的对外接口。</p>
<p>成员函数是类十分重要和具有标志性特征的部分,如果一个类中不包含成员函数,它与结构<br>体就没有区别了,只是定义了一种复合数据类型。<br>反过来说，也可以让类只包含属性，来当做结构体来用。</p>
</blockquote>
<p>成员函数的定义</p>
<blockquote>
<p>成员函数可以在类的声明中定义。在类声明中定义的话，就跟普通函数的定义方式一样。</p>
<p>如果类的定义中仅给出了成员函数的原型声明,没有定义函数体,这时就要在类声明的外部来定义成员函数。为了能表示与所属类的关系,需要使用二元作用域运算符“::”。下面是函数在类外的定义形式：<br>&lt;类型&gt;&lt;类名&gt;::&lt;函数名&gt;(&lt;参数表&gt;)<br>{<br>函数体<br>}<br>其中,作用域运算符“::”指出成员函数的类属,即该函数属于哪一个类的成员函数。</p>
<p>。</p>
</blockquote>
<p>举例</p>
<blockquote>
<p>函数在类内的定义<br><img src="/blog/fujian/febb45e28c5f03445485a06cb5b9fc29.png"></p>
<p>函数在类外的定义<br><img src="/blog/fujian/4ccee257ca86d9762c9f9d81bf3a45a5.png"><br><img src="/blog/fujian/e876aba86f1016ed4e3a934dd32595b8.png"></p>
</blockquote>
<h2 id="访问控制权"><a href="#访问控制权" class="headerlink" title="访问控制权"></a>访问控制权</h2><p>类的作用域划分</p>
<blockquote>
<p>类的声明内属于类的作用范围，而对于成员函数来说,无论是在类的声明内定义,还是在类的声明外定义,其函数体也是在类的作用域范围内。（在C++的类的作用域内，可以对其私有成员变量进行操作）</p>
</blockquote>
<p>访问一个类里面的数据的方式</p>
<blockquote>
<p>一般有两种，一个是成员函数的访问，一个是对象的调用。</p>
</blockquote>
<p>对象的调用</p>
<blockquote>
<p>对象调用分两种一个是在类作用域内，一个是在类作用域外。</p>
<p>在类的作用域外,本类的对象只可以访问其公有数据成员或成员函数,这时需使用运算符“.”,例如:person1 . ShowMe( )。如果访问的是一个对象中的私有成员和保护成员，则属于非法操作,将导致编译错误。</p>
<p>在类作用域内，对象就可以访问私有和保护成员。</p>
</blockquote>
<p>成员函数的访问</p>
<blockquote>
<p>所谓的成员函数访问，就是在函数体内去调用。<br>因为函数体是在类的作用域内，所以可以调用类的数据。<br>成员函数体内可以访问同类中的数据成员,或调用同类中的其他成员函数。这时可以直接使用数据成员名或成员函数名.</p>
</blockquote>
<p>对象调用的举例</p>
<blockquote>
<p>class A<br>{<br>private:<br>    int m_para;<br>public:<br>    void Func();<br>}<br>void A::Func()<br>{<br>    A temobject;  &#x2F;&#x2F;定义A类的临时对象<br>    temobject.m_para &#x3D; 1;  &#x2F;&#x2F;对临时对象的私有成员变量进行赋值<br>}</p>
</blockquote>
<p>类的成员的访问控制权限</p>
<blockquote>
<p>在C++中,通过成员的访问控制属性来实现封装。类成员的访问控制权限有3种:私有 ( Private)、公有( Public)和保护( Protected )。<br>公有成员，可以在本类成员函数内被访问 以及被本类对象调用<br>私有成员和保护，只能被成员数访问以及被同类对象在类作用域内被调用。<br>类对象无法在作用域外去调用私有数据和保护数据。</p>
</blockquote>
<h2 id="内联函数和外联函数-inline关键字"><a href="#内联函数和外联函数-inline关键字" class="headerlink" title="内联函数和外联函数(inline关键字)"></a>内联函数和外联函数(inline关键字)</h2><p>内联成员函数理解</p>
<blockquote>
<p>在类内定义的函数，即该函数的<strong>函数体放在类体内</strong>，被默认成内联成员函数。</p>
</blockquote>
<p>外联成员函数理解</p>
<blockquote>
<p>外联成员函数是声明在类体内，定义在类体外的成员函数。(在外联函数的定义开头用inline关键字修饰，该外联函数就变成内联函数。  )，外联成员函数的调用方式，也跟普通函数一样。</p>
</blockquote>
<p>举例</p>
<blockquote>
<p>类A<br><img src="/blog/fujian/2c0b39e38a15c65778e12785f74a92ec.png"><br><img src="/blog/fujian/a044b0f75cb25bf809a49afd8946eafa.png"></p>
<p>主函数<br><img src="/blog/fujian/90fbc4518ec99fdba69580d495ff6841.png"></p>
<p>输出结果<br><img src="/blog/fujian/b8d7fd64a5620b66369541dc61d1c837.png"></p>
</blockquote>
<p>   说明：类A中，直接定义了3个内联函数，又使用inline定义了2个内联函数。</p>
<p>注意</p>
<blockquote>
<p>。内联函数一定要在调用之前进行定义，并且内联函数无法递归调用。内外联函数区别就在于，运行时侯的效率与定义的方法不同。</p>
</blockquote>
<h2 id="对象的存储"><a href="#对象的存储" class="headerlink" title="对象的存储"></a>对象的存储</h2><p>对象存储的理解</p>
<blockquote>
<p>使用类创建对象时,系统会为每一个对象分配一块存储空间。类中包含有数据成员和成员函数,数据和函数的代码都应该有相应的存储空间。现在思考一下,如果用一个类声明了5个对象,系统是否需要分别为这5个对象分配存储数据和成员函数代码的存储空间。</p>
<p>从前面的分析可以看出,给对象赋值都是给对象的数据成员赋值,不同对象数据成员的值是不同的,而其成员函数的代码是相同的,不论调用哪一个对象的成员函数,实际上调用的都是相同的代码。因此,没有必要为每一个对象都开辟存储成员函数的空间。的州个</p>
<p>事实上,C++的编译系统可使用一段空间来存放这个公共的函数代码段,在调用各个对象的成员函数时,都去调用这个公共的函数代码。因此,每个对象的存储空间都只是该对象的数据成员所占用的存储空间,而不包括成员函数代码所占用的空间,函数代码是存储在对象空间之外的。而且,不论成员函数是在类的内部定义还是在类的外部定义,不论成员函数是否用inline声明,其代码段都不占用对象的存储空间。</p>
</blockquote>
<h2 id="类的组合"><a href="#类的组合" class="headerlink" title="类的组合"></a>类的组合</h2><p>类组合定义</p>
<blockquote>
<p>一个类的对象可以作为另一个类的数据成员,称为类的组合(Composition)。</p>
</blockquote>
<p>举例</p>
<blockquote>
<p><img src="/blog/fujian/9d537c7b0eb619774eb76e4f1fc892e6.png"><br>其中Date为一种类。</p>
</blockquote>
<p>注意</p>
<blockquote>
<p>如果成员类也是在本程序中定义的,则应将成员类的定义或声明放在另一个类的前面。如下图。<br><img src="/blog/fujian/23dbc792a326143414299189a608d6dc.png"></p>
</blockquote>
<h2 id="接口与实现分离"><a href="#接口与实现分离" class="headerlink" title="接口与实现分离"></a>接口与实现分离</h2><p>接口与实现分离的目的</p>
<blockquote>
<p>到目前为止,本书中介绍的例子程序都是包含在一个源文件中的。事实上,在实际编程时，通常将类的声明放在一个头文件中,形成类的public接口,并向客户提供调用类成员函数所需的函数声明。类成员函数的定义放在另一个源文件中,形成类的实现方法（公有的成员函数对数据的操作称为类的实现），就类的用户来说,类实现方法的改变并不影响用户的使用,只要类的接口保持不变即可,而类的功能可能扩展到原接口以外。类的用户使用类时不需要关心类的源代码,但客户需要连接类的目标码。</p>
</blockquote>
<p>举例</p>
<blockquote>
<p>Person.h文件<br><img src="/blog/fujian/b1fc6b8584c3bba7317eb40c1fd6840a.png"></p>
<p>Person.cpp文件<br><img src="/blog/fujian/2918ce6c7ddab3496543f8bc4aa473a6.png"></p>
<p>主函数<br><img src="/blog/fujian/ef49558906df6bbf06fa62f90122b3ab.png"></p>
<p>说明<br>Person.h是接口文件，Person.cpp是对接口的实现。主函数调用person接口。<br>具体例子和细节在“多文件编译执行（调用其他文件的函数的方法）”</p>
</blockquote>
<h2 id="构造函数-对象的初始化方式"><a href="#构造函数-对象的初始化方式" class="headerlink" title="构造函数(对象的初始化方式)"></a>构造函数(对象的初始化方式)</h2><h3 id="构造函数的基础知识"><a href="#构造函数的基础知识" class="headerlink" title="构造函数的基础知识"></a>构造函数的基础知识</h3><p>错误的初始化</p>
<blockquote>
<p>类是一种抽象的数据类型,其数据成员不能在声明时初始化。下面的描述是错误的。<br><img src="/blog/fujian/8db9b7d00dbb91de18f8e4f72839a7e8.png"></p>
</blockquote>
<p>对象为什么要初始化</p>
<blockquote>
</blockquote>
<p>与使用变量一样,对象也应该是先赋值,后使用。对象的初始化体现在对数据成员的赋值。对象是一个实体,在使用一个对象时,它的每一个数据成员都应该有确定的值</p>
<p>构造函数的定义（构造函数初始化方式）</p>
<blockquote>
<p>C++专门提供了构造函数(Constructor)来处理对象的初始化。构造函数是类的一个特殊的成员函数,它会在每次生成类对象(实例化)时自动被调用。</p>
</blockquote>
<p>构造函数的声明格式</p>
<blockquote>
<p>类名（参数表）;</p>
<p>即构造函数与类同名,且没有返回值类型。构造函数既可在类外定义,也可作为内联函数在类内定义。构造函数允许重载,提供初始化类对象的不同方法。在生成类对象时,其成员可以用类的构造函数自动初始化。</p>
</blockquote>
<p>构造函数的调用</p>
<blockquote>
<p>Date类的构造函数<br><img src="/blog/fujian/522f6376ef93227384ffc30f3502eeba.png"></p>
<p>定义对象时直接调用<br>Date date1 ( 2006,3,28 ) ;<br>创建对象时date1被初始化为2006年3月28日。</p>
<p>定义对象时，间接调用<br>Date date1&#x3D;Date(2006,328);<br>创建对象时date1被初始化为2006年3月28日。</p>
<p>前面已经说明,构造函数不能由用户直接调用,只能在定义对象时调用，因此实参是在定义对象时给出的。</p>
</blockquote>
<p>构造函数生成匿名对象</p>
<blockquote>
<p>Date(参数)单独写表示生成了一个匿名对象，当前行结束后，该对象立即析构。注意不能利用拷贝构造函数，初始化一个匿名对象，编译器认为是一个对象声明，例如Person(p),编译器会将括号删除，直接表示为 Person p；</p>
</blockquote>
<p>举例</p>
<blockquote>
<p>类声明<br><img src="/blog/fujian/ea16235ab73fa4cade2ae658f4e35334.png"><br><img src="/blog/fujian/1d2ceb3e29995226e620bc5b41dbcb0c.png"></p>
<p>主函数<br><img src="/blog/fujian/44a1c30851ec7960d50f354579cc0a0c.png"></p>
<p>输出结果<br><img src="/blog/fujian/bb8996db1c4937ffcce4bff1c9e1dedf.png"></p>
<p>说明<br>在添加了构造函数之后,在创建对象时,对象的数据成员不再是不可确定的,构造函数自动执行,对数据成员进行赋值。即当遇到说明<br>Date date1 ,date2 ;<br>时,编译器就自动调用无参构造函数<br>Date : : Date( )<br>来创建对象date1和 date2并初始化其数据成员。</p>
</blockquote>
<p>构造函数注意要点</p>
<blockquote>
<ul>
<li>与类的其他成员函数一样,构造函数也可以直接在类的声明中定义,此时它们就是内联构函数。</li>
<li>构造函数是在创建对象时由系统自动调用的,而且只执行一次不需要也不能够被用户调用。例如，下面的用法是错误的：<br> date1 . Date( ) ;</li>
<li>构造函数一般为public类型构造函数没有返回值,不需要在声明时指定返回值的类型。</li>
<li>构造函数的作用是为对象进行初始化,通常由一系列赋值语句构成,但也可以包含其他语句,只是一般不提倡在构造函数中加入与初始化无关的内容。</li>
<li>如果用户没有定义构造函数,则系统会自动生成一个默认构造函数在创建对象时调用只是这个构造函数的函数体是空的,不执行对数据成员的初始化操作。</li>
<li>调用无参构造函数不能加括号，如：Person p();原因是c++会将此代码视为一个函数声明，参考函数声明，如：int test();</li>
</ul>
</blockquote>
<p>拷贝构造函数和赋值运算符重载的区别</p>
<blockquote>
<p>拷贝构造函数是在创建新对象时使用现有对象进行初始化的特殊构造函数。<br>赋值运算符重载是一种特殊的成员函数，用于在已存在的对象上将另一个对象的值赋给它。<br>注意<br>当使用类似 <code>student s1 = s;</code> 或 <code>student s2(s);</code> 的语法来创建对象时，会调用拷贝构造函数。<br>而如果 是<code>student s1； s1=s；</code>它是赋值操作，会调用赋值运算符重载函数来将对象 <code>s</code> 的值赋给已经存在的对象 <code>s1</code>。</p>
</blockquote>
<h3 id="构造函数的重载"><a href="#构造函数的重载" class="headerlink" title="构造函数的重载"></a>构造函数的重载</h3><p>构造函数的重载的定义</p>
<blockquote>
<p>在一个类中可以定义多个构造函数,为类的对象提供不同的初始化方法。这些构造函数有相同的名字,而参数的个数或类型不同,这就是构造函数的重载。</p>
</blockquote>
<p>要点</p>
<blockquote>
<p>如果在定义对象时没有给出参数,对象将通过默认构造函数创建,显然,无参的构造函数属于默认构造函数，一个类只能有一个默认构造函数。</p>
<p>如果在类中用户没有定义构造函数,系统会自动提供一个默认构造函数,只不过其函数体为空,不能对数据成员进行初始化。注意：系统仅在用户没有定义任何形式的构造函数时才会自动提供默认构造函数。</p>
<p>此外,还要注意使用默认构造函数时,不能写成Date date1( );的形式，而是得写程Date date1;</p>
<p>如果类已经仅定义了构造函数Date( int , int，int)而没有定义Date(),那么Date类就没有默认构造函数,此时使用Date date1;来创建对象date1就是错误的。来创建对象datel就是错误的。这是因为Date类已经有一个包含3个参数的构造函数。</p>
<p>尽管一个类可以包含多个构造函数,但对每一个对象来说,创建时只执行其中的一个构造函数。</p>
</blockquote>
<p>举例</p>
<blockquote>
<p>类<br><img src="/blog/fujian/b9f0390e398cf3b2fe90aa2d8b0f9be0.png"><br><img src="/blog/fujian/c727e45004371335166e021af35275bd.png"><br><img src="/blog/fujian/8ae0ef70e1882a38a2375151df7d07d7.png"><br><img src="/blog/fujian/54293d76886146a7d7e981585ace60bc.png"><br><img src="/blog/fujian/ca40a67e2ae910c66e19eba2a2eff904.png"></p>
<p>主函数<br><img src="/blog/fujian/5e675d1b68eb1c79e8e1e813eabbb828.png"></p>
<p>结果<br><img src="/blog/fujian/49870968c95259b1e2aecd95f6cc7c7d.png"></p>
</blockquote>
<h3 id="结构体方式初始化"><a href="#结构体方式初始化" class="headerlink" title="结构体方式初始化"></a>结构体方式初始化</h3><p>结构体方式初始化举例</p>
<blockquote>
<p>如果一个类中所有的成员(包括数据成员和成员函数)都是公有的如下图。<br><img src="/blog/fujian/38686a116a21b8e8b952d6527f68c270.png"></p>
<p>那么在定义对象时可以对数据成员进行初始化。如下图。<br><img src="/blog/fujian/8bdcfdb68690a831fe3864a5ad5cc03d.png"></p>
<p>这种情况类似于结构体。但是,如果类中包含私有的或保护的成员,就不能这样进行初始化,只能使用公有的成员函数对它们赋值。</p>
</blockquote>
<h3 id="new初始化对象"><a href="#new初始化对象" class="headerlink" title="new初始化对象"></a>new初始化对象</h3><p>new调用构造函数初始化对象</p>
<blockquote>
<p>类声明<br><img src="/blog/fujian/eb0d034e40e3d919c352778b646b65b7.png"></p>
<p>main函数<br><img src="/blog/fujian/47ed05bd00a200652fa0ef771e49e5c0.png"></p>
<p>输出结果<br><img src="/blog/fujian/7bfbb4abcb1f910c1ed2c3cb20528ac4.png"></p>
</blockquote>
<p>  注意</p>
<blockquote>
<p>当然,用new建立的对象要用delete释放。</p>
</blockquote>
<h3 id="类内嵌对象初始化"><a href="#类内嵌对象初始化" class="headerlink" title="类内嵌对象初始化"></a>类内嵌对象初始化</h3><p>含内嵌对象的类的对象的初始化方式（内嵌对象的类的构造函数的组成）</p>
<blockquote>
<p>在类的构造函数的声明里，去调用内嵌对象的构造函数，以此来初始化内嵌对象。</p>
</blockquote>
<p>含有内嵌对象的类的构造函数形式</p>
<blockquote>
<p>类名::类名(形参列表):内嵌对象1 (参数列表)，内嵌对象2(参数列表)…<br>{<br>本类成员初始化<br>}</p>
</blockquote>
<p>构造函数调用顺序</p>
<blockquote>
</blockquote>
<p>先调用内嵌对象的构造函数(按照内嵌对象在组合类的定义中出现的次序),后调用本类对象的构造函数(析构函数调用顺序相反)</p>
<h3 id="构造函数的初始化方式"><a href="#构造函数的初始化方式" class="headerlink" title="构造函数的初始化方式"></a>构造函数的初始化方式</h3><p>1普通的初始化方式</p>
<blockquote>
<p>类的定义<br><img src="/blog/fujian/cb77713a1622a5b5657d22e34bd30618.png"></p>
<p>当遇到声明<br>Date date1 ( 2006,3,28) ;<br>时,编译器就调用构造函数<br>Date : : Date( int yy , int mm , int dd)<br>来创建对象date1并用实参初始化其数据成员。</p>
</blockquote>
<p>2引用的方式来初始化</p>
<blockquote>
<p>构造函数的形参还可以是本类的对象的引用,其作用是用一个已经存在的对象去初始化一个新的同类对象,也称为拷贝构造函数。例如，<br><img src="/blog/fujian/ef0835e3a97e5c946a7d59fc24e5d4ba.png"></p>
<p>当遇到声明<br>Date date2( date1 ) ;<br>时,编译器就调用上面的构造函数来创建对象date2 ,并用对象datel初始化date2。</p>
</blockquote>
<p>3使用参数初始化表初始化</p>
<blockquote>
<p>在构造函数的头部使用参数初始化表实现对数据成员的初始化</p>
<p>形式<br><img src="/blog/fujian/9b6784c06858559036928496defe5fc9.png"></p>
<p>例如<br><img src="/blog/fujian/44158c19e4b50fcc63f7c2eb8021c187.png"><br>即在函数首部的末尾加一个冒号,再列出参数的初始化表。上述初始化表中的year(yy)，等价于在函数体内，写year&#x3D;yy;</p>
</blockquote>
<p>4混合初始化方式</p>
<blockquote>
<p>即参数的初始化表和赋值语句相结合的方法。如：<br><img src="/blog/fujian/71f0b84b6fd6112c7fb10d8ee17938a5.png"></p>
</blockquote>
<p>5使用默认参数初始化</p>
<blockquote>
<p>在函数中可以使用带默认值的参数,构造函数也可以包含默认参数,即参数的值既可以通过实参传递,也可以指定为某些默认值。如果用户不指定实参值,编译系统就给形参取默认值。例如<br><img src="/blog/fujian/b416825b6f2c5d40b5a0f8d6f91f4726.png"><br>那么,当按以下方法创建对象时,<br>Date date1 ( 2006 ) ;<br>Date date2 ( 2006,4);<br>Date date3 ( 2006,4,8 ) ;<br>date1初始化为2006年1月1日,date2初始化为2006年4月1日,date3初始化为2006年4月8日。</p>
</blockquote>
<p>用构造函数初始化注意要点</p>
<blockquote>
<p>1.如果构造函数在类的声明外定义,那么构造函数的默认参数应该在类内声明构造函数原型时指定,而不能在构造函数定义时指定。虽然在任意一处指定都能得到正确的结果(不能两处都指定,否则会编译出错),但类的声明是类的外部接口,用户可以看到,而函数的定义作为类的实现细节用户往往是看不到的。因此,声明时指定默认参数,可以保证用户在创建对象时正确使用默认参数。</p>
<p>2.如果构造函数的参数全部指定了默认值,则在创建对象时可以指定一个或几个实参,也可以不给出实参,这时的构造函数属于默认构造函数,例如:<br>Date( int yy &#x3D; 1900 , int mm &#x3D; 1 , int dd &#x3D; 1 ) ;<br>因为一个类只能有一个默认构造函数,因此不能再声明无参的默认构造函数<br>Date( ) ;<br>否则,如用下面的语句创建对象<br>Date date1 ;<br>事实上,对于全部指定了默认值的构造函数,不能再定义其他参数类型与之相同的重载构造函数,否则可能会造成歧义。例如,再声明Date类的一个重载构造函数<br>Date( int , int ) ;<br>如用下面的语句创建对象<br>Date date2 ( 2006,4);<br>编译系统将无法判断应该调用哪个构造函数。因此,一般情况下,不要同时使用构造函数的重载和有默认参数的构造函数。</p>
</blockquote>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>析构函数的定义</p>
<blockquote>
<p>与构造函数相对应,析构函数( Destructor)也是类的一个特殊的成员函数。析构函数在对象撤销时被调用,即当一个对象的生存期结束时,系统将自动地调用析构函数。其本身并不实际删除对象,而是进行一些销毁对象前的扫尾工作,例如用delete运算符释放动态分配的存储空间等。</p>
</blockquote>
<p>（注意如果类的成员用动态存储来申请的空间，我们就必须在析构函数里面去释放动态申请的空间。因为如果没有释放动态申请的空间，这部分空间是不会被系统自动回收，就会产生垃圾。<br>而如果只是普通的数据成员，那么在程序结束后会被系统回收，就不必我们特地在在析构函数里面去回收，也就不必写析构函数了。）</p>
<p>析构函数的说明格式</p>
<blockquote>
<p>~类名（）；</p>
</blockquote>
<p>析构函数的要点</p>
<blockquote>
<p>析构函数名与类名相同,只是在其前面需加上波浪号“~”以与构造函数区分开。<br>析构函数不带有任何参数,因此不能重载。</p>
<p>析构函数没有返回类型。</p>
</blockquote>
<p>举例(为Person增加构造函数和析构函数)</p>
<blockquote>
<p>preson类<br><img src="/blog/fujian/419a049e208aebdbec1cc663cdb69866.png"><br><img src="/blog/fujian/a1e0e7d93c8b6ad8cceba6f4c4423d4f.png"></p>
<p>main函数<br><img src="/blog/fujian/ad7c4ac7188edfe7a2e639216d4bd195.png"></p>
<p>输出结果<br><img src="/blog/fujian/b032b4a1326b11ad431983c2f6d28dc1.png"></p>
<p>说明<br>在创建一个对象时,系统自动调用对象所属类的构造函数。程序结束前,需要清除对象person1 , person2 ,析构函数被自动调用。</p>
</blockquote>
<p>用delete与析构函数的关系</p>
<blockquote>
<p>类A<br><img src="/blog/fujian/91bccb00e1ceb6115093489b52d57007.png"></p>
<p>类B<br><img src="/blog/fujian/71531791a8efc06970099f28c732ec69.png"></p>
<p>未使用delete的main函数和输出结果<br><img src="/blog/fujian/b2818956a8021252ad83e48fb6764eb3.png"><br><img src="/blog/fujian/109c0a3ae5f990c4f08d3a35c4d0a285.png"></p>
<p>使用delete的main函数和输出结果<br><img src="/blog/fujian/04875354093668352f1ee103ae0fbd5a.png"><br><img src="/blog/fujian/8bbd6623e1ef42b53f3fb0e2f0b3759c.png"></p>
<p>分析<br>普通的对象，在程序结束后会被系统回收，也就是被系统撤销。当对象被撤销时，系统会自动调用析构函数。<br>动态存储申请的对象，在程序结束后不会被系统回收，因此也就没有调用析构函数。而当我们用delete去释放用动态存储申请的对象时，那么系统才开始自动调用析构函数。因此凡是用动态申请的对象，都需要在不用的时候用delete进行释放，否则所以程序即使结束了，对象是不会自动析构的，这就产生了垃圾。<br>同时还可以得出delete的执行步骤： 先调用<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020">析构函数</a>然后释放内存。</p>
</blockquote>
<h2 id="String类成员函数"><a href="#String类成员函数" class="headerlink" title="String类成员函数*"></a>String类成员函数*</h2><p><img src="/blog/fujian/003cd765af7c38df82769f9d2a7b1a8d.jpg"></p>
<p><img src="/blog/fujian/6cb54d14ff5e71638cfe9a337b60eca4.jpg"></p>
<p><img src="/blog/fujian/cb261a4a4f3ffdb8c1d7457a8e464535.jpg"></p>
<p><img src="/blog/fujian/8edda9388729f5234365ab204b7b4518.jpg"></p>
<p>248．</p>
<h1 id="对象与指针"><a href="#对象与指针" class="headerlink" title="对象与指针"></a>对象与指针</h1><h2 id="指向对象的指针"><a href="#指向对象的指针" class="headerlink" title="指向对象的指针"></a>指向对象的指针</h2><p>对象指针的理解</p>
<blockquote>
<p>与基本数据类型的变量一样,在创建对象时也会分配存储空间用以保存对象的数据成员。可以声明指向对象的指针,存放对象存储空间的起始地址。</p>
</blockquote>
<p>指向对象指针的定义</p>
<blockquote>
<p>类名 *对象指针名;</p>
</blockquote>
<p>定义举例</p>
<blockquote>
<p>例如Person类,可以声明<br>Person person1;<br>Person * ptr &#x3D; &amp;person1 ;<br>这样, ptr就是指向Person类对象的指针变量,它指向对象person1。注意,对象的地址也使用取地址运算符“&amp;”得到。</p>
</blockquote>
<p>指针访问成员数据的方式</p>
<blockquote>
<p>通过指向对象的指针访问对象的成员要用运算符“-&gt;”,例如：<br>ptr-&gt;ShowMe( ) ;<br>这条语句和<br>person1.ShowMe( ) ;<br>是等价的。</p>
<p>同样,”*“运算符出现在指向对象的指针变量前面,表示对象本身。下面的语句<br>( * ptr ) .ShowMe( ) ;<br>与前面两条语句也是等价的,需要说明的是,使用指针也只能够访问对象的公有成员。</p>
</blockquote>
<h2 id="指向对象成员的指针"><a href="#指向对象成员的指针" class="headerlink" title="指向对象成员的指针"></a>指向对象成员的指针</h2><p> 指向对象成员的指针的理解</p>
<blockquote>
<p>对象中的成员也有地址,可以声明指向对象成员的指针变量,指向对象中公有的数据成员或成员函数。</p>
</blockquote>
<p>指向对象数据成员的指针变量的定义方法</p>
<blockquote>
<p>指向对象数据成员的指针变量的声明方法和指向普通变量的指针完全一样。<br>例如,对于Date 类,可以进行下面的操作:<br>Date date1;&#x2F;&#x2F;声明对象<br>int * p; &#x2F;&#x2F;定义指向整型数据的指针<br>p &#x3D; &amp;date1. year;&#x2F;&#x2F;p指向对象date1的数据成员year<br>*p &#x3D; 2006;&#x2F;&#x2F;给date1的数据成员year赋值2006</p>
</blockquote>
<p>指向对象函数成员指针变量的定义方法</p>
<blockquote>
<p>指向对象成员函数的指针变量的声明方法和指向普通函数的指针有所不同。<br>声明指向对象成员函数的指针必须指明它所属的类。<br>Date datel;&#x2F;&#x2F;声明对象<br>void ( Date : : * p) ( int , int , int );&#x2F;&#x2F;声明指向Date类成员函数的指针p<br>p &#x3D; &amp;Date : : init ;&#x2F;&#x2F;p指向Date类的成员函数init<br>( data1.* p) ( 2006,4,8 );&#x2F;&#x2F;调用对象data1中p所指的成员函数(即init)</p>
</blockquote>
<p>类成员函数的地址以及普通函数的地址</p>
<blockquote>
<p>普通函数的地址: &amp;函数名<br>类成员函数的地址: &amp;类名::函数名字<br>加上类名的原因，是要因为要告诉C++函数所属的类。</p>
</blockquote>
<p>普通函数和成员函数的地址赋值</p>
<blockquote>
<p>普通函数在把地址赋值给函数指针的时候，可以直接用函数名赋值。而类的成员函数要赋值给函数指针，则得在函数名前面加上&amp;类名::。</p>
<p>而普通函数在赋值给函数指针的时候，可以不用取地址符号，直接用函数名，是因为函数名与函数的地址两者的值是一样的，都是函数的首地址，但两者的类型不同，而普通函数的函数名在赋值给函数指针的时候，表达式中会进行类型的转换。<br>函数地址的类型和指向函数的指针是一样的，类型的转换仅在表达式中才会发生,这仅是函数名众多性质中的一个，而非本质，函数名的本质就是函数实体的代表。</p>
<p>而C++非静态成员函数的左值不可获得，因此非静态成员函数不存在隐式左值转换，即不存在像常规函数那样的从函数到指针的隐式转换，因此要获取非静态成员函数的地址，必须在非静态成员函数前使用&amp;操作符才能获得地址。<br>如 &amp;Date : : init  &#x2F;&#x2F;Date类里的成员函数init的地址</p>
<p>而如果是静态成员函数，则就可以像普通函数一样，不用在函数前使用&amp;来取函数地址。 但是以防万一，还是都用&amp;来获取函数的地址。</p>
</blockquote>
<h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>this指针的理解</p>
<blockquote>
<p>每个对象的存储空间都只是该对象的数据成员所占用的存储空间,而不包括成员函数代码所占用的空间。C++为了节省存储空间，把函数代码存储在对象空间之外,让不同的对象调用同一个函数代码段。（这样就不需要每个对象的存储空间都存储函数代码段）<br>为此,C++在成员函数里设立了一个指针,用来指向不同的对象。也就是说，C++在每一个类的成员函数里，都设了一个可以指向本类对象的指针,叫this指针。<br>这个名为this的指针包含了当前被调用的成员函数所在对象的起始地址,<br>对象调用函数的时候，会自动把对象的地址传递到函数的this指针。函数通过这个this指针，就可以获得调用这个函数的对象的数据和成员函数。</p>
</blockquote>
<p>this指针的传递</p>
<blockquote>
<p>this 指针，是对象调用函数的时候，自动进行传递的。<br>因为形参表，以及实参表里面都没有直接使用this 这个参数，所以他是隐式的自动传递的；</p>
</blockquote>
<p>举例</p>
<blockquote>
<p>init函数的声明<br>void Date::init(int yy,int mm,int dd)<br>{<br>this -&gt; year &#x3D; yy ;<br>this -&gt; month &#x3D; mm ;<br>this - &gt; day &#x3D; dd;<br>}</p>
<p>声明了Date类的两个对象date1和date2,执行下列语句<br>date1. init( yy,mm, dd ) ;<br>date2. init( yy,mm, dd ) ;</p>
<p>首先执行date1. init( yy,mm, dd ) 语句的时候，会调用date1的成员函数init,编译器会把对象的起始地址先赋予this 指针,然后调用init函数,执行<br>this -&gt; year &#x3D; yy ;<br>this -&gt; month &#x3D; mm ;<br>this - &gt; day &#x3D; dd;<br>因为当前this指针指向date1 , init函数执行的实际是<br>date1 . year &#x3D; yy ;<br>datel . month &#x3D; mm;<br>date1 . day &#x3D; dd;<br>成员函数访问的是date1的数据成员。</p>
<p>然后执行date2. init( yy,mm, dd ) 语句的时候，调用date2的成员函数init,编译器会把对象的起始地址先赋予this 指针,然后调用init函数,执行<br>this -&gt; year &#x3D; yy ;<br>this -&gt; month &#x3D; mm ;<br>this - &gt; day &#x3D; dd;<br>因为当前this指针指向date2,所以init函数执行的实际是<br>date2 . year &#x3D; yy ;<br>date2 . month &#x3D; mm;<br>date2 . day &#x3D; dd;<br>成员函数访问的是date2的数据成员。</p>
</blockquote>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="与继承有关的一些概念"><a href="#与继承有关的一些概念" class="headerlink" title="与继承有关的一些概念"></a>与继承有关的一些概念</h2><p>为什么要有继承</p>
<blockquote>
<p>一般来说,不同类中的数据成员和成员函数是不会相同的。但有些时候,两个类的内容会出现基本相同或部分相同的情况。例如Person类。<br><img src="/blog/fujian/c2409f8545d6697993812c199bd8c129.png"></p>
<p>如果现在要声明一个学生类,除了包含姓名、年龄、性别等属性外,还有学号和班级信息。可以如下声明一个Student类<br><img src="/blog/fujian/9da6b242859bce4f64ac978f99d82a90.png"><br>可以看出, Student类中的内容很大一部分是Person类中已经具备的,只是增加和修改了很少的一部分。这样,人们自然会想到能否可以利用Person类作为基础,稍做修改和增加一部分新的内容来创建Student 类,以减少重复的工作。而这就是继承功能出现的原因。C++中通过继承机制来处理这样的问题</p>
</blockquote>
<p>继承的理解</p>
<blockquote>
<p>一个新类从现有的类那里获得其已有的特性,这种现象称为类的继承。换句话说,从已有的类产生一个新的类,称为类的派生。在此,已有的类称为“父类”或“基类”,新建立的类称为“子类”或“派生类”。</p>
<p>在建立一个新类时,程序员可以让新类继承已定义基类的所有数据成员和成员函数,而不必重新编写这些数据成员和成员函数。派生类还可以对这些数据成员和成员函数进行增加和调整,使新类具备已有类没有的一些特定的功能。一个基类可以派生出多个派生类,派生类本身也可再作为基类派生出其他的派生类。</p>
<p>通常情况下,派生类需要添加基类所没有的数据成员和成员函数。派生类比基类更具体，可以这样认为派生类是基类的对象，基类是派生类的抽象。</p>
</blockquote>
<p>直接派生类和间接派生类</p>
<blockquote>
<p>A为基类,类B是类A的派生类,类C是类B的派生类,则类C也是类A 的派生类。类B称为A的直接派生类,类C称为类A的间接派生类</p>
</blockquote>
<h2 id="派生类的声明"><a href="#派生类的声明" class="headerlink" title="派生类的声明"></a>派生类的声明</h2><p>声明格式</p>
<blockquote>
<p><img src="/blog/fujian/20b0c287c954a4303202fe5f0ff881ff.png"><br>其中,基类必须是已有的类的名称,派生类名则是新建的类名。继承方式有3种,即公有继承( Public) ,私有继承( Private)和保护继承( Protected )。如果不显式地给出继承方式关键字,系统的默认值是私有继承。不同继承方式下,派生类自身及其对象对基类成员的访问控制权限不同。</p>
</blockquote>
<p>单继承和多继承</p>
<blockquote>
<p>一个派生类可以只有一个基类,这种情形称为单继承;也可以同时有多个基类(这些基类之间可能毫无关系),这种情形称为多继承.另一方面,一个基类可以派生出多个派生类.</p>
</blockquote>
<p>单继承举例</p>
<blockquote>
<p>基类</p>
<blockquote>
<p><img src="/blog/fujian/c2409f8545d6697993812c199bd8c129.png"></p>
</blockquote>
<p>派生类</p>
<blockquote>
<p><img src="/blog/fujian/6e14a7ede08cf066d2314e5d7d661433.png"></p>
</blockquote>
</blockquote>
<p>多继承举例</p>
<blockquote>
<p><img src="/blog/fujian/ead22d4669b43ad4e49f320fc864ec60.png"><br>这是多继承的情形。航天飞机类拥有机翼,起落架和火箭发动机3个属性,同时有着陆和发射两个成员函数。</p>
</blockquote>
<p>^03dff7</p>
<h2 id="继承的过程"><a href="#继承的过程" class="headerlink" title="继承的过程"></a>继承的过程</h2><p>例图</p>
<blockquote>
<p><img src="/blog/fujian/283f3d7c3a9197fa3678c0819e5e0564.png"></p>
</blockquote>
<p>继承过程的理解</p>
<blockquote>
<p>对于派生类的构造而言,并不是把基类的成员和增加的成员简单地加在一起,而是包含三部分工作:<br>(1）从基类接收成员。派生类在继承了基类除构造函数和析构函数以外的所有成员时是没有选择的,不能只接收基类的一部分成员而舍弃另一部分成员。</p>
<p>(2）派生类对基类的扩充。增加新的成员是派生类对基类的扩充,体现了派生类功能的扩展。在上图中派生类Student增加了数据成员Number和ClassName 、成员函数ShowStu( )，Teacher类增加了数据成员Department 和 Salary ,扩充了基类。在<br><img src="/blog/fujian/ead22d4669b43ad4e49f320fc864ec60.png"> 中派生类SpaceShuttle虽然没有直接增加新的成员,但它将Plane类和Rocket类的成员集中在一起,也是对基类扩充的一种方式。</p>
<p>(3）派生类对基类函数的隐藏。隐藏（Hiding）指的是派生类中定义了与基类同名的函数（非虚函数），无论该同名函数的参数是否与基类同名函数一样，派生类的都会隐藏所继承基类的同名函数，使得所继承基类的同名函数在派生类对象上无法直接访问。如果想要调用基类的被隐藏函数，可以使用作用域运算符（::）显式地指明基类名字进行调用。</p>
</blockquote>
<h2 id="派生类的不同继承方式和访问属性"><a href="#派生类的不同继承方式和访问属性" class="headerlink" title="派生类的不同继承方式和访问属性"></a>派生类的不同继承方式和访问属性</h2><h3 id="类成员的访问属性"><a href="#类成员的访问属性" class="headerlink" title="类成员的访问属性"></a>类成员的访问属性</h3><p>类成员的访问属性</p>
<blockquote>
<p>在C++类里，成员具有public、protected、private三种访问权限。</p>
</blockquote>
<p>类里面的数据的访问的方式</p>
<blockquote>
<p>有两种，一个是在类内部访问（成员函数访问），一个是在类外部访问（对象调用）。<br>所谓在类内部访问数据，就是在类的成员函数的函数体内去访问其他成员。此时无论被访问的成员是什么访问属性，在类内部，即在成员函数的函数体内，成员可以被随意的访问。</p>
<p>在类外部访问数据，就是用对象直接去调用成员，此时对象就只能访问公有成员。</p>
</blockquote>
<h3 id="公有继承"><a href="#公有继承" class="headerlink" title="公有继承"></a>公有继承</h3><p>公有继承的理解</p>
<blockquote>
<p>在类的公有继承中<br>基类的公有或者保护属性的成员，在派生类里保持原有属性。基类的私有属性成员，仍然为基类的私有，不可被派生类的成员函数访问以及对象调用。</p>
<p>即派生类的成员函数，可以只直接访问基类公有和保护的数据和成员函数。派生类对象在类作用域外只可以访问，基类的公有成员，在作用域内则可以访问基类的公有和保护成员。</p>
<p>因为基类的私有成员对派生类来说是不可访问的,因此不允许派生类成员函数直接引用基类的私有成员 ,而只能通过基类的公有成员函数来引用基类的私有成员。</p>
</blockquote>
<p>公有继承的举例</p>
<blockquote>
<p>错误举例</p>
<p><img src="/blog/fujian/e1cdfc854f7da546f2724dc84dba8897.png"><br><img src="/blog/fujian/3f7ab889586a8519a6aec19df6764501.png"></p>
<p>正确举例<br>基类<br><img src="/blog/fujian/bbe5555bfe76105d31d51d23399b359e.png"></p>
<p>派生类<br><img src="/blog/fujian/9634fe822641588e0890e5d10722c1a5.png"></p>
<p>main函数<br><img src="/blog/fujian/f576ad75f630324f9257c0cd610ae77d.png"></p>
<p>输出结果<br><img src="/blog/fujian/f43c5e4f3fa3c78d9f6293c868c1fe4b.png"></p>
</blockquote>
<h3 id="私有继承"><a href="#私有继承" class="headerlink" title="私有继承"></a>私有继承</h3><p>私有继承的理解</p>
<blockquote>
<p>在类的私有继承中<br>基类的公有或者保护属性的成员，在派生类变为私有属性。<br>基类的私有属性成员，仍然为基类的私有，不可被派生类的成员函数访问以及对象调用。</p>
</blockquote>
<h3 id="保护继承"><a href="#保护继承" class="headerlink" title="保护继承"></a>保护继承</h3><p>保护继承的理解</p>
<blockquote>
<p>在类的保护继承中<br>基类的公有或者保护属性的成员，在派生类作为为保护属性。<br>基类的私有属性成员，仍然为基类的私有，不可被派生类的成员函数访问以及对象调用。</p>
</blockquote>
<h2 id="派生类的构造函数"><a href="#派生类的构造函数" class="headerlink" title="派生类的构造函数"></a>派生类的构造函数</h2><p>派生类的对象的本质</p>
<blockquote>
<p>假定派生类B公有继承基类A,其示意代码如下:<br><img src="/blog/fujian/c278275726f276ec5eae252e01b3aff1.png"><br><img src="/blog/fujian/1355e7104f513b894fbc54559a347ef0.png"><br>当创建B类对象b后,对象b可以访问x ,y这两个成员。那么,是否可以认为b实际上是下面C类的对象呢?<br><img src="/blog/fujian/8f4929746ef44744b8b12dceeb6381ad.png"><br>从逻辑上看,可以将b看做C类的一个对象,但从本质上讲,b并不是C类的一个对象。实际上,在对象b的创建过程中,会先创建一个基类A的隐含对象,从而使对象b可以访问属于隐含对象的成员x。</p>
</blockquote>
<p>派生类对象的初始化方式（派生类对象的构造函数的组成）</p>
<blockquote>
<p>基类的构造函数和析构函数不能被继承,在派生类中,如果对派生类新增的成员进行初始化,就必须创建派生类的构造函数，来对这些新增成员进行初始化。<br>与此同时,对所有从基类继承下来的成员的初始化工作,还是应由基类的构造函数完成。而要调用基类得构造函数，就得在派生类的构造函数的声明里去调用。<br>如果派生类的成员有对象，且要对这个对象成员进行初始化，那么就要像[[B2.C++类和对象#类内嵌对象初始化]]一样，在派生类的构造函数里，调用内嵌对象的构造函数。</p>
</blockquote>
<p>派生类对象构造函数的形式</p>
<blockquote>
<p><img src="/blog/fujian/075325e3256268de1c33e050d6cd6b01.png"><br>(1）当派生类属于多继承形式时,声明中才会出现多个基类名,若是单继承,则只有一个基类名出现。</p>
<p>(2）若基类使用默认构造函数或不带参数的构造函数,则在派生类声明中可略去“基类名(参数表)”;若此时派生类及内嵌对象都不需初始化,则可以不定义派生类构造函数,即采用默认构造函数。<br>有两种情况必须定义派生类构造函数:一种是派生类本身需要;另一种是基类的构造函数带有参数。</p>
<p>(3）参数总表包含了全部基类和全部内嵌对象的所有参数,同时也应包含派生类新增成员初始化的参数。</p>
<p>(4）派生类构造函数名后面括号内的参数总表包括参数的类型和参数名,而基类构造函数名和内嵌对象名后面括号内的参数表只有参数名而不包括参数类型。这里不是定义基类的构造函数,而是调用基类的构造函数,这些参数是实参而不是形参。</p>
</blockquote>
<p>派生类构造函数的执行次序如下</p>
<blockquote>
</blockquote>
<p>(1）调用基类构造函数,调用顺序按照它们被继承时声明的基类名顺序执行。<br>(2）调用内嵌对象构造函数,调用次序按各个对象在派生类内声明的顺序。<br>(3）执行派生类构造函数体中的内容。</p>
<h2 id="派生类的析构函数"><a href="#派生类的析构函数" class="headerlink" title="派生类的析构函数"></a>派生类的析构函数</h2><p>派生类对象析构函数的组成</p>
<blockquote>
<p>派生类与基类的析构函数没有什么联系,彼此独立,派生类或基类的析构函数只作各自类对象消亡前的善后工作,因此在派生类中有无显式定义的析构函数与基类无关。</p>
</blockquote>
<p>派生类析构函数的执行次序如下</p>
<blockquote>
<p>派生类析构函数执行过程恰与构造函数执行过程相反。首先,执行派生类析构函数,然后执<br>行内嵌对象的析构函数,最后执行基类的析构函数。</p>
</blockquote>
<p>举例</p>
<blockquote>
<p>基类person<br><img src="/blog/fujian/5ded83a73a805d1c959a6269537aa1c1.png"></p>
<p>派生类<br><img src="/blog/fujian/456ab8d8c913004c9b30839e57e705ab.png"></p>
<p>main函数<br><img src="/blog/fujian/b8574670b5b1aa108ecef810ac336d39.png"></p>
<p>输出结果<br><img src="/blog/fujian/12b7eed6b516145d38561634ae8f26f2.png"><br>分析:从输出结果可以清楚地看出,构造函数执行顺序为先祖先( Person张弓长),后客人( Person李木子),最后是自己( Student)。这里Monitor是person类的一个对象,被派生类Student所拥有。</p>
<p>同时,从上述输出结果中可以看出,析构函数的执行次序恰好与构造函数相反,先执行自身的析构函数(Student ) ,而后是客人( Person李木子)的析构函数,最后执行祖先( Person张弓长)的析构函数。</p>
</blockquote>
<h2 id="显式和隐式访问基类成员"><a href="#显式和隐式访问基类成员" class="headerlink" title="显式和隐式访问基类成员"></a>显式和隐式访问基类成员</h2><p> 隐式访问类成员的形式</p>
<blockquote>
<p>类成员被访问时,常见的形式为“对象名.成员名”，<br>或在成员函数体内直接写出成员名。这些都属于隐式访问方法。</p>
</blockquote>
<p>显示访问类成员的形式</p>
<blockquote>
<p>在用对象或者成员函数访问成员的时候，在成员前面加其对应的类名也就是下面的形式。<br>类名::成员名</p>
</blockquote>
<p>隐式和显示访问基类成员的举例</p>
<blockquote>
<p><img src="/blog/fujian/85f6a7a1ec84b2c43326b7b5a349ea1a.png"></p>
</blockquote>
<p> 显示访问的好处</p>
<blockquote>
<ul>
<li>在派生类中覆盖了基类同名成员后,如果要在派生类中访问基类同名成员,必须用显式访问方法。</li>
<li>多继承情况下,多个基类拥有的同名成员在派生类中的二义性。</li>
</ul>
</blockquote>
<p>显示访问的运用举例</p>
<blockquote>
<p>基类Person<br><img src="/blog/fujian/bbe5555bfe76105d31d51d23399b359e.png"></p>
<p>派生类<br><img src="/blog/fujian/3d02b5a6c8a16d429e5f154ea0c5bb2b.png"></p>
<p>main函数<br><img src="/blog/fujian/8f0b8fc4725571a14209e0acd5932f4a.png"></p>
<p>输出结果<br><img src="/blog/fujian/1ed62e22a0e3436f57abd2c7007b9244.png"></p>
</blockquote>
<h2 id="多继承产生的问题和解决"><a href="#多继承产生的问题和解决" class="headerlink" title="多继承产生的问题和解决"></a>多继承产生的问题和解决</h2><p>多继承的理解</p>
<blockquote>
<p>C++的多继承是指一个类可以从多个基类继承成员变量和成员函数的能力。通过多继承，一个派生类可以拥有多个不同的父类，从而获得多个父类的特性和功能。</p>
</blockquote>
<p>多继承的问题</p>
<blockquote>
<ol>
<li>名称冲突：当多个基类中存在同名的成员函数或成员变量时，在派生类中使用这些成员时会产生名称冲突的问题。需要使用作用域解析运算符（::），来显示访问哪个基类的成员，或者在派生类中定义同名成员，覆盖基类相关成员。</li>
<li>菱形继承问题：当一个派生类通过多个路径继承自同一个基类时，可能会出现菱形继承问题。例如，如果类 B 和类 C 都继承自类 A，而类 D 继承自类 B 和类 C，那么在类 D 中就存在两个相同的类 A 的实例，这可能导致二义性和冗余。解决菱形继承的问题，可以用显示访问，或者在派生类中覆盖基类相关成员，或者使用虚继承。</li>
</ol>
</blockquote>
<p>虚继承</p>
<blockquote>
<p>通过使用虚继承，可以确保在继承关系中只有一份共享的基类的成员。这样可以避免派生类中存在多个相同基类的成员的问题。<br>在虚继承中，通过在继承关系中使用关键字 <code>virtual</code> 来标记虚继承。</p>
</blockquote>
<p>虚继承的举例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">    // 基类的成员函数和成员变量</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived1 : public virtual Base &#123;</span><br><span class="line">    // 派生类1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived2 : public virtual Base &#123;</span><br><span class="line">    // 派生类2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class FinalDerived : public Derived1, public Derived2 &#123;</span><br><span class="line">    // 最终派生类</span><br><span class="line">&#125;;</span><br><span class="line">//在上面的示例中，Derived1 和 Derived2 类都使用了虚继承来继承自 Base 类。这样，在最终派生类 FinalDerived 中，只会有一份 Base 类的实例，避免了二义性和冗余的问题。</span><br></pre></td></tr></table></figure>


<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="多态的概述"><a href="#多态的概述" class="headerlink" title="多态的概述"></a>多态的概述</h2><p>多态的两种形式</p>
<blockquote>
<p>在C++中,多态性有两种不同的形式;编译时多态性和运行时多态性。</p>
</blockquote>
<p>编译时多态</p>
<blockquote>
<p>编译时多态性指同一类的不同对象或同一个对象在不同环境下调用名称相同的成员函数,所完成的功能不同。函数(包括类成员函数)的重载和运算符的重载都属于这一类。这种在编译连接阶段完成绑定工作的情况称为静态绑定。</p>
</blockquote>
<p>运行时多态</p>
<blockquote>
<p>运行时多态性是指同属于某一基类的不同派生类对象,在形式上调用从基类继承的同一成员函数时,实际调用了各自派生类的同名函数成员。运行时多态性是通过使用继承和虚函数来实现的,在程序运行阶段完成绑定工作,称为动态绑定,又称晚期绑定或后绑定。</p>
</blockquote>
<p>绑定的理解</p>
<blockquote>
<p>确定了函数调用是调用哪个具体函数。<br>也就是将函数调用与具体函数绑定起来</p>
</blockquote>
<p>静态绑定的理解</p>
<blockquote>
<p>在编译阶段就将函数实现和函数调用绑定起来。<br>也就是说代码运行前，就让具体函数与函数调用绑定。执行程序时可以直接执行。</p>
</blockquote>
<p>动态绑定的理解</p>
<blockquote>
<p>在程序运行的时候才进行函数实现和函数调用的绑定。<br>也就是说程序运行的阶段，才让具体对象的函数与函数调用绑定。增加程序运行时间。</p>
</blockquote>
<p>编译时多态的举例说明（静态绑定的举例说明）</p>
<blockquote>
<p><img src="/blog/fujian/5c8180d857491e0d3fa71c603154f56f.png"><br>将兔子抽象化为一个类后,可以具有许多成员函数。其中“逃生”成员函数,表达了兔子逃命的不同方法。当遇到老鹰袭击时,兔子会使用“兔子蹬鹰”的绝招。当遇到狼的攻击时,兔子则采用“动如脱兔”的逃跑方法。<br>显而易见,这就是函数重载。在使用这些函数时,它们的参数都是在编码时设置好的。即当调用“兔子”类的“逃生”函数时,传入的参数是“老鹰”或“狼”的对象,在编译时就已确定,不会改变。因此,在编译代码时使用哪一个版本的函数,也可以确定。这种多态性就是编译时的多态性。</p>
</blockquote>
<p>运行时多态的举例说明（动态绑定的举例说明）</p>
<blockquote>
<p><img src="/blog/fujian/8f7b30a072af884393c787cf0945aaa6.png"><br><img src="/blog/fujian/f4a10eff5e83301f420e6e8079203a79.png"><br><img src="/blog/fujian/e434c2b8c7c9cecc17b91d3e3d3d8ac2.png"><br>一个小孩得知邻居家养了几个宠物,但不知是猫还是狗。于是,小孩丢一块石头到邻居家院中,以探明真相。这里,宠物作为基类,拥有一个speak( )函数,即发声函数。而猫类和狗类是宠物类的派生类,并各有一个基类speak( )函数的同名覆盖成员函数。类伪代码如上</p>
<p><img src="/blog/fujian/1b8b8773103555019f99b1a8be54c7bd.png"><br>小孩丢石块,相当于调用了宠物类对象的speak( )函数。因为小孩并不知是猫是狗,只知道是宠物。但是,实际接收此消息的却是宠物的派生类对象,如果是猫则给出“miao!miao!”字符串;如果是狗,则给出“wang! wang!”字符串。调用过程的伪代码如上。</p>
<p>由于小孩只知道对象是宠物类,因此 main( )函数定义了宠物类指针p。按照设想:指针p应根据实际情况指向猫类或狗类对象;<br>最后,语句 p -&gt;speak( )调用的应该是p所指向派生类的speak( )函数。<br>按照这种设想,程序在编译阶段并不知道指针p将指向什么对象,所以在编译阶段就无法确定p将调用哪个类的speak( )函数。<br>只有在运行阶段才能确定 p的值,从而动态决定调用哪一个类的speak( )成员函数。这正是运行时多态性的典型形式。</p>
<p>但是,上面的程序段并不会按照设想运行。实际上,当执行上面的程序段时,不论指针p所指对象是宠物类还是其派生类,p -&gt;speak( )都只能调用基类——宠物类的speak( )方法,这是由派生类替代基类对象的原则所决定的。因此,为了学习运行时多态性的实现机制,首先需要了解派生类对象替代基类对象的一些知识。</p>
</blockquote>
<h2 id="派生类对象替换基类对象"><a href="#派生类对象替换基类对象" class="headerlink" title="派生类对象替换基类对象"></a>派生类对象替换基类对象</h2><p>替换的原则</p>
<blockquote>
<p>公有派生类全面继承了基类的成员及其访问权限,因此只有公有派生类对象才可以替代基类对象做本来由基类对象所做的事情。</p>
</blockquote>
<p>替换的形式</p>
<blockquote>
</blockquote>
<p>(1）派生类对象给基类对象赋值。<br>(2）派生类对象给基类对象的引用赋值。<br>(3）派生类对象的地址赋值给基类指针。（也就是令基类对象的指针指向派生类对象）</p>
<p>三种替换的举例</p>
<blockquote>
<p>类的声明<br><img src="/blog/fujian/f55878d84b3d0704eeec54991fa91b85.png"></p>
<p>main函数<br><img src="/blog/fujian/58d7eb69d93daa6ae25cf599c2b300ff.png"></p>
<p>输出结果<br><img src="/blog/fujian/4de95c538668a53082756ac46227313e.png"></p>
<p>注意，上面不论哪一种情形,派生类对象替代基类对象后,只能当作基类对象来使用。不论派生类是否存在同名覆盖成员,这样的基类对象所访问的成员都只能来自基类。而要想实现运行时多态性，还得了解虚函数的相关知识。</p>
</blockquote>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>虚函数的定义</p>
<blockquote>
<p>根据派生类替代基类对象的原则,可以用基类对象指针指向派生类对象,但只能访问基类的成员。为了实现多态性,即能够通过指向派生类的基类指针,访问派生类中同名覆盖成员函数,因此需要将基类的同名函数声明为虚函数。<br>则当基类指针指向包含虚函数的派生对象时,C＋+会根据该指针所指的对象类型决定调用的这个的对象的虚函数版本。这一决定是在运行时做出的,因此当指针指向不同的对象时,就执行该对象的虚函数的版本。这同样适用于基类引用。</p>
</blockquote>
<p>虚函数的形式</p>
<blockquote>
<p>virtual 函数返回类型 函数名(参数表)<br>{<br>函数体<br>}<br>虚函数是一个成员函数,该成员函数在基类内部声明并且被派生类重新定义</p>
</blockquote>
<p>虚函数使用多态的原理</p>
<blockquote>
<p><img src="/blog/fujian/f2be3b728ccfd44e79f9da0d640f4512.png"><br><img src="/blog/fujian/94b57662db9ddb5b06bbe77301d0fbb1.png"><br><img src="/blog/fujian/1d816e535a3aa1487163664eae917d30.png"></p>
</blockquote>
<p>[[304-多态的实现原理、成立条件、作用.mp4#t&#x3D;00:23.207,03:55]]</p>
<blockquote>
<p>注意<br>虚函数表是针对类的，类的所有对象共享这个类的虚函数表，因为每个对象内部都保存一个指向该类虚函数表的指针vptr<br>^c4d3e3</p>
</blockquote>
<p>举例</p>
<blockquote>
<p>基类<br><img src="/blog/fujian/62296f9e1ebe9f835e0c6531ae0d0218.png"></p>
<p>派生类<br><img src="/blog/fujian/cae166653372d5525103a308ad792378.png"></p>
<p>派生类<br><img src="/blog/fujian/fc3098460eb8b60b1c935abe86073859.png"></p>
<p>主函数<br><img src="/blog/fujian/c32cc675e0180d9cfb34b82104a1d2e8.png"></p>
<p>结果<br><img src="/blog/fujian/3767b91e68915be778288e11aa2137e3.png"></p>
</blockquote>
<p>派生类重定义虚函数</p>
<blockquote>
<p>在派生类中重定义的基类虚函数的过程就叫重写（Override），通过相同的函数名来覆盖基类中的虚函数。在派生类重写的函数仍为虚函数,同时可以省略virtual关键字。虚函数重定义时,函数的名称、返回类型、参数类型、个数及顺序与基类虚函数完全一致。<br>如果在重新定义虚函数时改变了它的原型,那么该函数只能被认为是由C++编译器重载的,其虚函数特性也将丧失。如果修改例12-1中Cat类的Speak( )函数为<br><img src="/blog/fujian/b04af350a3196fcaaf1c5a5c6e2e5d84.png"><br>则此函数就变为一般函数重载,以下程序段<br><img src="/blog/fujian/8d55cbafdad03c49c5dd82bd49a5305c.png"><br>的最后一句就调用了基类的成员。</p>
</blockquote>
<p>虚函数的使用说明</p>
<blockquote>
<p>(1) 派生类对象替换基类对象有三种形式，但只有后两种，也就是用派生类对象初始化基类对象的引用，以及用基类对象的指针指向派生类对象这两种替换方式，才可以用指针或引用来调用访问派生类中同名覆盖的虚成员函数。<br>如果用第一种形式，也就是派生类对象给基类对象赋值，此时基类对象所访问的就不是派生类中同名覆盖的虚成员函数，而是基类自身的同名函数</p>
<p>(2)引用有其自身的特点,即引用一旦初始化后,就无法重新赋值。例如,在main( )函数中,采用下面的语句<br><img src="/blog/fujian/c1bb76b4a52b6e6f241eb887293de152.png"><br>上面语句p2&#x3D; &amp;c1错误,因为p2被初始化为d1后,不能进行修改,所以采用引用实现方式显然不够灵活,最好的方式是使用指针调用。</p>
<p>(3)不能定义虚构造函数的原因<br>虚函数的调用依赖于指针vptr，而指向虚函数表的指针vptr需要在对象构造期间进行初始化，所以无法调用定义为虚函数的构造函数。</p>
<p>(4)基类析构函数定义为虚函数的原因<br>为了实现动态绑定，基类指针指向派生类对象，如果析构函数不是虚函数，那么在对象销毁时，就会调用基类的析构函数，只能销毁派生类对象中的部分数据，所以必须将析构函数定义为虚函数，从而在对象销毁时，调用派生类的析构函数，从而销毁派生类对象中的所有数据。</p>
</blockquote>
<p>虚析构函数的语法</p>
<blockquote>
<p>virtual ~类名( ) ;</p>
</blockquote>
<h2 id="抽象类和纯虚函数"><a href="#抽象类和纯虚函数" class="headerlink" title="抽象类和纯虚函数"></a>抽象类和纯虚函数</h2><p>纯虚函数的形式</p>
<blockquote>
<p>virtual 返回类型 函数名(参数表)&#x3D;0；</p>
<p>容易看出,纯虚函数与虚函数的不同就是在虚函数的最后加上“&#x3D;0”。</p>
</blockquote>
<p>纯虚函数的要点</p>
<blockquote>
<ul>
<li>纯虚函数在基类声明后,不能再定义其函数体,具体实现过程只能在派生类中完成。纯虚函数仅仅是为了实现多态性而存在的。</li>
<li>当一个虚函数变为纯虚函数时,其派生类必须给出自己的定义覆盖该纯虚函数,否则将导致编译错误。</li>
</ul>
</blockquote>
<p>抽象类的定义</p>
<blockquote>
<p>至少包含一个纯虚函数的类称为抽象类。</p>
</blockquote>
<p>抽象类的要点</p>
<blockquote>
<ul>
<li>抽象类不能实例化,即不能声明抽象类对象。如果 Pet为抽象类,则语句Pet p1是错误的。</li>
<li>抽象类只作为基类被继承,无派生类的抽象类毫无意义。</li>
<li>可以定义指向抽象类的指针或引用,这个指针或引用必然指向派生类对象,从而实现多态性。</li>
</ul>
</blockquote>
<p>抽象类的理解</p>
<blockquote>
<p>当把类看做一种数据类型时,通常认定该类型的对象是要被实例化的。但是,在许多情况下,定义不实例化对象的类也很有用处,这种类称为抽象类( Abstract Class)。因为抽象类要作为基类被其他类继承,所以通常也将其称为抽象基类(Abstract Base Class )</p>
<p>抽象类的唯一用途是为其他类提供合适的基类,其他类可从这里继承和实现接口。能够建立实例化对象的类称为具体类(Concrete Class),具体类具有足以能够建立实例化对象的明确含义。</p>
</blockquote>
<p>举例</p>
<blockquote>
<p>基类pet<br><img src="/blog/fujian/42b7b15d1e334cc0e4b98215c053b360.png"><br><img src="/blog/fujian/b10228904f54f8ba476d409e726075b4.png"></p>
<p>派生类Cat<br><img src="/blog/fujian/5596d2337313029bdcef3a072ede7bf5.png"><br><img src="/blog/fujian/ace31e6e680ea0a52d991ee0a7a5ff51.png"></p>
<p>派生类dog<br><img src="/blog/fujian/792b6717fd52b8913625ba88f7c24118.png"><br><img src="/blog/fujian/e92ca4a602e7cf2ed283587572ff19c8.png"></p>
<p>主函数<br><img src="/blog/fujian/f4d228f3ab5a8567fe34d837b98714b6.png"></p>
<p>结果<br><img src="/blog/fujian/5ab0ee95d8cf277bee3bceba1bc66416.png"></p>
</blockquote>
<p>普通成员函数、虚函数、纯虚函数三者在继承中的</p>
<blockquote>
<p>虚函数<br>派生类可以选择重写也可以不重写,如果不写,就使用直接基类中的该函数。如果直接基类也没写,再往上查找间接基类中的该函数,如此往上找到为止。</p>
<p>纯虚函数？<br>纯虚函数一定要在子类中实现。但是不一要在直接子类中实现，可以是子子类。如果子类实现了，子子类就不用实现。而子类没实现的话，子子类就必须需要实现，同时他的子类没有实现这个纯虚函数，子类也是纯虚函数，也不可以被实例化！如下图<br><img src="/blog/fujian/7033678c7f659651fa2b7041817516f5.png"></p>
<p>普通函数<br>派生类可以选择重写也可以不重写。<br>重写的话,如果函数名相同,返回类型或者参数不同,编译器会自动辨别使用哪个函数。如果函数名,返回类型和参数都相同,则把基类的函数覆盖掉了。<br>需要使用基类的函数时,可以这样写，派生类对象.基类名称::函数名(参数);</p>
</blockquote>
<h2 id="static修饰成员（静态成员）"><a href="#static修饰成员（静态成员）" class="headerlink" title="static修饰成员（静态成员）"></a>static修饰成员（静态成员）</h2><p>静态数据成员的理解</p>
<blockquote>
<p>在说明一个某类的对象时,系统将为该对象分配一块内存用来存放类中的所有成员,即在每一个对象中都存放有其所属类中所有成员的副本。但在有些应用中,希望程序中同类对象共享某个数据。对此,一种解决方法是将所要共享的数据说明为全局变量,但这会破坏数据的封装性;较好的解决方法是将所要共享的数据说明成类的静态成员。<br>类中用关键字static修饰的数据成员是静态数据成员,静态数据成员就会被所有对象共享。</p>
</blockquote>
<p>静态数据成员的声明</p>
<blockquote>
<p><img src="/blog/fujian/f1cca586812de279f9616f66bc3e715d.png"><br>类MyClass 中有两个数据成员x和Count,前者为普通数据成员,在对象MemberX和 MemberY中都存在有各自的该数据成员的副本;<br>后者为静态数据成员,在所有类MyClass对象中的该成员实际上是同一个变量。C++编译器将静态数据成员存放在静态存储区,该存储区中的数据被类的所有对象所共享。<br>在类中说明的静态数据成员属于引用性说明,在使用静态数据成员之前,还必须对静态数据成员进行定义性说明,同时也可对其进行初始化。上例中的倒数第⒉行就是对静态数据成员Count的定义性说明。<br>静态数据成员的定义性说明，不能再main函数里进行定义。</p>
</blockquote>
<p>静态数据成员的调用</p>
<blockquote>
<p>静态数据成员的调用方式，与普通的数据成员调用方式是一样的，只不过静态数据成员会被所有对象共享。<br>其次，如果静态数据成员是public，则它也可以被用类名来调用。具体的方式就是类名::静态数据成员</p>
</blockquote>
<p>静态成员函数的理解</p>
<blockquote>
<p>用static关键字可以把类普通的成员函数声明为静态成员函数。<br>静态成员函数是没有this指针的，这就说明在调用静态成员函数的时候，函数没有this指针，无法获得调用对象的信息，因此静态成员函数只能访问类中的静态成员。如果要访问类中的非静态成员,必须借助对象名或指向对象的指针。</p>
<p>C++的实现里，为了节省内存而将一个类所有对象的成员函数只保存一个副本，而这本质上与静态成员的存储方式是一样，因此静态成员函数仅在逻辑上有意义。<br>静态成员函数的作用，就是可以不用对象，直接用类名调用。</p>
</blockquote>
<p>静态成员函数的声明</p>
<blockquote>
<p><img src="/blog/fujian/6c48c6998d9d0174415451a74668675b.png"><br>静态成员函数与其他成员函数一样,也可以说明为内联的,但不能说明为虚函数。</p>
</blockquote>
<p>静态成员函数的调用方式</p>
<blockquote>
<p>静态成员函数是没有this指针的，那么在调用静态成员函数的时候，就不需要对象来传递地址，也就是说可以不用对象来调用，可以直接调用。<br>直接调用方式就是<strong>类名::成员函数</strong><br>当然也可以用对象来调用<strong>对象名.成员名</strong>，但是对象在调用的时候，就不会传递地址给函数。</p>
</blockquote>
<h2 id="const修饰成员"><a href="#const修饰成员" class="headerlink" title="const修饰成员"></a>const修饰成员</h2><p>const修饰对象的理解</p>
<blockquote>
<p>与普通变量一样,可使用关键字const 修饰对象。C++规定,对于const对象,只能访问其中也用const 修饰的成员函数,<br>如果定义一个类的普通对象,则无论成员函数是否const 均可调用。</p>
</blockquote>
<p>const修饰成员函数</p>
<blockquote>
<p>即 const成员函数。在const成员函数中不得修改类中的任何数据成</p>
</blockquote>
<p>const修饰对象和成员函数的举例</p>
<blockquote>
<p><img src="/blog/fujian/5d14f92fb4ab46a92bd8388ea2a5fadc.png"><br>其中成员函数ConstFunc( )就是const 成员函数(注意修饰符const的位置)。</p>
<p><code>const MyClass ConstObj(3)</code>&#x2F;&#x2F;定义了一个MyClass类的const对象<br><code>int i = ConstObj.ConstFunc();</code>&#x2F;&#x2F;调用合法<br><code>int j = ConstObj.NormalFunc();</code>&#x2F;&#x2F;调用不合法 </p>
</blockquote>
<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>运算符重载的理解</p>
<blockquote>
<p>在C++中,运算符和函数一样,也可以重载,使它们能够完成和创建与类有关的特殊操作。通过创建运算符函数,可以重载运算符。运算符函数定义了重载运算符将要执行的操作,该操作与其作用的对象有关。运算符函数使用关键字operator创建。</p>
</blockquote>
<p>运算符函数的定义</p>
<blockquote>
<p><code>&lt;类型&gt;&lt;类名&gt; :: operator&lt;操作符&gt;(&lt;参数表&gt; )&#123;...&#125;</code><br>“类型”为函数的返回值类型,即运算付的运算结果值的类型;<br>“类名”为该运算符重载所属类的类名;<br>而“操作符”即所重载的运算符,可以是C++中除了“<code>::</code>”、“<code>.</code>”、“ <code>*</code>”(访问指针内容的运算符,与该运算符同形的指针说明运算符和乘法运算符允许重载)和“<code>?:</code>”以外的所有运算符。</p>
</blockquote>
<p>举例</p>
<blockquote>
<p><img src="/blog/fujian/6bf6c3fb85daa7e07992f48c2cb46dfb.png"><br><img src="/blog/fujian/721d2e845cc139ccd11931412cd4ffc6.png"><br><img src="/blog/fujian/b813aa3bc65b0683b89368d090c73465.png"><br><img src="/blog/fujian/9e890d8346c5bd132557028cf89ac7fa.png"><br><img src="/blog/fujian/66e96fda40a1ce67669d093a015c3e5e.png"><br><img src="/blog/fujian/46d0215a56e31f4812b8e83ef9a0c73d.png"></p>
<p>上述例子<br>C1+C2，可以理解为C1.OPERATOR+.(C2)<br>对象C3使用函数&#x3D;，参数是C1；</p>
</blockquote>
<p><img src="/blog/fujian/93aca0578cf3017cb119e66d9be6135c.png"><br><img src="/blog/fujian/14e4e1b3af9bf5f320707390b052be5d.png"><br><img src="/blog/fujian/06dba922d9ccf5247f3b0ce94cad8f8a.png"></p>
<h2 id="override关键字"><a href="#override关键字" class="headerlink" title="override关键字"></a>override关键字</h2><p>理解</p>
<blockquote>
<p>如果派生类在所继承的虚函数的声明时使用了 <code>override</code>描述符，那么派生类就必须重新这个虚函数，否则代码将无法通过编译。</p>
<p>也就是说，如果派生类里面有需要重写的虚函数，那么可以加上关键字 <code>override</code>，这样编译器就会提醒你记得重写，并且在不小心漏写了虚函数重写的某个苛刻条件的时候，编译器还会辅助检查是不是正确重写。</p>
<p>而如果没加这个关键字 也没什么严重的 <code>error</code> 只是少了编译器检查的安全性；</p>
</blockquote>
<p>举例说明</p>
<blockquote>
<p>基类<br><img src="/blog/fujian/7e42966ef98d5f2c2cb46c1e257bf3e4.png"><br><img src="/blog/fujian/9ee79d6313d9fb4d2d3ad5b8b70106f7.png"></p>
<p>派生类<br><img src="/blog/fujian/a84acd51d06995002f74e6f03b1d8495.png"></p>
<p>说明<br>派生类继承的虚函数用了override关键字，那么如果虚函数书写错误，则编译器会报错</p>
</blockquote>
<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="模板的基础知识"><a href="#模板的基础知识" class="headerlink" title="模板的基础知识"></a>模板的基础知识</h2><p>模板的概念</p>
<blockquote>
<p>在程序设计中往往存在这样的两种情况,一种是两个或多个函数的程序结构相同，区别仅在于其参数类型或函数返回类型不同;另一种是两个或多个类的结构相同,差别仅在于部分类的成员的类型或成员函数的类型及参数的类型不同。不论哪种情况,其程序框架都基本相同,只是具体细节不同。C+＋提供了模板(‘Template)机制,利用这一机制,可简化程序代码,实现软件复用。</p>
</blockquote>
<p>C++的模板类型</p>
<blockquote>
<p>C++有两种模板类型:<br>(1)函数模板:是一种抽象通用的函数,用它可生成一批具体的函数。这些由函数模板经实例化生成的具体函数称为模板函数。<br>(2)类模板:是一种抽象通用的类,用它可生成一批具体的类。这些由类模板经实例化生成的具体类称为模板类。</p>
</blockquote>
<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>函数模板理解</p>
<blockquote>
<p>函数模板可以用来创建通用的函数,其作用类似函数重载,但其编码却比函数重载简单得多。</p>
</blockquote>
<p>函数模板的定义形式</p>
<blockquote>
<p>定义形式<br><img src="/blog/fujian/cd5047bdd5a665551bd981a7be4b22c3.png"></p>
<p>模板函数定义说明<br>模板参数表中的模板参数形式为，<code>class 类型参数</code>。其中，关键字<code>class</code>与一般所讲的类无关,而是与<code>类型参数</code>一起，来说明<code>类型参数</code>就是一个通用数据类型，<code>类型参数</code>可以是任何一个合法的标识符。<br>在构建函数模板时，类型参数可以写在函数模板中的类型的位置上，替换掉具体的数据类型，这时原本是一个具体的数据类型，变成一个通用的数据类型。比如，我们把这个类型参数，写在函数里的传入参数的数据类型的位置。作用是在调用这个模板函数时，可以传入不同的数据类型的参数，根据实际传入的参数，来变换对应数据类型，而不是只能传入某种数据类型的参数。所以说，函数模板可以做到类型通用的作用。</p>
</blockquote>
<p>函数模板的举例</p>
<blockquote>
<p>函数定义<br><img src="/blog/fujian/97736a9bcb6420605a0d2a2f707eae7d.png"></p>
<p>主函数<br><img src="/blog/fujian/71f5907da216003310a56d44f2f1b0f3.png"></p>
<p>输出结果<br>Type int : 5<br>Type double :5.2<br>Type string : xjtu</p>
</blockquote>
<p>模板函数的调用</p>
<blockquote>
<p>模板函数可以直接被调用，此时他会根据你传输的数据类型，来改变类型参数。<br>以int test(T a1,T a2)函数举例，当我用整形数据传入函数来调用函数，如test(1,2)，那么test函数里的T类型就会转换成我传入的参数的类型。也就是根据 传入的参数类型，来改变类型参数。<br>而如果以这种方式调用函数，就会有一个局限性，那就是得保证给模板函数传入数据的类型是统一的。如果不统一就会报错，如test(1,2.0),此时test函数里的T，就不知道该转换成跟1类型，还是该转换成2.0一样的类型。</p>
<p>另外还有一种调用方式，就没有这种局限性，就是在调用时指定类型参数的数据类型。还是以int test(T a1,T a2)函数举例， 调用的时候指定类型参数的数据类型，如test&lt;\int&gt; (5,6.2),此时无论所给实参是什么类型，test函数里的T就会转成int类型。又因为test里的T是int类型，也就是说test里的a1,a2都是是int类型，那么哪怕你传入的实参是6.2，在传给a2的时候，也会被转成int类型，此时a2的值就是6。</p>
</blockquote>
<p>定义函数模板的注意要点</p>
<blockquote>
<ol>
<li>在函数模板的定义里，参数表以及函数的返回值类型中,至少有一个类型为模板的类型参数。</li>
<li>模板中可以带有多个参数类型。如：<br><img src="/blog/fujian/920609334303a32a84a511f412c7006a.png"></li>
<li>函数可以带有模板参数表中未给出的、但已存在的数据类型的参数。如：<br><img src="/blog/fujian/8339a18334cd453640eb7db93421dad4.png"></li>
</ol>
</blockquote>
<p>重载函数和函数模板之间的关系</p>
<blockquote>
<p>由函数模板产生的模板函数都是同名的,因此模板函数和重载是密切相关的,编译器使用重载的方法来调用相应的函数。<br>函数模板本身可以用多种方法重载,也可以用其他非模板函数重载,只要它们满足函数名相同,而函数参数不同的重载条件即可。<br>在对函数模板重载时,C++规定,在这种情况下,编译器首先匹配重载的函数,只有在重载的函数类型无法匹配时才使用函数模板。如果编辑器通过这样的匹配过程之后,结果却找不到或产生多个匹配,就会产生编译错误。<br>恰当运用这种机制,可以很好地处理一般与特殊的关系。</p>
</blockquote>
<p>typename关键字</p>
<blockquote>
<p>关键字typename和class 在声明template参数时是等价的, typename 比 class后推出,它解决了某些情况下关键字多义性造成的问题,但某些老的编译器可能不支持,故本书仍采用class作为关键字,下同。</p>
</blockquote>
<h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><p>类模板的理解</p>
<blockquote>
<p>C++的类模板可以用来创建适应多种数据类型的类。编写了类模板之后，我们就可以使用这个类模板生成不同数据类型的模板类，从而提高代码的重用性和可维护性。</p>
</blockquote>
<p>类模板的定义</p>
<blockquote>
<p><img src="/blog/fujian/2a7d48f825336230f579f6aac3db27f6.png"></p>
</blockquote>
<p>类模板的定义举例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//数据节点，用结构体模板定义</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    T date;        //用来存储数据</span><br><span class="line">    Node&lt;T&gt; *next; //用来存储</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//单链表，用类模板定义</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">class DLB</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    Node&lt;T&gt; *head;//单链表的头指针，头指针指向的第一个节点为头结点。</span><br><span class="line">    int sl;//数量，表示当前容器的元素数量。</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    //链表的初始化函数，用来初始化你的链表。</span><br><span class="line">    DLB();</span><br><span class="line">    </span><br><span class="line">    //插入函数，指定表格的位置，插入你的数值。pos是你指定的位置，value是你要插入的值，既你要把数据插入到第pos-1的结点的后面，如果pos为1，就是要把数据插入到头结点的后面。插入成功返回true，否则返回false；</span><br><span class="line">    bool insert_DLB(int pos, T value);</span><br><span class="line"></span><br><span class="line">    //位置查找函数，根据传入的位置，查找该位置的数据。pos是传入的位置。</span><br><span class="line">    T findbypos_DLB(int pos );</span><br><span class="line"></span><br><span class="line">    //链表的释放函数，在链表结束后，用来释放你的链表。</span><br><span class="line">    ~DLB();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//如在测试函数李，如果执行DLB&lt;int&gt; a,这时候对象a里面的所有T数据类型，就会变成int类型。</span><br></pre></td></tr></table></figure>

<p>类模板的外联成员函数定义说明</p>
<blockquote>
<p>在定义模板类时，如果要在类外定义模板类的成员函数的时候，无论成员函数中是否用到模板参数，在类外定义时，都有遵循函数模板的定义形式去定义他们，因为类模板的成员函数都被认为是函数模板。如下，所有的参数类型都必须在类名后一一列出。<br><img src="/blog/fujian/05f55da95ff5f8c4cab42f5ab301b55b.png"></p>
</blockquote>
<p>模板类的外联成员函数定义举例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T,int Max&gt;</span><br><span class="line">SXZ&lt;T,Max&gt;::SXZ()</span><br><span class="line">&#123;</span><br><span class="line">    //更新top指针</span><br><span class="line">    top=-1;</span><br><span class="line">    //更新数量</span><br><span class="line">    sl=0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>类模板对象的定义形式</p>
<blockquote>
<p><img src="/blog/fujian/b5b185f24a809e8f40404f2b26860d9e.png"><br>其中，<code>类型实参</code>是任何已存在的数据类型,也可以是非模板类。如果模板类带有多个参数类型,则除默认参数外的所有参数都必须给出其实参类型。</p>
</blockquote>
<p>模板类对象的定义举例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DLB&lt;int&gt; a;</span><br><span class="line">此时a对象里面的所有T就变成int类型。这也是最能直观看出模板类的作用</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>类模板的举例</p>
<blockquote>
<p><img src="/blog/fujian/b206279b07f052fe64c650a8a94c1324.png"><br><img src="/blog/fujian/cd9d6d4b7a031408d4aaf9efd8b15932.png"><br><img src="/blog/fujian/91ebdf8ff735887cafd095915e0d0189.png"><br><img src="/blog/fujian/84fe826295ded09add9866010db3e9a6.png"></p>
</blockquote>
<h2 id="结构体模板"><a href="#结构体模板" class="headerlink" title="结构体模板"></a>结构体模板</h2><p>结构体模板的定义举例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    T date;        //用来存储数据</span><br><span class="line">    Node&lt;T&gt; *next; //用来存储</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//结构体初始化</span><br><span class="line">//Node&lt;T&gt; a;</span><br><span class="line">//Node&lt;T&gt; *a=new Node&lt;T&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="不同模板参数的作用"><a href="#不同模板参数的作用" class="headerlink" title="不同模板参数的作用"></a>不同模板参数的作用</h2><p>类型模板参数的作用</p>
<blockquote>
<p>模板参数列表里的模板参数，为类型模板参数，其作用让类里的各种数据类型变成通用的数据类型。<br>“模板参数表”中的类型模板参数的形式为<code>class 类型参数</code>(或新的关键字<code>typename 类型参数</code>)，也就是说在构建类模板时，类型参数可以写在类模板中的类型的位置上，替换掉具体的数据类型，这时原本是一个具体的数据类型，变成一个通用的数据类型。</p>
<p>如上述用类模板定义的单链表，这时候用这个类创建一个具体的对象，并且传递一个类型，如<code>DLB&lt;int&gt; a,</code>这时候对象a里面的所有T数据类型，就会变成int类型。</p>
</blockquote>
<p>非类型模板参数的作用</p>
<blockquote>
<p>模板参数列表里的模板参数，为非类型模板参数，其作用就是用就是给类(函数)模板传递信息，在类(函数)模板中可将该参数当成<strong>常量</strong>来使用。</p>
</blockquote>
<p>非类型模板参数的使用举例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T,int N = 10&gt;</span><br><span class="line">class Mystack</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	//...</span><br><span class="line">private:</span><br><span class="line">	T a[N];</span><br><span class="line">	int top;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Mystack&lt;int,100&gt; st1; //类模板里的N就变成常数100</span><br><span class="line">	Mystack&lt;int,200&gt; st2; //N变为常数200</span><br><span class="line">	Mystack&lt;int&gt; st3; //不给参数，N就会是我们在参数模板设置的常数10 </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="模板特例化"><a href="#模板特例化" class="headerlink" title="模板特例化"></a>模板特例化</h2><p>模板特例化的理解</p>
<blockquote>
<p>当我们使用模板编程时，有时候需要为特定的类型或参数提供专门的实现。模板特例化允许我们为特定的类型或参数提供专门的实现，当遇到这些特定的类型或参数时，就会调用我们特地去定义的实现。</p>
</blockquote>
<p>模板特例化的分类</p>
<blockquote>
<p>模板特化可以分为两种类型：完全特化（Full Specialization）和部分特化（Partial Specialization）。<br><strong>完全特化是指对模板的所有参数都进行了具体的类型或值的特化。</strong> 完全特化的定义将完全取代通用模板的实现，提供了针对特定参数的定制实现。<br><strong>部分特化是指对模板的部分参数进行特化，而另一部分参数仍保持通用的模板形式。</strong> 部分特化允许我们为一组参数提供特定的实现，而其他参数仍使用通用模板的实现。</p>
</blockquote>
<p>举例说明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">// 通用的模板</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void printValue(T value) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Generic Template: &quot; &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 部分特化：针对指针类型的特化实现</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void printValue(T* value) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Partial Specialization for Pointer: &quot; &lt;&lt; *value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 完全特化：针对int类型的特化实现</span><br><span class="line">template &lt;&gt;</span><br><span class="line">void printValue&lt;int&gt;(int value) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Full Specialization for int: &quot; &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">//这里所有的T都换成类型int</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int a = 10;</span><br><span class="line">    double b = 3.14;</span><br><span class="line">    int* ptr = &amp;a;</span><br><span class="line"></span><br><span class="line">    printValue(a);    // 使用完全特化的实现</span><br><span class="line">    printValue(b);    // 使用通用模板的实现</span><br><span class="line">    printValue(ptr);  // 使用部分特化的实现</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">在上面的示例中，我们定义了一个通用的模板函数 printValue，它可以打印任意类型的值。然后，我们使用模板特化来提供针对特定类型或参数的定制实现。</span><br><span class="line"></span><br><span class="line">首先，我们通过部分特化来针对指针类型提供特殊的实现，即 printValue(T* value) 函数。这个函数会打印指针所指向的值。</span><br><span class="line"></span><br><span class="line">然后，我们使用完全特化来为 int 类型提供专门的实现，即 printValue&lt;int&gt;(int value) 函数。这个函数会打印 int 类型的值。</span><br><span class="line"></span><br><span class="line">在 main 函数中，我们分别调用了 printValue 函数来打印不同类型的值。对于 int 类型的值，会使用完全特化的实现；对于其他类型的值，会使用通用模板的实现；对于指针类型的值，会使用部分特化的实现。</span><br></pre></td></tr></table></figure>


<h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><p>友元的理解</p>
<blockquote>
<p>虽然封装机制所带来的好处是极其明显的,但是如果绝对不允许类外的函数访问类中的私有成员,确实也有许多不便之处。<br>为此,C++提供了友元这种机制,允许类外部的函数或者类具有该类私有成员的特权。通过关键字friend可以把其他类或类的非成员函数声明为一个类的友元。作为一个类的友元的类外函数,可以像本类的成员函数一样自由地访问类中的任何成员。</p>
</blockquote>
<p>友元函数的理解</p>
<blockquote>
<p>友元函数实际上就是一个一般的函数,与其他普通函数的不同之处在于:友元函数需在某个类中声明,它拥有访问声明它的类中所有成员的特权。而其他普通函数则只能访问类中的公有成员。<br>虽然友元是在类中声明的,但其作用域却在类外。使用友元的主要目的是提高程序的运行效率。</p>
</blockquote>
<p>友元函数的声明和定义</p>
<blockquote>
<p>一个类的友元函数是在该类中用关键字friend修饰声明的函数。友元函数是在该类以外其他地方定义的。友元函数有权访问类中所有的成员。<br>声明一个友元的一般形式如下:<br>friend &lt;类型&gt;&lt;函数名&gt;(&lt;参数表&gt;);</p>
</blockquote>
<p>举例</p>
<blockquote>
<p>代码<br><img src="/blog/fujian/89ed79d37484f9a9e46a8fa99b920bba.png"></p>
<p>说明<br>在本例子中,友元函数FriFunc()带有一个参数—对类Person 的引用,在函数的定义中可利用该参数来访问对象person中的私有成员。<br>注意,这是友元函数访问类成员的唯一方法,因为友元虽在类中说明,但它并不是类的成员函数,因此不带this 指针。</p>
</blockquote>
<p>在模板类里定义友元函数举例</p>
<blockquote>
<p><img src="/blog/fujian/5e19585031081a8c02931ea6ad04ff10.png"></p>
</blockquote>
<p>注意</p>
<blockquote>
<ol>
<li>除了可以像上例那样将一个全局函数声明为某类的友元之外,也可以将一个类的成员函数声明为另一个类的友元,例如:<br><img src="/blog/fujian/fefbd0426d6a795db31508e7e2007dbd.png"><br>由此可见,一个类的友元可以是类外的任何函数,包括不属于任何类的普通函数和属于某个类的成员函数。</li>
<li>友元声明可以出现在类的私有部分﹑保护部分和公有部分。在某类中说明友元只是说明该类允许这个函数随意访问它的所有成员,但友元函数并不是它的成员函数,指定对该函数的访问权限是没有意义的。</li>
</ol>
</blockquote>
<h2 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h2><p>友元类的理解</p>
<blockquote>
<p>当一个类成为另一个类的友元时,就构成了友元类。这意味着该类的每一个成员函数都是另一个类的友元函数。</p>
</blockquote>
<p>友元类的声明</p>
<blockquote>
<p>定义友元类的语句格式如下：  friend class 类名;<br>例如，以下语句说明类B是类A的友元类：<br><img src="/blog/fujian/f3826fed53f4bbf15558072ae6c6577b.png"><br>经过以上说明后，类B的所有成员函数都是类A的友元函数。<br>注意类B，需要在类A外面进行定义。或者类B已经是程序中的一个已定义过的类，。</p>
</blockquote>
<p>举例</p>
<blockquote>
<p>代码<br><img src="/blog/fujian/f7917af744097b1bd0651f1b9de79a2f.png"><br><img src="/blog/fujian/9ad2a5053de4a23a4257f9367eada008.png"></p>
<p>输出结果<br>5</p>
</blockquote>
<p>注意</p>
<blockquote>
<p>使用友元虽然可以提高程序的运行效率,但却破坏了类的封装性。友元就如同在封装类中成员的容器上打了一些洞,一个类拥有的友元越多,这种洞就越多,类的封装性就越差。因此,为了保证数据的完整性及数据的封装性与隐藏性,在实际应用中应尽量少用或不用友元。另外,友元是不可继承的,即一个类的友元并不是其派生类的友元。</p>
</blockquote>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>内部类的理解</p>
<blockquote>
<p>如果一个A类定义在另一个B类的内部，这个A类就叫做内部类,B类就叫外部类。注意此时这个内部类是一个独立的类，它不属于外部类，更不能通过外部类的对象去调用内部类。外部类对内部类没有任何优越的访问权限。<br><strong>内部类可以理解为，就是外部类的友元类</strong>。注意友元类的定义，内部类可以通过外部类的对象参数来访问外部类中的所有成员。但是外部类不是内部类的友元。<br>只是内部类比友元类多了一点权限：可以不加类名的访问外部类中的static、枚举成员。其他的都和友元类一样。</p>
</blockquote>
<p>注意</p>
<blockquote>
<p>内部类可以定义在外部类的public、protected、private都是可以的。</p>
<p>如果内部类定义在public，则可通过 外部类名::内部类名，来定义内部类的对象。</p>
<p>如果定义在private，则外部不可定义内部类的对象，这可实现“实现一个不能被继承的类”问题。</p>
<p>内部类可以直接访问外部类中的static、枚举成员，不需要外部类的对象&#x2F;类名。但不能直接访问外部类的成员函数。<br>因为内部类是一个独立的类，不属于外部类，所以此时还没有外部类的对象，显然也不存在成员变量。而静态成员变量就不同了，不需要外部类的对象就已存在。</p>
</blockquote>
<p>举例</p>
<blockquote>
<p>类的定义<br><img src="/blog/fujian/25a808000f72b8ce116718e79582fbb9.png"></p>
<p>主函数<br><img src="/blog/fujian/ca2888e37e15db0d37640ca61db2d9b7.png"></p>
<p>输出结果<br>b:5<br>statci value:3</p>
</blockquote>
<h2 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h2><p>异常的理解</p>
<blockquote>
<p>例如,当程序执行时遇到下面几种异常情况:出现除数为0的除法运算;<br>系统内存空间不够,无法完成指定的操作;<br>硬盘上文件被移动而无法打开;<br>数组下标越界(注意,C++编译器是不理会数组下标越界的)等,这些都有可能会造成正在执行的程序提前终止。</p>
</blockquote>
<p>异常处理机制的理解</p>
<blockquote>
<p>异常处理机制则将异常的检测与处理进行分离，即程序代码只负责检测异常是否发生，而具体的异常处理操作则是在其他地方交给特定的异常处理程序来完成。这样做可以使程序结构更加清晰，错误处理也更加灵活和高效。</p>
</blockquote>
<p>异常处理的实现方式</p>
<blockquote>
<p>C+＋的异常处理由3个保留字实现: throw ,try 和 catch。<br>需要检测异常的程序段(包括函数调用)必须放在try语句块中执行,try检测函数调用是否引发了异常，检测到异常条件并使用throw引发一个异常;<br>异常由紧跟着try语句块后面的catch语句捕获并处理。</p>
<p>因而try与catch总是结合使用的,其形式如下:<br><img src="/blog/fujian/3fefbb9c0658a717748d1930dfb4b9d5.png"><br>在上述结构中,一个try语句可与多个catch语句相联系。如果某个catch 语句的参数类型与引发异常的信息数据类型相匹配,则执行该catch 语句的异常处理(捕获异常),此时由throw语句抛出的异常信息(值)传送给catch语句中的参数。<br>在多个catch 语句的最后可以使用catch(…)捕获所有其他类型的异常,其中的省略号表亓可与任何数据类型相匹配。<br>引发异常的 throw 语句必须包含在try语句块内,或者由 try语句块中直接或间接调用的丞数执行。<br>throw语句的一般形式如下:<br><code>throw exception ;</code><br>这里的exception表示一个异常值,它可以是任意类型的变量、对象或值。</p>
<p>注意;catch语句的类型匹配过程中不做任何类型转换,例如unsigned int类型的异常值不能被int类型的catch参数捕获。</p>
</blockquote>
<p>异常处理的运行过程</p>
<blockquote>
<p>在函数调用过程中，一个函数可以调用另一个函数来执行某个任务。被调用的函数称为被调用函数，调用该函数的函数称为调用函数。假设有函数A调用函数B，而函数B又调用函数C，那么在这个调用链中，函数C是A的下一级函数，B是C的上一级函数，而A是B的上一级函数。<br>当一个函数在执行过程中出现异常时，首先会在当前的函数进行处理，如果当前函数无法处理，就将这个异常将传递给它的上一级函数来处理，上一级函数就是调用它的函数。如果上一级函数也不能处理该异常，则继续向上一级传递，直到最高一级函数或者C++运行系统处理为止。</p>
<p>假设有一个程序由三个函数组成，分别是 main()、foo() 和 bar()。main() 调用 foo()，foo() 调用 bar()。如果 bar() 在执行过程中出现异常，那么看该异常在bar能否处理，<br>如果 bar()不能，就把该异常将传递给 foo()，如果 foo() 能够处理该异常，那么它就会在 foo() 中被处理掉。<br>如果 foo() 不能处理该异常，那么该异常将继续向上一级函数 main() 传递，如果 main() 能够处理该异常，那么它就会在 main() 中被处理掉。如果 main() 也不能处理该异常，那么该异常将被传递给 C++ 运行系统处理。</p>
</blockquote>
<p>用try与catch处理异常与用if处理异常的区别</p>
<blockquote>
<p>用try与catch处理异常，异常的检测与处理进行分离，就是在try里去检测异常， 然后在某个地方集中用catch里处理异常。<br>跟使用if检测的区别在于，如果使用if检测异常，那么就得直接在if下面去处理异常，这样久需要在每个可能引发异常的代码块中进行异常处理，这样会导致代码冗长和可读性降低，使得程序的可读性不高。<br>相比之下，使用try和catch可以将所有的异常处理代码集中在一起，使得代码更加简洁和易于维护。</p>
</blockquote>
<p>使用try与catch来进行异常处理的举例</p>
<blockquote>
<p><img src="/blog/fujian/547b015bd5245801d0834d0afe0e9a1f.png"><br><img src="/blog/fujian/5b847260d16d2babb332fcde2a08df35.png"><br><img src="/blog/fujian/9ae90f87176ddb5ca8ce3010965ea7e4.png"><br>在这里try是进行异常的检查，catch是对异常的处理，也就是异常于检查分离。<br>在try里如果没有问题，则继续执行代码，如果有问题则执行throw语句抛出异常，然后代码就转到catch处，去处理异常</p>
</blockquote>
<p>构造函数不能抛出异常的原因</p>
<blockquote>
<p>在类的构造函数中抛出异常可能导致内存泄漏。<br>致内存泄漏主要原因是，在构造函数中发生异常时，对象的生命周期尚未完成，即对象还没有完全构造成功。此时，对象的析构函数可能不会被调用，它所占用的资源没有被释放，这样就会导致内存泄漏或资源泄漏的问题。</p>
</blockquote>
<p>析构函数不能抛出异常的原因</p>
<blockquote>
<p>析构函数不可以抛出异常，如果析构函数抛出异常，则异常点之后的程序，比如释放内存等操作，就不会被执行，从而造成内存泄露的问题</p>
</blockquote>
<h1 id="B2C1-C-常用类和结构体"><a href="#B2C1-C-常用类和结构体" class="headerlink" title="[[B2C1.C++常用类和结构体]]"></a>[[B2C1.C++常用类和结构体]]</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://xingwumo.github.io/blog">wumo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://xingwumo.github.io/blog/2023/07/01/B2.C++%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/">http://xingwumo.github.io/blog/2023/07/01/B2.C++%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://xingwumo.github.io/blog" target="_blank">wumo学习分享仓库</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/blog/fujian/c18a5aebdee3f6a9262f3536aece0d16.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://fastly.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blog/2023/07/01/B1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="B1.计算机网络基础知识"><img class="cover" src="/blog/fujian/1086f6027eb51154d19ef8a1e3b3aa21.jpg" onerror="onerror=null;src='/blog/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">B1.计算机网络基础知识</div></div></a></div><div class="next-post pull-right"><a href="/blog/2023/07/01/B3.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/" title="B3.基础算法"><img class="cover" src="/blog/fujian/6d7cd2992339f0ba0bbea74deef77b43.jpg" onerror="onerror=null;src='/blog/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">B3.基础算法</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/blog/img/favicon.png" onerror="this.onerror=null;this.src='/blog/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">wumo</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">类和对象的基本知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">类和对象的概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="toc-number">1.2.</span> <span class="toc-text">面向对象基本特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.</span> <span class="toc-text">类的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.4.</span> <span class="toc-text">对象的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">成员函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83"><span class="toc-number">1.6.</span> <span class="toc-text">访问控制权</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%96%E8%81%94%E5%87%BD%E6%95%B0-inline%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.7.</span> <span class="toc-text">内联函数和外联函数(inline关键字)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">1.8.</span> <span class="toc-text">对象的存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%BB%84%E5%90%88"><span class="toc-number">1.9.</span> <span class="toc-text">类的组合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%88%86%E7%A6%BB"><span class="toc-number">1.10.</span> <span class="toc-text">接口与实现分离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="toc-number">1.11.</span> <span class="toc-text">构造函数(对象的初始化方式)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.11.1.</span> <span class="toc-text">构造函数的基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">1.11.2.</span> <span class="toc-text">构造函数的重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E5%BC%8F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.11.3.</span> <span class="toc-text">结构体方式初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.11.4.</span> <span class="toc-text">new初始化对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%86%85%E5%B5%8C%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.11.5.</span> <span class="toc-text">类内嵌对象初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="toc-number">1.11.6.</span> <span class="toc-text">构造函数的初始化方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.12.</span> <span class="toc-text">析构函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.13.</span> <span class="toc-text">String类成员函数*</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E4%B8%8E%E6%8C%87%E9%92%88"><span class="toc-number">2.</span> <span class="toc-text">对象与指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">2.1.</span> <span class="toc-text">指向对象的指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">2.2.</span> <span class="toc-text">指向对象成员的指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E6%8C%87%E9%92%88"><span class="toc-number">2.3.</span> <span class="toc-text">this指针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">3.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E%E7%BB%A7%E6%89%BF%E6%9C%89%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.</span> <span class="toc-text">与继承有关的一些概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">3.2.</span> <span class="toc-text">派生类的声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">3.3.</span> <span class="toc-text">继承的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E4%B8%8D%E5%90%8C%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F%E5%92%8C%E8%AE%BF%E9%97%AE%E5%B1%9E%E6%80%A7"><span class="toc-number">3.4.</span> <span class="toc-text">派生类的不同继承方式和访问属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE%E5%B1%9E%E6%80%A7"><span class="toc-number">3.4.1.</span> <span class="toc-text">类成员的访问属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E6%9C%89%E7%BB%A7%E6%89%BF"><span class="toc-number">3.4.2.</span> <span class="toc-text">公有继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E7%BB%A7%E6%89%BF"><span class="toc-number">3.4.3.</span> <span class="toc-text">私有继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E7%BB%A7%E6%89%BF"><span class="toc-number">3.4.4.</span> <span class="toc-text">保护继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.5.</span> <span class="toc-text">派生类的构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">3.6.</span> <span class="toc-text">派生类的析构函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E5%92%8C%E9%9A%90%E5%BC%8F%E8%AE%BF%E9%97%AE%E5%9F%BA%E7%B1%BB%E6%88%90%E5%91%98"><span class="toc-number">3.7.</span> <span class="toc-text">显式和隐式访问基类成员</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%BA%A7%E7%94%9F%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3"><span class="toc-number">3.8.</span> <span class="toc-text">多继承产生的问题和解决</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">4.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-number">4.1.</span> <span class="toc-text">多态的概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%9B%BF%E6%8D%A2%E5%9F%BA%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.2.</span> <span class="toc-text">派生类对象替换基类对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.</span> <span class="toc-text">虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">4.4.</span> <span class="toc-text">抽象类和纯虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%EF%BC%88%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%EF%BC%89"><span class="toc-number">4.5.</span> <span class="toc-text">static修饰成员（静态成员）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98"><span class="toc-number">4.6.</span> <span class="toc-text">const修饰成员</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">4.7.</span> <span class="toc-text">运算符重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#override%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">4.8.</span> <span class="toc-text">override关键字</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">5.</span> <span class="toc-text">模板</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">5.1.</span> <span class="toc-text">模板的基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">5.2.</span> <span class="toc-text">函数模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-number">5.3.</span> <span class="toc-text">类模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%A8%A1%E6%9D%BF"><span class="toc-number">5.4.</span> <span class="toc-text">结构体模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">5.5.</span> <span class="toc-text">不同模板参数的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%89%B9%E4%BE%8B%E5%8C%96"><span class="toc-number">5.6.</span> <span class="toc-text">模板特例化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-number">5.7.</span> <span class="toc-text">友元函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="toc-number">5.8.</span> <span class="toc-text">友元类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">5.9.</span> <span class="toc-text">内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">5.10.</span> <span class="toc-text">异常处理机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#B2C1-C-%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">6.</span> <span class="toc-text">[[B2C1.C++常用类和结构体]]</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/2024/01/02/%E7%A7%92%E9%80%9F5CM%E6%96%87%E6%A1%88%201/" title="秒速5CM文案 1">秒速5CM文案 1</a><time datetime="2024-01-01T16:00:00.000Z" title="发表于 2024-01-02 00:00:00">2024-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/07/23/B1.C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="B1.C++基础知识"><img src="/blog/fujian/7f6aba31b4c37b3ff37eeec6dea1eb08.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="B1.C++基础知识"/></a><div class="content"><a class="title" href="/blog/2023/07/23/B1.C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="B1.C++基础知识">B1.C++基础知识</a><time datetime="2023-07-22T16:00:00.000Z" title="发表于 2023-07-23 00:00:00">2023-07-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/07/02/GamePlay%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6%E6%9E%84%E6%88%90/" title="GamePlay基础框架构成"><img src="/blog/fujian/c9e4acd4daeeff67236a5f9bfa0e57e6.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="GamePlay基础框架构成"/></a><div class="content"><a class="title" href="/blog/2023/07/02/GamePlay%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6%E6%9E%84%E6%88%90/" title="GamePlay基础框架构成">GamePlay基础框架构成</a><time datetime="2023-07-01T16:00:00.000Z" title="发表于 2023-07-02 00:00:00">2023-07-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/07/01/B1.Markdown%E7%9A%84%E5%B8%B8%E7%94%A8%E8%AF%AD%E8%A8%80%E8%A7%84%E5%88%99/" title="B1.Markdown的常用语言规则"><img src="/blog/fujian/86f423ffed4a9a1c33ff8db747ba24b2.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="B1.Markdown的常用语言规则"/></a><div class="content"><a class="title" href="/blog/2023/07/01/B1.Markdown%E7%9A%84%E5%B8%B8%E7%94%A8%E8%AF%AD%E8%A8%80%E8%A7%84%E5%88%99/" title="B1.Markdown的常用语言规则">B1.Markdown的常用语言规则</a><time datetime="2023-06-30T16:00:00.000Z" title="发表于 2023-07-01 00:00:00">2023-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/07/01/B1.Git%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="B1.Git基础知识"><img src="/blog/fujian/b9a047b5abbc54c9f035ccdaab4e02e0.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="B1.Git基础知识"/></a><div class="content"><a class="title" href="/blog/2023/07/01/B1.Git%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="B1.Git基础知识">B1.Git基础知识</a><time datetime="2023-06-30T16:00:00.000Z" title="发表于 2023-07-01 00:00:00">2023-07-01</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/blog/fujian/c18a5aebdee3f6a9262f3536aece0d16.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By wumo</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/blog/js/utils.js"></script><script src="/blog/js/main.js"></script><script src="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>