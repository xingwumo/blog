<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>B1.计算机网络基础知识 | wumo学习分享仓库</title><meta name="author" content="wumo"><meta name="copyright" content="wumo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="计算机网络体系结构五层协议体系结构五次协议的理解  五层协议是综合OSI和 TCP&#x2F;IP的优点，所形成的，主要是为了方便学习计算机网络的原理。  物理层的理解  发送端的物理层负责接收从数据链路层传下来的数据帧，然后将数据帧的比特流以0和1的电信号在物理媒介上进行传输。接收端的物理层从物理媒介接收传输的电信号之后，将其解码为比特流，然后上传给数据链路层进行后续处理。例如，网线将数据转换">
<meta property="og:type" content="article">
<meta property="og:title" content="B1.计算机网络基础知识">
<meta property="og:url" content="http://xingwumo.github.io/blog/2023/07/01/B1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/index.html">
<meta property="og:site_name" content="wumo学习分享仓库">
<meta property="og:description" content="计算机网络体系结构五层协议体系结构五次协议的理解  五层协议是综合OSI和 TCP&#x2F;IP的优点，所形成的，主要是为了方便学习计算机网络的原理。  物理层的理解  发送端的物理层负责接收从数据链路层传下来的数据帧，然后将数据帧的比特流以0和1的电信号在物理媒介上进行传输。接收端的物理层从物理媒介接收传输的电信号之后，将其解码为比特流，然后上传给数据链路层进行后续处理。例如，网线将数据转换">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://xingwumo.github.io/blog/fujian/1086f6027eb51154d19ef8a1e3b3aa21.jpg">
<meta property="article:published_time" content="2023-06-30T16:00:00.000Z">
<meta property="article:modified_time" content="2023-06-30T18:09:47.981Z">
<meta property="article:author" content="wumo">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://xingwumo.github.io/blog/fujian/1086f6027eb51154d19ef8a1e3b3aa21.jpg"><link rel="shortcut icon" href="/blog/img/favicon.png"><link rel="canonical" href="http://xingwumo.github.io/blog/2023/07/01/B1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/blog/css/index.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/blog/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://fastly.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://fastly.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'B1.计算机网络基础知识',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-01 02:09:47'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/blog/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/blog/fujian/1086f6027eb51154d19ef8a1e3b3aa21.jpg')"><nav id="nav"><span id="blog-info"><a href="/blog/" title="wumo学习分享仓库"><span class="site-name">wumo学习分享仓库</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">B1.计算机网络基础知识</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-30T16:00:00.000Z" title="发表于 2023-07-01 00:00:00">2023-07-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-30T18:09:47.981Z" title="更新于 2023-07-01 02:09:47">2023-07-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="B1.计算机网络基础知识"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><img src="/blog/fujian/1086f6027eb51154d19ef8a1e3b3aa21.jpg"></p>
<h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><h2 id="五层协议体系结构"><a href="#五层协议体系结构" class="headerlink" title="五层协议体系结构"></a>五层协议体系结构</h2><p>五次协议的理解</p>
<blockquote>
<p><img src="/blog/fujian/6eee2af6ad2fea323c09046f8152731c.png"><br>五层协议是综合OSI和 TCP&#x2F;IP的优点，所形成的，主要是为了方便学习计算机网络的原理。</p>
</blockquote>
<p>物理层的理解</p>
<blockquote>
<p>发送端的物理层负责接收从数据链路层传下来的数据帧，然后将数据帧的比特流以0和1的电信号在物理媒介上进行传输。<br>接收端的物理层从物理媒介接收传输的电信号之后，将其解码为比特流，然后上传给数据链路层进行后续处理。例如，网线将数据转换为电信号以在计算机之间进行传输。</p>
<p>而物理层的主要任务就是决定如何在物理媒介（如电缆、光纤）上传输比特流，也就是决定如何将这些比特流转换为电信号或光信号，包括传输介质的选择、电信号的编码和调制方式、物理层会考虑用多大的电压代表“1”或“0”，以及接收方如何识别出发送方所发送的电信号等。</p>
<p>总的来说，物理层的任务就是决定如何在物理媒介上去传输数据。</p>
<p>物理层传输的数据被称作比特流（Bits）。</p>
</blockquote>
<p>数据链路层的理解</p>
<blockquote>
<p>发送端数据链路层主要负责将网络层交下来的数据报封装成帧，然后传给物理层。<br>接收端数据链路层在接收物理层传上来的比特流后，根据帧的首部和尾部的标记，识别帧的边界，并将帧从连续的比特流中分离出来。然后上传给网络层，进行后续处理。</p>
<p>封装成帧(framing)就是将数据报的前后分别添加首部和尾部，这样就构成了一个帧。之后接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的边界，并将帧从连续的比特流中分离出来。<br>在物理媒介传输数据时，它是连续的传递数据，也就是说，接收端收到的数据是连续的比特流，如果没有明确的标记来表示数据的边界，接收端无法直接从收到的连续比特流中识别出数据的开始和结束，从而提取出数据出来，封装成帧的过程就是为了解决这个问题。<br>因此数据链路层的主要任务，就是决定要传输的数据的基本格式，也就是决定网络层的数据报在传输时需要封装的格式，同时还包括帧同步和错误检测等功能。帧同步指的是在传输过程中确保接收端保持与发送端的同步。错误检测则是通过添加校验位或冗余信息，使接收端能够检测出传输过程中的比特错误，从而提高数据的可靠性。</p>
<p>总的来说，数据链路层决定了要传输的数据的基本格式，也就是封装成帧的方式，并提供帧同步和错误检测等功能，以确保数据在传输时的可靠性和准确性。</p>
<p>在数据链路层传输的数据称作帧。帧的本质也是由比特流组成的。不过与物理层的比特流不同的是，帧的比特流添加了结构、标识和控制信息。而物理层的比特流没有明确的结构和含义。</p>
</blockquote>
<p>网络层的理解</p>
<blockquote>
<p>发送端的网络层将运输层产生的报文段或用户数据报进行封装，形成数据报。该数据报包括网络层的首部和传输层的数据，然后传递给数据链路层。<br>接收端的网络层在收到链路层传上来的帧之后，首先会去除数据链路层添加的首部和尾部，提取出原始的数据报。然后，根据数据报中的目的地址进行路由选择和转发.<br>最终接收端的网络层会将数据报传递给上层的运输层，以便进行进一步的处理。</p>
<p>数据报的首部主要记录了，网络通信相关的控制信息和地址信息。<br>地址信息包含了源地址和目的地址，用于标识数据报的发送方和接收方。在传输过程中，发送端会将数据报先传送给给附近的路由，路由的网络层在提取出原始的数据报之后，根据数据报里首部记录的源地址和目的地址，选择下一个要传输的路由，在这过程中，数据报会经过多个路由器进行转发，每个路由器根据数据报中的目的地址进行路由选择，最终将数据报传递给目标地址所在的网络。<br>当数据报到达目标网络后，根据目的地址找到目标主机，网络层将数据报传递给目标主机的网络层进行进一步处理。目标主机的网络层会检查数据报的目的地址，如果与主机的地址匹配，就将数据报传递给上层的运输层，完成数据的传输。<br>控制信息，例如生存时间（Time to Live，TTL）字段，用于限制数据报在网络中的生存时间，防止数据报在网络中无限循环。还有服务质量（Quality of Service，QoS）字段，用于指定数据报的优先级和传输要求，确保网络能够按照特定的要求处理数据报。<br>因此网络层的主要任务，首先就是为每个网络设备分配唯一的标识，即IP地址。通过IP地址，源主机可以将数据报发送到目标主机，而目标主机也可以根据IP地址将数据报传递给相应的应用程序或上层协议。另一个主要任务是定义路由的功能，路由根据数据报中的目的地址，选择最佳的路径将数据报转发到下一个路由器或目标主机。路由器根据网络层的路由表和路由算法来进行路由选择</p>
<p>总的来说网络层的功能，就是分配IP地址和定义路由功能，实现了网络设备之间的通信和数据传输。</p>
<p>网络层传送的数据称作数据报。（在 TCP&#x2F;IP体系中，由于网络层使用IP协议，因此分组也叫做IP数据报，或简称为数据报。)</p>
</blockquote>
<p>运输层的理解</p>
<blockquote>
<p>发送端在接收应用层传下来的应用层报文之后，运输层会根据传输协议的要求对应用层报文进行封装，添加相应的首部和校验和，然后传输给网络层。<br>如果使用的是TCP协议，运输层会将应用层报文分割成更小的TCP报文段，并为每个报文段添加TCP首部，包括源端口号和目的端口号等信息。运输层还会计算校验和来确保数据的完整性，并将TCP报文段传递给网络层。<br>如果使用的是UDP协议，运输层会直接封装应用层报文为UDP报文，其中包含源端口号和目的端口号等信息，然后传递给网络层</p>
<p>接收端的运输层在接收网络层的数据报之后，首先会根据数据报的首部的协议标识字段，来确定使用的是哪个传输层协议，例如TCP或UDP。然后，运输层会根据该协议对数据报进行解封，并根据该传输协议对解封后的数进行进一步的处理，处理后传递给应用层。</p>
<p>如果使用的是TCP协议，运输层会根据TCP首部的信息进行进一步处理，包括对TCP报文段进行排序和重组，确保数据按正确的顺序传递给上层应用程序，同时，运输层还会处理流量控制和拥塞控制等机制，以确保网络的可靠性和高效性。<br>如果数据报使用UDP协议，运输层会将数据报直接传递给相应的UDP端口，供上层应用程序使用。</p>
<p>TCP协议提供可靠的、面向连接的通信；UDP协议提供无连接的通信，简单地将数据传递给上层应用程序。</p>
<p>注意，运输层本身并不决定数据该用什么协议去传输，而是根据应用层传递给它的信息来确定使用的是哪个传输层协议。</p>
<p>因此运输层的任务，建立端口到端口的通信，然后是实现TCP协议传输数据或者UDP协议传输数据的功能，确保数据的可靠传输（对于TCP）或无连接传输（对于UDP）。</p>
<p>如果是TCP协议，则运输层传输的数据单位是TCP报文段。如果是UDP协议，则运输层传输的协议叫UDP数据报</p>
</blockquote>
<p>应用层的理解</p>
<blockquote>
<p>发送端的应用层进程会根据应用层协议，将要传输的数据形成对应的应用层报文，并将其传递给运输层。<br>接收端的应用层的进程在收到运输层传来的数据后，会根据应用层协议去解析和处理接收到的数据。</p>
<p>应用层协议定义了数据的格式、交互方式和语义，发送端的应用层的进程会按照协议规定的方式去将要发送的数据，组织形成规定好的数据格式然后再将数据交给运输层。而接收端的应用层的进程也会根据协议规定的方式解析和处理接收到的数据。<br>举例来说，HTTP协议规定了Web应用中客户端和服务器之间的通信规则，定义了请求和响应报文的格式、方法、状态码等。SMTP协议定义了电子邮件的传输规则，规定了邮件报文的结构和传输流程。</p>
<p>因此应用层的主要任务，就是制定各种应用层的协议，而应用层的协议是应用进程间通信和交互的规则，包括数据格式、处理方式和交互流程，确保了应用程序之间数据的正确传输与处理。</p>
<p>应用层传输的数据叫应用层数据报。 </p>
</blockquote>
<p>数据在各层传递的过程</p>
<blockquote>
<p><img src="/blog/fujian/7441d109a58a3be2c72a96164a430dba.png"><br><img src="/blog/fujian/61e2ab3058cabb840cc02b1e52af34e2.png"><br><img src="/blog/fujian/d73d9a5538223c978fe628433b93be11.png"></p>
</blockquote>
<h2 id="OSI七层协议结构"><a href="#OSI七层协议结构" class="headerlink" title="OSI七层协议结构"></a>OSI七层协议结构</h2><p>OSI七层协议的理解</p>
<blockquote>
<p><img src="/blog/fujian/8f8db7a9275e2e651ecbfb32b2d54be6.png"><br>OSI的七层协议体系结构是一个标准，概念清楚，理论也较完整,但它非常复杂，因此实际应用不采用这个结构。</p>
</blockquote>
<h2 id="TCP-x2F-IP体系结构"><a href="#TCP-x2F-IP体系结构" class="headerlink" title="TCP&#x2F;IP体系结构"></a>TCP&#x2F;IP体系结构</h2><p>TCP&#x2F;IP体系结构的理解</p>
<blockquote>
<p><img src="/blog/fujian/cd118fa122359ec5cfabb34489c504db.png"><br>TCP&#x2F;IP体系结构，是简化版的OSI七层协议结构，实际的应用就采用这个模型。不过从实质上讲，TCP&#x2F;IP只有最上面的三层,因为最下面的网络接口层并没有什么具体内容。</p>
</blockquote>
<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="网络层的基础知识"><a href="#网络层的基础知识" class="headerlink" title="网络层的基础知识"></a>网络层的基础知识</h2><p>网络层的理解</p>
<blockquote>
<p>发送端的网络层将运输层产生的报文段或用户数据报进行封装，形成数据报。该数据报包括网络层的首部和传输层的数据，然后传递给数据链路层。<br>接收端的网络层在收到链路层传上来的帧之后，首先会去除数据链路层添加的首部和尾部，提取出原始的数据报。然后，根据数据报中的目的地址进行路由选择和转发.<br>最终接收端的网络层会将数据报传递给上层的运输层，以便进行进一步的处理。</p>
<p>数据报的首部主要记录了，网络通信相关的控制信息和地址信息。<br>地址信息包含了源地址和目的地址，用于标识数据报的发送方和接收方。在传输过程中，发送端会将数据报先传送给给附近的路由，路由的网络层在提取出原始的数据报之后，根据数据报里首部记录的源地址和目的地址，选择下一个要传输的路由，在这过程中，数据报会经过多个路由器进行转发，每个路由器根据数据报中的目的地址进行路由选择，最终将数据报传递给目标地址所在的网络。<br>当数据报到达目标网络后，根据目的地址找到目标主机，网络层将数据报传递给目标主机的网络层进行进一步处理。目标主机的网络层会检查数据报的目的地址，如果与主机的地址匹配，就将数据报传递给上层的运输层，完成数据的传输。<br>控制信息，例如生存时间（Time to Live，TTL）字段，用于限制数据报在网络中的生存时间，防止数据报在网络中无限循环。还有服务质量（Quality of Service，QoS）字段，用于指定数据报的优先级和传输要求，确保网络能够按照特定的要求处理数据报。<br>因此网络层的主要任务，首先就是为每个网络设备分配唯一的标识，即IP地址。通过IP地址，源主机可以将数据报发送到目标主机，而目标主机也可以根据IP地址将数据报传递给相应的应用程序或上层协议。另一个主要任务是定义路由的功能，路由根据数据报中的目的地址，选择最佳的路径将数据报转发到下一个路由器或目标主机。路由器根据网络层的路由表和路由算法来进行路由选择</p>
<p>总的来说网络层的功能，就是分配IP地址和定义路由功能，实现了网络设备之间的通信和数据传输。</p>
<p>网络层传送的数据称作数据报。（在 TCP&#x2F;IP体系中，由于网络层使用IP协议，因此分组也叫做IP数据报，或简称为数据报。)</p>
</blockquote>
<p>网络层的中间设备</p>
<blockquote>
<p>路由器</p>
</blockquote>
<h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><h3 id="IP协议的概述"><a href="#IP协议的概述" class="headerlink" title="IP协议的概述"></a>IP协议的概述</h3><p>IP地址的理解</p>
<blockquote>
<p>他是网络层所使用的地址。互联网上的每一台主机(或路由器）的每一个接口都会分配一个IP地址。<br>IP地址由32位或128位二进制数组成，表示为点分十进制格式（例如：192.168.0.1）<br>源IP地址和目的IP地址放在IP数据报的首部</p>
</blockquote>
<p>物理地址</p>
<blockquote>
<p>他是数据链路层和物理层所使用的地址。<br>物理地址由48位二进制数组成，通常以十六进制表示，格式为6对冒号分隔的十六进制数（例如：00:1A:2B:3C:4D:5E）。</p>
<p>源MAC地址和目的MAC地址都写在帧的首部中。</p>
</blockquote>
<p>IP协议的理解</p>
<blockquote>
<p>IP协议定义了一种地址格式，即IP地址，每台连接到互联网的设备都有一个唯一的IP地址。<br>同时IP协议，还定义了网络层的数据的传输方式，即怎么根据对方的IP地址，将数据传输给对方的网络层，以及怎么将接收到的数据传输给运输层。</p>
</blockquote>
<p>IP协议的配套协议</p>
<blockquote>
<p><img src="/blog/fujian/cc0809927e2b28fb6642953f08caac30.png"><br>地址解析协议ARP(Address Resolution Protocol)<br>网际控制报文协议ICMP (Internet Control Message Protocol)网际<br>组管理协议IGMP (Internet Group Management Protocol)<br>图画出了这三个协议和网际协议IP的关系。在这一层中，ARP画在最下面，因为P经常要使用这个协议。ICMP和 IGMP画在这一层的上部，因为它们要使用IP协议。</p>
</blockquote>
<p>IP数据报在传递过程中，IP地址和mac地址的变化</p>
<blockquote>
<p>举例传输图<br><img src="/blog/fujian/79bf1ae362e1bd8072f30d86e6b586f0.png"><br>图画的是三个局域网用两个路由器R1和R2互连起来。现在主机H1要和主机H2通信。这两台主机的IP地址分别是IP1,和IP2，而它们的硬件地址分别为HA1和 HA2(HA表示Hardware Address)。通信的路径是:H1→经过R1转发→再经过R2转发→H2。<br>路由器R1,因同时连接到两个局域网上，因此它有两个硬件地址，即 HA3,和 HA4。同理，路由器R2也有两个硬件地址HA5和 HA6。</p>
<p>传输过程的IP地址和物理地址图<br><img src="/blog/fujian/c1a20da88e75493e44ae971a281f3b36.png"><br>开始在H1到R1间传送时，MAC帧首部中写的是从硬件地址HA1发送到硬件地址HA3，路由器R1,收到此MAC帧后，在数据链路层，要丢弃原来的MAC帧的首部和尾部。.<br>在转发时，在数据链路层，要重新添加上MAC 帧的首部和尾部。这时首部中的源地址和目的地址分别便成为HA4和 HA5。路由器R2收到此帧后，再次更换 MAC帧的首部和尾部，首部中的源地址和目的地址分别变成为HA6和 HA2。</p>
</blockquote>
<h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p>ARP协议的理解</p>
<blockquote>
<p>ARP协议的作用，就是在已知一个机器的IP地址后，找到其对应的MAC地址。<br>在IP数据报的传输过程中，当需要将数据发送到目标机器时，需要知道目标机器的MAC地址才能正确地进行数据传输。这时IP协议就会使用ARP协议来找到其MAC地址。</p>
<p>如果目标机器在同一个局域网内，ARP协议可以直接通过目标机器的IP地址找到其MAC地址。<br>如果目标机器不在同一个局域网内，ARP协议就无法直接找到目标机器的MAC地址。在这种情况下，ARP会查找附近的路由器的MAC地址。发送设备会将数据发送到该路由器的MAC地址，然后让路由器根据目标机器的IP地址完成剩下的工作。</p>
</blockquote>
<p>ARP协议的实现原理</p>
<blockquote>
<p>每一台主机都设有一个 ARP 高速缓存(ARP cache)，里面有本局域网上的各主机和路由器的IP地址到硬件地址的映射表，这些都是该主机目前知道的一些地址。</p>
<p>当主机A要向本局域网上的某台主机B发送IP数据报时，就先在其 ARP高速缓存中查看有无主机B的P地址。如有，就在ARP 高速缓存中查出其对应的硬件地址，再把这个硬件地址写入 MAC帧，然后通过局域网把该MAC帧发往此硬件地址。</p>
<p>也有可能查不到主机B的IP地址的项目。这可能是主机B才入网，也可能是主机A刚刚加电，其高速缓存还是空的。在这种情况下，主机A就自动运行ARP,然后按以下步骤找出主机B的硬件地址。</p>
<p><img src="/blog/fujian/65647756ddf52b10b7a7d6df53b4a3ab.png"><br>1.ARP进程在本局域网上广播发送一个 ARP请求分组，上面是示意图。ARP 请求分组的主要内容是:“我的IP地址是209.0.0.5，硬件地址是00-00-C0-15-AD-18。我想知道P地址为209.0.0.6的主机的硬件地址。”<br>2.在本局域网上的所有主机上运行的ARP进程都收到此ARP 请求分组。主机B的IP地址与ARP请求分组中要查询的P地址一致，就收下这个ARP请求分组。</p>
<p><img src="/blog/fujian/2f777849bb1d041615b5b53dcd35b3c6.png"><br>3.之后主机B并向主机A发送 ARP响应分组。同时在这个ARP响应分组中写入自己的硬件地址。由于其余的所有主机的IP地址都与ARP请求分组中要查询的IP地址不一致，因此都不理睬这个ARP请求分组。<br>ARP响应分组的主要内容是:“我的IP地址是209.0.0.6，我的硬件地址是08-00-2B-00-EE-0A。”<br>请注意:虽然ARP请求分组是广播发送的，但ARP响应分组是普通的单播，即从一个源地址发送到一个目的地址。<br>主机A收到主机B的ARP响应分组后，就在其ARP高速缓存中写入主机B的IP地址到硬件地址的映射。<br>当主机A向B发送数据报时，很可能以后不久主机B还要向A发送数据报，因而主机B也可能要向A发送ARP请求分组。为了减少网络上的通信量，主机A在发送其ARP 请求分组时，就把自己的IP地址到硬件地址的映射写入 ARP请求分组。当主机B收到A的ARP请求分组时，就把主机A的这一地址映射写入主机B自己的 ARP高速缓存中。以后主机B向A发送数据报时就很方便了。</p>
</blockquote>
<p>使用ARP的四种情况</p>
<blockquote>
<p><img src="/blog/fujian/94cd88b20a664ad47d10d16f3ed2f4cc.png"><br><img src="/blog/fujian/d91cfbfed0c3e737e04ce8768509bda4.png"></p>
</blockquote>
<p>IP层转发分组的流程</p>
<blockquote>
<p><img src="/blog/fujian/a37b7bfb52050b6e50f67da4fab26486.png"><br><img src="/blog/fujian/46c297cccf05df090773327fb9a13974.png"></p>
</blockquote>
<h3 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h3><p>ICMP协议的理解</p>
<blockquote>
<p>ICMP是一种用于在IP网络中进行错误报告和诊断的协议。它允许主机或路由器发送控制消息给其他主机或路由器，以测试网络状况、错误情况或执行特定的网络功能。</p>
<p>举个例子，假设你想测试与某个远程主机的连接是否正常。你可以在命令行中输入ping命令，后跟目标主机的IP地址或域名。操作系统会生成ICMP Echo Request消息，并将其发送到目标主机。如果目标主机正常工作并且连接畅通，它将接收到ICMP Echo Request消息，并回复一个ICMP Echo Reply消息作为响应。你的计算机会计算回复消息的往返时间（RTT）和丢包率等信息，并将结果显示给你。</p>
<p>通过使用ICMP协议进行ping测试，你可以了解到目标主机的可达性和网络延迟情况。</p>
</blockquote>
<p>ICMP的应用</p>
<blockquote>
<p>一个是ping,一个是Traceroute(路由跟踪)</p>
</blockquote>
<p>ping命令的理解</p>
<blockquote>
<p>当你使用ping命令测试网络连接时，实际上就是在使用ICMP协议。Ping是一种常用的网络诊断工具，它通过发送ICMP回显请求消息（Echo Request）到目标主机，并等待目标主机发送回相应的回显应答消息（Echo Reply）来测试网络的连通性和延迟。</p>
</blockquote>
<p>Traceroute（路由跟踪）的理解</p>
<blockquote>
<p>是一种网络诊断工具，用于确定数据包从源主机到目标主机的路径和经过的网络节点。<br>它通过发送一系列的数据包（通常是使用ICMP协议）并观察返回的数据包的传输时间，来确定数据包经过的路由路径和网络延迟。</p>
</blockquote>
<h3 id="IGMP协议"><a href="#IGMP协议" class="headerlink" title="IGMP协议"></a>IGMP协议</h3><p>多播通信的理解</p>
<blockquote>
<p>多播通信是一种网络通信方式，它允许一个主机将数据同时发送给多个接收者，而不是只发送给一个特定的目标主机。在多播通信中，发送者只需发送一份数据，而网络将负责将数据传输到所有参与的接收者。<br>在多播通信中，参与通信的主机必须属于同一个多播组。</p>
</blockquote>
<p>IGMP协议的理解</p>
<blockquote>
<p><strong>IGMP是在多播通信中管理组成员的协议。<br>IGMP允许主机加入或离开特定的多播组，并通知网络中的路由器。这样，路由器可以根据组成员的信息来有效地转发多播数据包，而不将其发送给不相关的主机。</strong></p>
<p>举例<br>当一个主机希望接收某个多播组的数据时，它会发送一个IGMP报文给相应的多播组地址，表明它要加入该多播组。路由器在收到这个报文后，就知道该主机对该组播组感兴趣，并将相关信息记录在路由表中，确保将多播数据转发给对应的主机。<br>当主机不再对某个多播组感兴趣时，它会发送一个IGMP报文离开该多播组，路由器也会相应地更新路由表</p>
</blockquote>
<h3 id="IPV4和IPV6"><a href="#IPV4和IPV6" class="headerlink" title="IPV4和IPV6"></a>IPV4和IPV6</h3><p>IPV4和IPV6的区别</p>
<blockquote>
<p>IPv4和IPv6是IP协议中的两个版本</p>
<p><strong>IPV4的特点<br>IPv4使用32位地址<br>IPv4使用点分十进制表示法</strong>,例如 192.168.0.1。</p>
<p><strong>ipv6特点<br>IPv6使用128位地址<br>IPv6使用冒号分组表示法</strong>，例如 20 01:0 db8:85a3:00 00:00 00:8 a2e:03 70:73 34。</p>
<p><strong>自动配置：IPv6引入了一种称为“无状态地址自动配置（SLAAC）”的机制</strong>，使设备能够根据网络中的路由器广告自动配置自己的IPv6地址。<strong>这简化了网络的配置和管理。</strong></p>
<p><strong>安全性：IPv6提供了内置的IPSec支持，提供了对数据的加密和认证，增强了网络层的安全性。</strong></p>
<p><strong>流量优先级：IPv6引入了流量类别和流量流标签，使得网络能够更好地管理流量</strong></p>
<p><strong>总的来说，IPv6相对于IPv4不仅提供了更大的地址空间，还具有更好的扩展性、安全性和功能性。<br>由于IPv4的广泛部署和现有基础设施的限制，IPv4仍然广泛使用</strong></p>
</blockquote>
<h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><h3 id="UDP协议的概述"><a href="#UDP协议的概述" class="headerlink" title="UDP协议的概述"></a>UDP协议的概述</h3><p>UDP协议的理解</p>
<blockquote>
<p>UDP（User Datagram Protocol）是一种在运输层提供无连接的传输服务的协议。</p>
</blockquote>
<p>UDP协议的特点</p>
<blockquote>
<p>1无连接性<br>UDP是无连接的，即在通信之前不需要进行握手和建立连接的过程。发送端将数据封装成UDP报文后，直接发送给接收端，而不需要在发送端和接收端之间建立持久的连接。这使得UDP具有更低的延迟和开销，适用于实时性要求高、数据量较小的应用场</p>
<p>2不可靠性<br>UDP不提供数据的可靠传输。一旦UDP报文发送出去，就无法保证其是否能到达接收端，也无法保证接收端按顺序接收到报文。UDP不进行重传、确认和拥塞控制等机制，对传输过程中的错误或丢失不进行纠正。</p>
<p>3尽最大努力交付,<br>即传输效率高，因为不需要维持复杂的连接状态表（这里面有许多参数)，也因此不保证可靠交付</p>
<p>4.没有拥塞控制<br>很多的实时应用（如IP电话、实时视频会议等）要求源主机以恒发的速率发送数据，并且允许在网络发生拥塞时丢失一些数据，但却不允许数据有太大的时延。UDP正好适合这种要求。</p>
<p>5面向报文<br>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。接收方对网络层交上来的UDP用户数据报，在去除首部后就原封不动地交付上层的应用进程。这意味着UDP不会对数据进行分割和重组，保持了数据的边界和完整性，但也不提供数据的可靠性和顺序性。</p>
<p>6UDP支持一对一、一对多、多对一和多对多的交互通信。<br>一对多指一个UDP发送端可以向多个UDP接收端发送数据。多对一，这意味着多个UDP发送端可以向一个UDP接收端发送数据。接收端可以接收来自多个发送端的数据，并进行相应的处理。</p>
<p>7UDP的首部开销小<br>UDP首部只有8个字节，比 TCP的20个字节的首部要短。</p>
</blockquote>
<p>适合UDP协议的应用场景</p>
<blockquote>
<p>实时性要求较高、对可靠性和顺序性要求相对较低的应用场景。它具有低延迟、高效性和简单性的特点，但不提供可靠传输和连接管理的功能。</p>
</blockquote>
<h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><h3 id="TCP协议的概述"><a href="#TCP协议的概述" class="headerlink" title="TCP协议的概述"></a>TCP协议的概述</h3><p>TCP协议的理解</p>
<blockquote>
<p>TCP（Transmission Control Protocol）是一种面向连接的、可靠的传输层协议。</p>
</blockquote>
<p>TCP协议的特点</p>
<blockquote>
<p>1面向连接<br>在数据传输之前，发送端和接收端需要先建立一个TCP连接。连接的建立和终止都需要经过握手和挥手的过程。</p>
<p>2.可靠性<br>TCP提供可靠的数据传输，保证数据的完整性和顺序性。它使用序号和确认号的机制来确保数据的准确传输。接收端会确认收到的数据，并要求发送端重传丢失的数据，以及对乱序的数据进行排序和重组。</p>
<p>3.流量控制<br>TCP通过流量控制机制，确保发送端不会以过快的速度发送数据导致接收端无法处理。接收端使用滑动窗口来告知发送端可接收的数据量，发送端根据接收端的窗口大小进行发送控制。</p>
<p>4拥塞控制<br>TCP具有拥塞控制机制，用于防止网络拥塞和保持网络的稳定性。通过监测网络的负载情况和反馈信息，TCP动态调整发送端的发送速率，以避免网络拥塞的发生。</p>
<p>5面向字节流<br>TCP将应用层传输的数据看作是一个连续的字节流，而不是离散的消息。它会将数据分割成TCP报文段进行传输，并在接收端进行重新组装。</p>
<p>6全双工通信<br>TCP连接是全双工的，允许发送端和接收端同时发送和接收数据，实现双向通信。</p>
</blockquote>
<p>TCP适用场景</p>
<blockquote>
<p>它适用于对数据传输的准确性和顺序性要求较高的应用场景，如文件传输、电子邮件、网页浏览等。<br>但是在一些实时性要求高、数据量小且可靠性要求较低的应用中，UDP协议可能更为适合。</p>
</blockquote>
<h3 id="TCP的连接"><a href="#TCP的连接" class="headerlink" title="TCP的连接"></a>TCP的连接</h3><p>TCP连接建立过程的说明（TCP三次握手）</p>
<blockquote>
<p>TCP连接建立图示<br><img src="/blog/fujian/88c67c4361f80956d4bbcc7472ce7f26.png"><br>TCP建立连接的过程需要在客户和服务器之间交换三个 TCP 报文段，因此TCP连接建立也称为三次握手。</p>
<p>假定主机A运行的是TCP客户程序，而B运行TCP服务器程序。图中在主机下面的方框分别是TCP进程所处的状态。在本例中,A主动打开连接,而B被动打开连接。</p>
<p>最初两端的TCP进程都处于CLOSED（关闭）状态。</p>
<p>一开始，B的 TCP服务器进程先创建传输控制块 TCB，准备接受客户进程的连接请求。然后服务器进程就处于LISTEN（收听）状态，等待客户的连接请求。如有，即作出响应。</p>
<p>A的TCP客户进程也是首先创建传输控制模块TCB。然后向B发出连接请求报文段，再然后，TCP客户进程进入SYN-SENT（同步已发送)状态。<br>发出的连接请求报文段，其首部中的同步位SYN&#x3D; 1，同时选择一个初始序号 seq &#x3D;x。TCP 规定，SYN报文段(即SYN &#x3D;1的报文段）不能携带数据，但要消耗掉一个序号。</p>
<p>B收到连接请求报文段后，如同意建立连接，则向A发送确认报文段。然后TCP服务器进程进入SYN-RCVD（同步收到)状态。<br>在确认报文段中应把SYN位和 ACK位都置1，确认号是ack &#x3D;x +1，同时也为自己选择一个初始序号seq&#x3D;y请注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。</p>
<p>A收到B的确认后，还要向B给出确认报文段。然后TCP连接已经建立，A进入 ESTABLISHED（已建立连接）状态。<br>确认报文段的ACK置1，确认号ack &#x3D; y + 1，而自己的序号seq&#x3D;x +1。TCP的标准规定，ACK报文段可以携带数据。但如果不携带数据则不消耗序号，在这种情况下，下一个数据报文段的序号仍是seq&#x3D; x+1。注意A发送给B的报文段只需要确认B的响应，不需要再请求建立连接，因此SYN标志位应该是0。</p>
<p>当B收到A的确认后,也进入ESTABLISHED状态。</p>
</blockquote>
<p>三次握手过程简化说明</p>
<blockquote>
<p>1、第一次握手：服务器处于收听状态，客户端给服务器发送一个请求报文，也就是 SYN 报文。之后客户端处于同步已发送状态。</p>
<p>2、第二次握手：服务器收到 SYN 报文之后，同意连接，就向客户端发送确认连接报文段。也就是 SYN+ACK 报文，然后服务器处于同步已接收状态。</p>
<p>3、第三次握手：客户端收到 SYN+ACK 报文之后，会向服务器回应一个确认报文，也就是 ACK 报文。此时客户端就处于已建立连接状态</p>
<p>4、服务器收到 ACK 报文之后，也处于已建立连接，三次握手建立完成。</p>
</blockquote>
<p>三次握手的原因</p>
<blockquote>
<p>作用是为了确认双方的接收与发送能力是否正常。<br>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。<br>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。<br>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。<br>因此，需要三次握手才能确认双方的接收与发送能力是否正常。</p>
</blockquote>
<p>创建传输控制块 TCB的理解</p>
<blockquote>
<p>传输控制块TCB (Transmission Control Block)存储了每一个连接中的一些重要信息</p>
</blockquote>
<p>确认ACK (ACKnowledgment)的理解</p>
<blockquote>
<p>确认ACK是TCP报文段首部的一个字段。<br>仅当ACK&#x3D;1时确认号字段才有效。当ACK &#x3D; 0时，确认号无效。TCP规定，在连接建立后所有传送的报文段都必须把ACK置1。</p>
</blockquote>
<p>同步SYN (SYNchronization)的理解</p>
<blockquote>
<p>同步SYN是TCP报文段首部的一个字段。<br>在连接建立时用来同步序号。当SYN &#x3D; 1而ACK&#x3D;0时，表明这是一个连接请求报文段。<br>对方若同意建立连接，则应在响应的报文段中使SYN &#x3D; 1和 ACK&#x3D;1。因此，SYN置为1就表示这是一个连接请求或连接接受报文。</p>
</blockquote>
<p>序号seq的理解</p>
<blockquote>
<p>序号seq 是TCP报文段首部的一个字段<br>在一个 TCP连接中传送的TCP报文段中（也就是字节流中），TCP报文段中每一个字节都按顺序编号。而序号seq 字段值则指的是本报文段所发的数据的第一个字节的序号。<br>例如，一报文段的序号字段值是301，而携带的数据共有10字节。这就表明:本报文段的数据的第一个字节的序号是 301，最后一个字节的序号是400。显然，下一个报文段（如果还有的话）的数据序号应当从401开始，即下一个报文阜的序号字段值应为401。这个字段的名称也叫做“报文段序号”。</p>
</blockquote>
<p>确认号ack的理解</p>
<blockquote>
<p>确认号ack是TCP报文段首部的一个字段。<br>它是期望收到对方下一个报文段的第一个数据字节的序号。例如，B正确收到了A发送过来的一个报文段，其序号字段值是501，而数据长度是200字节(序号501～700)，这表明B正确收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701。</p>
</blockquote>
<h3 id="TCP连接的释放"><a href="#TCP连接的释放" class="headerlink" title="TCP连接的释放"></a>TCP连接的释放</h3><p>TCP连接的释放的过程说明</p>
<blockquote>
<p><img src="/blog/fujian/b3a864a7c25e70fc1c290ca7ac3d0e68.png"><br><img src="/blog/fujian/71502e75e7cc3e79270e32d698c04f53.png"><br><img src="/blog/fujian/3d2c27a8f87e8d9e291683864cd674ba.png"><br><img src="/blog/fujian/4d92286035d5b54b6d174151e8760199.png"><br><img src="/blog/fujian/8d942008dc0f87b3df1bdbe19e3f3021.png"></p>
</blockquote>
<p>TCP连接的释放的过程简化说明</p>
<blockquote>
<p>首先双方处于已建立连接状态<br>第一次挥手：客户端要解除连接，就向服务器发送一个出连接释放报文（ FIN 报文），并停止在发送数据，此时客户端处于终止等待1状态。</p>
<p>第二次挥手：服务端收到连接释放报文（ FIN 报文）之后，会发送 确认报文（ACK 报文），然后进入关闭等待状态，客户端接收到确认报文后，处于终止等待2状态。此时服务器若发送数据，客户端仍要接收。</p>
<p>第三次挥手：如果服务端也想断开连接了，就给客户端发送连接释放报文（ FIN 报文）。此时服务端处于 最后确认状态。</p>
<p>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，此时客户端处于 TIME_WAIT 状态，也就是时间等待状态。确保服务端收到自己的 ACK 报文之后才会进入关闭状态。</p>
<p>服务端收到 ACK 报文之后，就处于关闭连接了，处于 关闭状态。</p>
</blockquote>
<p>TIME_WAIT这个状态的理解</p>
<blockquote>
<p>为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭。这其中的原因就是，要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 FIN 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文</p>
</blockquote>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h2><p>域名系统的理解</p>
<blockquote>
<p>用户与互联网上某台主机通信时，必须要知道对方的IP地址。然而用户很难记住二进制主机地址。应用层为了便于用户记忆连接在互联网上的主机不仅有IP地址，而且还有便于用户记忆的主机名字。<br>域名系统DNS能够把互联网上的主机名字转换为IP地址。</p>
</blockquote>
<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>超文本文档的理解</p>
<blockquote>
<p>我们平时在浏览器中浏览的网页通常就是超文本文档。<br>这些超文本文档由HTML语言编写，他们由浏览器解析和渲染，呈现给用户。<br>超文本文档中的内容可以包括文字、图像、链接、表格、音频、视频等多种元素。</p>
</blockquote>
<p>万维网的理解</p>
<blockquote>
<p>万维网（World Wide Web），简称WWW，它由许多互相链接的超文本文档组成。<br>用户通过浏览器软件可以浏览和访问这些超文本文档，通过点击文档中的链接，可以跳转到其他文档或资源，从而实现了文档之间的关联和交互。</p>
</blockquote>
<p>HTTP协议的理解</p>
<blockquote>
<p>HTTP协议定义了浏览器(即万维网客户进程)怎样向万维网服务器请求万维网文档,以及服务器怎样把文档传送给浏览器。<br>请注意，HTTP 不仅传送完成超文本跳转所必需的信息，而且也传送任何可从互联网上得到的信息，如文本、超文本、声音和图像等。</p>
</blockquote>
<p>万维网工作流程</p>
<blockquote>
<p>每个万维网网点都有一个服务器进程，它不断地监听TCP的端口80，以便发现是否有浏览器向它发出连接建立请求。<br>一旦监听到连接建立请求并建立了TCP连接之后，浏览器就向万维网服务器发出浏览某个页面的请求，服务器接着就返回所请求的页面作为响应。最后，TCP 连接就被释放了。<br>注意在这过程中，在浏览器和服务器之间的请求和响应的交互，必须按照超本传送协议HTTP。</p>
</blockquote>
<p>用户浏览页面的方法</p>
<blockquote>
<p>一种方法是在浏览器的地址窗口中键入所要找的页面的URL。<br>另一种方法是在某一个页面中用鼠标点击一个可选部分，这时浏览器会自动在互联网上找到所要链接的页面。</p>
</blockquote>
<p>HTTP协议的特点</p>
<blockquote>
<p>HTTP使用了TCP协议<br>保证了数据的可靠传输。</p>
<p>HTTP协议是无状态的<br>意味着每个HTTP请求都是独立的，服务器不会保留客户端的任何状态信息。当客户端发送请求时，服务器只会根据请求中的信息进行处理，并返回响应给客户端。服务器并不知道曾经是否访问过的这个客户。</p>
</blockquote>
<p>浏览器请求一个万维网文档所需时间</p>
<blockquote>
<p><strong>需要用到2个RTT时间，一个 RTT用于连接 TCP连接,另一个RTT用于请求和接收万维网文档。</strong><br>用户在点击鼠标链接某个万维网文档时，HTTP协议首先要和服务器建立TCP连接。这需要使用三报文握手。当建立TCP连接的三报文握手的前两部分完成后(即经了一个 RTT 时间后)，万维网客户就把 HTTP请求报文，作为建立TCP连接的三报文握手中的第三个报文的数据，发送给万维网服务器。服务器收到HTTP请求报文后，就把所请求的文档作为响应报文返回给客户。</p>
</blockquote>
<p>HTTP1.0的优缺点</p>
<blockquote>
<p><strong>HTTP1.0的主要缺点，就是每请求一个文档就要有两倍RTT的开销。<br>其次HTTP1.0是非持续连接，每次HTTP请求都需要建立一个新的TCP连接，请求完成后立即关闭连接，会使万维网服务器的负担很重。</strong><br>如果某个页面有很多链接对象，用户点击一个链接，就需要建立TCP连接，请求一个文档就需要花费2RTT的开销。</p>
</blockquote>
<p>HTTP1.1的优缺点</p>
<blockquote>
<p><strong>优点：HTTP1.1为了解决了http1.0的问题，他使用了持续连接。<br>持久连接允许在单个TCP连接上发送多个HTTP请求和响应,可以减少建立和关闭TCP连接的开销。</strong><br><strong>缺点: HTTP1.1用单个TCP连接解决多个HTTP请求，但是当其中一个请求出现延迟或阻塞时，会阻塞后续请求的处理。</strong></p>
<p>这意味着在同一连接上可以发送多个HTTP请求，并且服务器可以在接收到请求后立即发送响应，而无需重新建立连接。<br>通过使用持久连接，可以减少建立和关闭TCP连接的开销，并减少网络延迟</p>
</blockquote>
<p>HTTP2.0的优缺点</p>
<blockquote>
<p><strong>优点：HTTP2.0为了解决HTTP1.1的问题，他在采用了多路复用，即在单个TCP连接上同时进行多个请求和响应来实现多路复用。<br>这消除了HTTP&#x2F;1.1中存在的队头阻塞问题，提高了请求的并发性和响应速度。<br>能做到这一点的前提就是，http2.0采用了二进制分帧，即会将所有要传输的信息分割为更小的消息和帧，在进行发送。<br>HTTP&#x2F;2使用了HPACK算法对请求和响应的头部进行压缩，减少了传输的数据量。</strong><br>而这个负责拆分、组装请求和二进制帧的一层就叫做二进制分帧层.</p>
</blockquote>
<p>二进制分帧的作用</p>
<blockquote>
<p>这种做法的好处是，他在传输一个大的数据块时，可能需要很长时间，较小的帧可以更快地发送和接收，减少了传输延迟。较小的帧可以更快地发送和接收，减少了传输延迟</p>
</blockquote>
<p>二进制分帧可以做到多路复用的原因</p>
<blockquote>
<p>举例，服务器收到了A请求和B请求。<br>在HTTP&#x2F;1.1中，服务器需要先处理完A请求才能回应B请求。<br>在HTTP&#x2F;2.0中，服务器可以将A请求和B请求分成多个帧，并交替发送，这样可以提高并发性和响应速度。</p>
</blockquote>
<h2 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h2><p>TLS协议</p>
<blockquote>
<p>他是运输层安全协议，主要使用密码学技术来加密通信内容，是一种加密协议。<br>举例<br>当使用TCP作为传输协议时，TLS通常以加密的方式运行在TCP之上。TLS在TCP连接建立后启动，它使用握手协议来协商密钥、验证身份和进行加密。一旦TLS握手成功，TCP传输的数据将通过TLS进行加密和解密，从而保证数据的安全性。</p>
</blockquote>
<p>HTTPS的理解</p>
<blockquote>
<p><strong>是HTTP的安全版本。它在应用层HTTP的基础上，使用了传输层安全协议TLS，对通信进行加密，并且还使用身份验证机制。提供了更安全的数据传输。</strong></p>
<p>客户端通过HTTPS与服务器建立连接时，首先会进行TLS握手过程，包括协商加密算法、验证服务器身份和生成加密密钥等步骤。一旦握手成功，通信双方之间的数据将通过TLS协议进行加密，保护数据的机密性和完整性</p>
</blockquote>
<p>HTTPS的过程</p>
<blockquote>
<p> 1.客户端发送自己支持的加密规则给服务器，代表告诉服务器要进行连接了；  </p>
<p>2.服务器从中选出一套加密算法和 hash 算法以证书的形式发送给浏览器，其中证书中还包含服务器信息，加密公钥，证书的办法机构；  </p>
<p>3.客户端收到网站的证书，先验证证书的合法性；<br>如果验证通过证书，客户端生成一串随机数，并使用证书中的公钥对该随机数进行加密。<br>客户端使用约定好的哈希算法计算握手消息的哈希值，并且用公钥将其加密。最终将加密的握手消息、加密的随机数和计算的哈希值一起发送给服务器。</p>
<p>4.服务器接收到客户端传送来的信息 ，使用自己的私钥解密加密的随机数、握手消息。得到原始的随机数和原始的握手消息。<br>服务器使用约定好的哈希算法，对原始的握手消息进行计算哈希值，验证 hash 值是否和客户端发来的一致；  </p>
<p>5.如果计算法 hash 值一致，握手成功。</p>
</blockquote>
<p>公钥和私钥的理解</p>
<blockquote>
<p>公钥加密算法可以使用公钥算法对数据进加密。<br>只有拥有相应私钥的实体（在这里是服务器），才能使用私钥解密算法，解密由公钥加密的数据。</p>
</blockquote>
<p>哈希算法的理解</p>
<blockquote>
<p>相同的输入，同一个哈希算法，产生相同的输出，也就是哈希值。</p>
</blockquote>
<p>随机数的作用</p>
<blockquote>
<p>这个随机数在握手过程中是用于密钥协商的，并不直接参与哈希算法的计算。</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://xingwumo.github.io/blog">wumo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://xingwumo.github.io/blog/2023/07/01/B1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">http://xingwumo.github.io/blog/2023/07/01/B1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://xingwumo.github.io/blog" target="_blank">wumo学习分享仓库</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/blog/fujian/1086f6027eb51154d19ef8a1e3b3aa21.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://fastly.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blog/2023/07/01/B2.C++%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/" title="B2.C++类和对象"><img class="cover" src="/blog/fujian/c18a5aebdee3f6a9262f3536aece0d16.jpg" onerror="onerror=null;src='/blog/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">B2.C++类和对象</div></div></a></div><div class="next-post pull-right"><a href="/blog/2023/07/01/B5.C++STL/" title="B5.C++STL"><img class="cover" src="/blog/fujian/4f7e72f6ec78d0bf231e6368530d04f2.jpg" onerror="onerror=null;src='/blog/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">B5.C++STL</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/blog/img/favicon.png" onerror="this.onerror=null;this.src='/blog/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">wumo</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">计算机网络体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">五层协议体系结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OSI%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">OSI七层协议结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-x2F-IP%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">TCP&#x2F;IP体系结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-number">2.</span> <span class="toc-text">网络层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">2.1.</span> <span class="toc-text">网络层的基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IP%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.2.</span> <span class="toc-text">IP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IP%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-number">2.2.1.</span> <span class="toc-text">IP协议的概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ARP%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.2.2.</span> <span class="toc-text">ARP协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ICMP%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.2.3.</span> <span class="toc-text">ICMP协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IGMP%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.2.4.</span> <span class="toc-text">IGMP协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IPV4%E5%92%8CIPV6"><span class="toc-number">2.2.5.</span> <span class="toc-text">IPV4和IPV6</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E8%BE%93%E5%B1%82"><span class="toc-number">3.</span> <span class="toc-text">运输层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.1.</span> <span class="toc-text">UDP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.1.</span> <span class="toc-text">UDP协议的概述</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.2.</span> <span class="toc-text">TCP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-number">3.2.1.</span> <span class="toc-text">TCP协议的概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E7%9A%84%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.2.2.</span> <span class="toc-text">TCP的连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E9%87%8A%E6%94%BE"><span class="toc-number">3.2.3.</span> <span class="toc-text">TCP连接的释放</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-number">4.</span> <span class="toc-text">应用层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9FDNS"><span class="toc-number">4.1.</span> <span class="toc-text">域名系统DNS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.2.</span> <span class="toc-text">HTTP协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTPS%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.3.</span> <span class="toc-text">HTTPS协议</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/blog/2024/01/02/%E7%A7%92%E9%80%9F5CM%E6%96%87%E6%A1%88%201/" title="秒速5CM文案 1"><div style="background: transparent"></div></a><div class="content"><a class="title" href="/blog/2024/01/02/%E7%A7%92%E9%80%9F5CM%E6%96%87%E6%A1%88%201/" title="秒速5CM文案 1">秒速5CM文案 1</a><time datetime="2024-01-01T16:00:00.000Z" title="发表于 2024-01-02 00:00:00">2024-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/07/23/B1.C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="B1.C++基础知识"><img src="/blog/fujian/7f6aba31b4c37b3ff37eeec6dea1eb08.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="B1.C++基础知识"/></a><div class="content"><a class="title" href="/blog/2023/07/23/B1.C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="B1.C++基础知识">B1.C++基础知识</a><time datetime="2023-07-22T16:00:00.000Z" title="发表于 2023-07-23 00:00:00">2023-07-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/07/02/GamePlay%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6%E6%9E%84%E6%88%90/" title="GamePlay基础框架构成"><img src="/blog/fujian/c9e4acd4daeeff67236a5f9bfa0e57e6.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="GamePlay基础框架构成"/></a><div class="content"><a class="title" href="/blog/2023/07/02/GamePlay%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6%E6%9E%84%E6%88%90/" title="GamePlay基础框架构成">GamePlay基础框架构成</a><time datetime="2023-07-01T16:00:00.000Z" title="发表于 2023-07-02 00:00:00">2023-07-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/07/01/B1.Markdown%E7%9A%84%E5%B8%B8%E7%94%A8%E8%AF%AD%E8%A8%80%E8%A7%84%E5%88%99/" title="B1.Markdown的常用语言规则"><img src="/blog/fujian/86f423ffed4a9a1c33ff8db747ba24b2.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="B1.Markdown的常用语言规则"/></a><div class="content"><a class="title" href="/blog/2023/07/01/B1.Markdown%E7%9A%84%E5%B8%B8%E7%94%A8%E8%AF%AD%E8%A8%80%E8%A7%84%E5%88%99/" title="B1.Markdown的常用语言规则">B1.Markdown的常用语言规则</a><time datetime="2023-06-30T16:00:00.000Z" title="发表于 2023-07-01 00:00:00">2023-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/07/01/B1.Git%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="B1.Git基础知识"><img src="/blog/fujian/b9a047b5abbc54c9f035ccdaab4e02e0.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="B1.Git基础知识"/></a><div class="content"><a class="title" href="/blog/2023/07/01/B1.Git%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="B1.Git基础知识">B1.Git基础知识</a><time datetime="2023-06-30T16:00:00.000Z" title="发表于 2023-07-01 00:00:00">2023-07-01</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By wumo</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/blog/js/utils.js"></script><script src="/blog/js/main.js"></script><script src="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>