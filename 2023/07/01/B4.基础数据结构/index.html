<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>B4.基础数据结构 | wumo学习分享仓库</title><meta name="author" content="wumo"><meta name="copyright" content="wumo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据结构的基础知识数据结构的理解和相关定义数据结构的理解  数据结构是指存储和组织数据的方式，它分为物理结构和逻辑结构（简单来说，数据结构就是设计数据以何种方式组织，何种方式存储在计算机中。比如:列表、集合与字典等都是一种数据结构。）常用的数据结构有线性表、树等数据结构^c1d1  数据结构中的物理结构和逻辑结构数据结构中的逻辑结构的理解  某个数据结构的逻辑结构，就是指在这个数据结构里，数据元">
<meta property="og:type" content="article">
<meta property="og:title" content="B4.基础数据结构">
<meta property="og:url" content="http://xingwumo.github.io/blog/2023/07/01/B4.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="wumo学习分享仓库">
<meta property="og:description" content="数据结构的基础知识数据结构的理解和相关定义数据结构的理解  数据结构是指存储和组织数据的方式，它分为物理结构和逻辑结构（简单来说，数据结构就是设计数据以何种方式组织，何种方式存储在计算机中。比如:列表、集合与字典等都是一种数据结构。）常用的数据结构有线性表、树等数据结构^c1d1  数据结构中的物理结构和逻辑结构数据结构中的逻辑结构的理解  某个数据结构的逻辑结构，就是指在这个数据结构里，数据元">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://xingwumo.github.io/blog/fujian/a4765ed9990a10e5015c6931b31b06f2.png">
<meta property="article:published_time" content="2023-06-30T16:00:00.000Z">
<meta property="article:modified_time" content="2023-06-30T18:08:04.115Z">
<meta property="article:author" content="wumo">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://xingwumo.github.io/blog/fujian/a4765ed9990a10e5015c6931b31b06f2.png"><link rel="shortcut icon" href="/blog/img/favicon.png"><link rel="canonical" href="http://xingwumo.github.io/blog/2023/07/01/B4.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/blog/css/index.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/blog/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://fastly.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://fastly.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'B4.基础数据结构',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-01 02:08:04'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/blog/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/blog/fujian/a4765ed9990a10e5015c6931b31b06f2.png')"><nav id="nav"><span id="blog-info"><a href="/blog/" title="wumo学习分享仓库"><span class="site-name">wumo学习分享仓库</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">B4.基础数据结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-30T16:00:00.000Z" title="发表于 2023-07-01 00:00:00">2023-07-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-30T18:08:04.115Z" title="更新于 2023-07-01 02:08:04">2023-07-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/blog/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="B4.基础数据结构"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><img src="/blog/fujian/a4765ed9990a10e5015c6931b31b06f2.png"></p>
<h1 id="数据结构的基础知识"><a href="#数据结构的基础知识" class="headerlink" title="数据结构的基础知识"></a>数据结构的基础知识</h1><h2 id="数据结构的理解和相关定义"><a href="#数据结构的理解和相关定义" class="headerlink" title="数据结构的理解和相关定义"></a>数据结构的理解和相关定义</h2><p>数据结构的理解</p>
<blockquote>
<p>数据结构是指存储和组织数据的方式，它分为物理结构和逻辑结构<br>（简单来说，数据结构就是设计数据以何种方式组织，何种方式存储在计算机中。比如:列表、集合与字典等都是一种数据结构。）<br>常用的数据结构有线性表、树等数据结构<br>^c1d1</p>
</blockquote>
<h2 id="数据结构中的物理结构和逻辑结构"><a href="#数据结构中的物理结构和逻辑结构" class="headerlink" title="数据结构中的物理结构和逻辑结构"></a>数据结构中的物理结构和逻辑结构</h2><p>数据结构中的逻辑结构的理解</p>
<blockquote>
<p>某个数据结构的逻辑结构，就是指在这个数据结构里，数据元素之间的互相关系。<br>比如说线性表的的逻辑结构就是线性结构，就是表中的的元素之间存在一对一的关系，一个元素后面接着一个，这是线性表的逻辑结构。<br>再比如二叉树的逻辑结构，元素之间的相互关系，就是一个父亲节点下面有两个子节点，子节点下面又有两个子节点。这就是二叉树的逻辑结构。二叉树虽然可以用数组实现，但是其逻辑结构则是树结构。</p>
</blockquote>
<p>数据结构中的物理结构的理解</p>
<blockquote>
<p>某个数据结构的物理结构，就是指在这个数据结构里，数据存储在磁盘中的方式。<br>比如有一个数据结构为线性表，其逻辑结构是线性结构。而线性表根据不同的物理结构，又有两种实现方式。一种实现方式的物理结构是使用顺序存储，线性表的元素连续的的存储在计算机存储器中，这时候这种采用顺序存储结构的线性表就叫顺序表。另一种实现方式的物理结构是使用链式结构，其元素不一定是连续的存储在计算机存储器中 ，而用链式存储结构的线性表也叫链表。</p>
</blockquote>
<p>数据结构中的逻辑结构分类</p>
<blockquote>
<p><strong>数据结构按照其逻辑结构可分为线性结构、树结构、图结构。</strong><br>线性结构，数据结构中的元素存在一对一的相互关系。比如列表，一个元素后面接着一个元素。</p>
<p>树结构，数据结构中的元素存在一对多的相互关系。比如二叉树，一个父亲节点后面有两个子节点。</p>
<p>图结构，数据结构中的元素存在多对多的相互关系</p>
</blockquote>
<p>物理结构分类</p>
<blockquote>
<p><strong>数据结构按照其物理结构可分为顺序存储、链式存储、索引存储以及散列存储。</strong><br>顺序存储，存储顺序是连续的，在内存中用一组地址连续的存储单元依次存储线性表的各个数据元素。</p>
<p>链式存储，在内存中的存储元素不一定是连续的，用任意地址的存储单元存储元素，元素节点存放数据元素以及通过指针指向相邻元素的地址信息。</p>
<p>索引存储，除建立存储结点信息外，还建立附加的索引表来标识节点的地址。索引表由若干索引项组成。</p>
<p>散列存储，又称Hash存储，由节点的关键码值决定节点的存储地址</p>
<p>注意，<br>（数据结构学习重点就在数据结构的逻辑结构，物理结构了解即可）</p>
</blockquote>
<h2 id="数据结构的常用函数"><a href="#数据结构的常用函数" class="headerlink" title="数据结构的常用函数"></a>数据结构的常用函数</h2><blockquote>
<p>初始化、释放、增删查遍历</p>
</blockquote>
<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="线性表的基础知识"><a href="#线性表的基础知识" class="headerlink" title="线性表的基础知识"></a>线性表的基础知识</h2><p>线性表的理解</p>
<blockquote>
<p>线性表是一种常见的数据结构，它是由n个具有相同数据类型的数据元素a1, a2, …, an 组成的有限序列。<br>线性表的特点是数据元素之间存在一种线性关系，每个数据元素最多只有一个直接前驱和一个直接后继。</p>
</blockquote>
<p>线性表的性质</p>
<blockquote>
<p>a0为线性表的第一个元素，只有一个后继a1。<br>an为线性表的最后一个元素，只有一个前驱an-1。<br>除a0和an外的其它元素ai，既有前驱ai-1，又有后继ai+1。</p>
</blockquote>
<p>线性表举例说明</p>
<blockquote>
<p><img src="/blog/fujian/53ccdb4298f0d2fc5cab34b99f4db55b.png"><br>学生情况信息表是一个线性表，表中数据元素的类型为由学号、姓名、性别、年龄、专业等组成的结构体类型，也就是说表的每一行（除第一行）就是一个数据元素，一个数据元素内容包含 学号、姓名、性别、年龄、专业等 内容。</p>
</blockquote>
<p>线性表的结构</p>
<blockquote>
<p>线性表的逻辑结构是线性结构。线性表根据不同的物理结构，又有两种实现方式。一种实现方式的物理结构是使用顺序存储，线性表的元素连续的的存储在计算机存储器中，这时候这种采用顺序存储结构的线性表就叫顺序表。另一种实现方式的物理结构是使用链式结构，其元素不一定是连续的存储在计算机存储器中 ，而用链式存储结构的线性表也叫链表。</p>
</blockquote>
<h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><h3 id="顺序表的基础知识"><a href="#顺序表的基础知识" class="headerlink" title="顺序表的基础知识"></a>顺序表的基础知识</h3><p>顺序表的理解</p>
<blockquote>
<p>顺序表是线性表的一种。线性表根据不同的物理结构，有两种实现方式，当线性表的物理结构是采用顺序存储结构时，线性表就叫顺序表。此时内存中会用地址连续的一块存储空间顺序存放线性表的各元素</p>
</blockquote>
<h3 id="顺序表的实现"><a href="#顺序表的实现" class="headerlink" title="顺序表的实现"></a>顺序表的实现</h3><p>接口文件SXB.h</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">class SXB</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    int *dz; //地址，存放数据的地址，他存放数组的首地址，由这个首地址，就可以获得整个数组内容。</span><br><span class="line">	int sl;  //数量，表示存储在当前容器的元素数量</span><br><span class="line">    int rl;  //容量，表示当前容器最大能容纳的元素</span><br><span class="line">  </span><br><span class="line">public:</span><br><span class="line">    //初始构造函数，初始化对象</span><br><span class="line">    SXB();</span><br><span class="line"></span><br><span class="line">    //末尾插入函数，在顺序表的末尾插入传入的数值.value是传入顺序表的数值</span><br><span class="line">    bool push_back_SXB(int value);</span><br><span class="line"></span><br><span class="line">    //位置删除函数，根据传入的位置，在顺序表中删除该位置的值。pos是传入的位置。</span><br><span class="line">    bool remove_pos_SXB(int pos);</span><br><span class="line"></span><br><span class="line">    //值删除函数，根据传入的数值，在顺序表删除该值。value是传入顺序的数值。</span><br><span class="line">    bool remove_value_SXB(int value);</span><br><span class="line"></span><br><span class="line">    //查位置函数，根据传入的数值，在顺序表中，查找该该值的位置。value是传入的数值</span><br><span class="line">    int find_pos_SXB(int value);</span><br><span class="line"></span><br><span class="line">    //打印函数，输出顺序表的值。</span><br><span class="line">    bool print_SXB();</span><br><span class="line"></span><br><span class="line">    //清空函数，清空顺序表的值。</span><br><span class="line">    bool clear_SXB();</span><br><span class="line"></span><br><span class="line">    //查容量函数，查找当前顺序表的容量</span><br><span class="line">    int return_rl_SXB();</span><br><span class="line"></span><br><span class="line">    //查数量函数，查找当前顺序表存储的元素的数量。</span><br><span class="line">    int return_sl_SXB();</span><br><span class="line">  </span><br><span class="line">    //析构函数</span><br><span class="line">    ~SXB();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接口的实现文件 SXB.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;SXB.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//初始构造函数，初始化对象</span><br><span class="line">SXB::SXB()</span><br><span class="line">&#123;</span><br><span class="line">    dz = new int[20];</span><br><span class="line">    rl = 20;</span><br><span class="line">    sl = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//末尾插入函数，在顺序表的末尾插入传入的数值.value是传入顺序表的数值</span><br><span class="line">bool SXB::push_back_SXB(int value)</span><br><span class="line">&#123;</span><br><span class="line">    //判断是否顺序表的容量满了。如果满了执行if里的函数</span><br><span class="line">    if (sl == rl)</span><br><span class="line">    &#123;</span><br><span class="line">        //申请一个新的更多大的空间，这个空间是旧的空间的大小的两倍。xdz是新地址用于存储新的空间的地址。</span><br><span class="line">        int *xdz = new int[rl * 2];</span><br><span class="line">        //把旧的空间的数据复制到新的空间</span><br><span class="line">        for (int i = 0; i &lt; sl; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            xdz[i] = dz[i];</span><br><span class="line">        &#125;</span><br><span class="line">        //把旧的空间释放掉</span><br><span class="line">        delete[] dz;</span><br><span class="line">        dz = xdz;</span><br><span class="line"></span><br><span class="line">        //更新容量</span><br><span class="line">        rl = rl * 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //在顺序表末尾插入新元素</span><br><span class="line">    dz[sl] = value;</span><br><span class="line">    //更新元素数量</span><br><span class="line">    ++sl;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//位置删除函数，根据传入的位置，在顺序表中删除该位置的值。pos是传入的位置。</span><br><span class="line">bool SXB::remove_pos_SXB(int pos)</span><br><span class="line">&#123;</span><br><span class="line">    //顺序表元素数量为0，或者传入的位置大于顺序表元素的数量，则则删除失败</span><br><span class="line">    if (sl == 0 || pos &gt; sl || pos &lt;= 0)</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    //删除元素，就是将顺序表pos位置开始的值（不包括pos位置的值），都往前挪一个位置，自然就删除了pos位置的值</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = pos - 1; i &lt; sl - 1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dz[i] = dz[i + 1];</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//值删除函数，根据传入的数值，在顺序表删第一次出现的该值。value是传入顺序的数值。</span><br><span class="line">bool SXB::remove_value_SXB(int value)</span><br><span class="line">&#123;</span><br><span class="line">    //判断顺序表元素数量是否为0</span><br><span class="line">    if (sl == 0)</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    //获取该值的位置</span><br><span class="line">    int pos = find_pos_SXB(value);</span><br><span class="line"></span><br><span class="line">    //如果找不到该值</span><br><span class="line">    if (pos == 0)</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    //如果找到该值，用位置删除函数来进行删除。</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        remove_pos_SXB(pos);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//查位置函数，根据传入的数值，在顺序表中，查找该该值的位置，返回的位置是该值在元素表中第一次被找到的位置。value是传入的数值.返回0说明找不到这个值。</span><br><span class="line">int SXB::find_pos_SXB(int value)</span><br><span class="line">&#123;</span><br><span class="line">    //如果顺序表元素为0，则返回0</span><br><span class="line">    if (sl == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //遍历循环，查找顺序表是否有该值</span><br><span class="line">        for (int i = 0; i &lt; sl; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (dz[i] == value)</span><br><span class="line">            &#123;</span><br><span class="line">                return i + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //找不到该值返回0</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//打印函数，输出顺序表的值。</span><br><span class="line">bool SXB::print_SXB()</span><br><span class="line">&#123;</span><br><span class="line">    //顺序表元素数量为0，则无法打印。</span><br><span class="line">    if (sl == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //顺序表元素数量不为0，则可以进行打印。</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; sl; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; dz[i] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//清空函数，清空顺序表的值。</span><br><span class="line">bool SXB::clear_SXB()</span><br><span class="line">&#123;</span><br><span class="line">    //假如顺序表里已存储元素，不需要把元素清空掉，只要把表示元素数量的变量sl设为0即可。这时候在存储元素，也是从顺序表开头开始存储。</span><br><span class="line">    sl = 0;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//返回容量函数，返回当前顺序表的容量</span><br><span class="line">int SXB::return_rl_SXB()</span><br><span class="line">&#123;</span><br><span class="line">    return rl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//返回数量函数，返回当前顺序表存储的元素的数量。</span><br><span class="line">int SXB::return_sl_SXB()</span><br><span class="line">&#123;</span><br><span class="line">    return sl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//析构函数,用来释放数组的内存</span><br><span class="line">SXB::~SXB()</span><br><span class="line">&#123;</span><br><span class="line">    delete[] dz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>&#x2F;&#x2F;测试文件 test.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;SXB.h&quot;</span><br><span class="line">#include &quot;SXB.cpp&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    SXB a;</span><br><span class="line">    for (int i = 0; i &lt;= 22; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a.push_back_SXB(i);</span><br><span class="line">    &#125;</span><br><span class="line">    a.push_back_SXB(4);</span><br><span class="line">    a.print_SXB();</span><br><span class="line">    cout &lt;&lt; a.return_rl_SXB() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; a.return_sl_SXB() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><h3 id="单链表的基础知识"><a href="#单链表的基础知识" class="headerlink" title="单链表的基础知识"></a>单链表的基础知识</h3><p>链表的理解</p>
<blockquote>
<p>链表是线性表的一种，当线性表的物理结构是采用链式存储结构时，线性表就叫链表。此时其元素不一定是连续的存储在计算机存储器中。</p>
</blockquote>
<p>链表的节点理解</p>
<blockquote>
<p>在链表中，每个数据元素由一个结点表示。为了建立起数据元素之间的逻辑关系，一个的最基本的链表的节点的组成形式，除了存放数据元素的自身信息外，还需要有一个指针存储其后继元素所在的地址信息。有的其他链表的节点，除了有一个指向其后继元素的指针，可能还会其其他功能的指针。</p>
</blockquote>
<p>单链表的理解</p>
<blockquote>
<p>单链表是最基本的一种链表，每个数据元素由一个结点表示，节点除了存放数据元素的自身信息，还要含有一个指针使其指向后继元素，这种一个节点只含有一个指针，这个指针向其后继元素的链表表称为单链表。</p>
</blockquote>
<p>头指针的理解</p>
<blockquote>
<p>在单链表中，由于每个结点的存储地址存放在其前驱结点的next域中,因此第一个结点是没有前驱结点的，它的地址就是整个链表的开始地址,必须将第一个结点的地址放到一个指针变量(如图2-3所示的head)中，该指针变量称为头指针。这样就可以从头指针开始，依次找到每个结点。通常用头指针来标识一个单链表。最后一个结点没有后继,其指针域必须置空(NULL)，表明此单链表到此结束。</p>
</blockquote>
<p>头结点的理解</p>
<blockquote>
<p>在单链表中，为了方便操作，有时在链表的第一个结点前加入一个头结点,然后让头结点的next指向链表的第一个节点。<br>头结点的类型与其他数据结点相同，标识链表的头指针变量head 中存放该头结点的地址。这样即使是空表，头指针变量head也不为空了。头结点的加入使得单链表无论是否为空，头指针始终指向头结点，从而使空表和非空表的处理成为一致。</p>
<p>总的来说，头结点的加入完全是为了操作的方便，它的数据域可以不存放任何信息，也可以存放有关链表的整体信息，如表长;指针域中存放的是第一个数据结点的地址,空表时其中为空。</p>
</blockquote>
<p>带头节点的单链表图示</p>
<blockquote>
<p><img src="/blog/fujian/e5b8574a470ba1a065b3e3c0f057e70a.png"></p>
</blockquote>
<p>单链表数据节点的构建思路</p>
<blockquote>
<p>数据<br>变量data：用模板参数来定义的变量，用来存储各种类型数据<br>指针next：存储下个数据节点的地址</p>
</blockquote>
<p>单链表的构建思路</p>
<blockquote>
<p>[[单链表框架搭建.mp4#t&#x3D;01:57.415,02:43.5]]</p>
<p>数据<br>头指针head：指向头节点的指针。<br>变量Sl：表示当前表格里元素的数量</p>
</blockquote>
<p>节点插入实现思路</p>
<blockquote>
<p>[[单链表的实现.mp4#t&#x3D;07:18.279,09:40]]</p>
</blockquote>
<p>节点删除实现思路</p>
<blockquote>
<p>[[单链表的实现.mp4#t&#x3D;11:41.314,12:39]]</p>
</blockquote>
<p>链表的释放实现思路</p>
<blockquote>
<p>[[单链表的实现.mp4#t&#x3D;19:48.201,21:36.3]]</p>
</blockquote>
<h3 id="单链表的实现"><a href="#单链表的实现" class="headerlink" title="单链表的实现"></a>单链表的实现</h3><p>接口文件DLB.h</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">//链表的节点</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    T date;        //用来存储数据</span><br><span class="line">    Node&lt;T&gt; *next; //用来存储</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">class DLB</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    Node&lt;T&gt; *head;//单链表的头指针，头指针指向的第一个节点为头结点。</span><br><span class="line">    int sl;//数量，表示当前容器的元素数量。</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    //链表的初始化函数，用来初始化你的链表。</span><br><span class="line">    DLB();</span><br><span class="line">    </span><br><span class="line">    //插入函数，指定表格的位置，插入你的数值。pos是你指定的位置，value是你要插入的值，既你要把数据插入到第pos-1的结点的后面，如果pos为1，就是要把数据插入到头结点的后面。插入成功返回true，否则返回false；</span><br><span class="line">    bool insert_DLB(int pos, T value);</span><br><span class="line"></span><br><span class="line">    //位置删除函数，根据传入的位置，在顺序表中删除该位置的值。pos是传入的位置。成功则返回true，否则返回false</span><br><span class="line">    bool removebypos_DLB(int pos);</span><br><span class="line"></span><br><span class="line">    //返回数量函数，返回当前链表存储的元素的数量。</span><br><span class="line">    int return_sl_DLB();</span><br><span class="line">    </span><br><span class="line">    //位置查找函数，根据传入的位置，查找该位置的数据。pos是传入的位置。</span><br><span class="line">    T findbypos_DLB(int pos );</span><br><span class="line"></span><br><span class="line">    //打印函数，按顺序打印你的单链表的数据。</span><br><span class="line">    bool print_DLP();</span><br><span class="line"></span><br><span class="line">    //链表的释放函数，在链表结束后，用来释放你的链表。</span><br><span class="line">    ~DLB();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实现文件DLB.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;DLB.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//链表的初始化函数，用来初始化你的链表。</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">DLB&lt;T&gt;::DLB()</span><br><span class="line">&#123;</span><br><span class="line">    //创建一个链表的头结点。并将头结点指向后继的指针为null</span><br><span class="line">    Node&lt;T&gt; *tjd = new Node&lt;T&gt;;</span><br><span class="line">    tjd-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    //将头指针指向头结点</span><br><span class="line">    head = tjd;</span><br><span class="line">    //初始化sl</span><br><span class="line">    sl = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//插入函数，指定表格的位置，插入你的数值。pos是你指定的位置，value是你要插入的值，既你要把数据插入到第pos-1的结点的后面，如果pos为1，就是要把数据插入到头结点的后面。插入成功返回true，否则返回false；</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">bool DLB&lt;T&gt;::insert_DLB(int pos, T value)</span><br><span class="line">&#123;</span><br><span class="line">    //插入的位置非法则返回空。且我们设定当链表元素数量为n的时候，我们可以把值插入到n+1的位置里。</span><br><span class="line">    if (pos &lt;= 0 || pos &gt; sl + 1)</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    //插入位置合法，则进行插入</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //创建新的结点，来存储传入的数据</span><br><span class="line">        Node&lt;T&gt; *newnode = new Node&lt;T&gt;;</span><br><span class="line">        newnode-&gt;date = value;</span><br><span class="line">        newnode-&gt;next = NULL;</span><br><span class="line">        //创建一个指针，用来存储后面我们找到pos-1的位置的节点。里面先暂时存储第0个位置的节点，也就是头结点的位置。</span><br><span class="line">        Node&lt;T&gt; *jd = head;</span><br><span class="line">        //找到第pos-1的位置的节点，把这个节点的位置存储到jd。如果pos-1=0，就不用找，因为jd已经存储第0个节点的位置。</span><br><span class="line">        for (int i = 1; i &lt; pos; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            jd = jd-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //把要插入的节点</span><br><span class="line">        newnode-&gt;next = jd-&gt;next;</span><br><span class="line">        jd-&gt;next = newnode;</span><br><span class="line"></span><br><span class="line">        //更新sl</span><br><span class="line">        ++sl;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//位置删除函数，根据传入的位置，在顺序表中删除该位置的值。pos是传入的位置。成功则返回true，否则返回false</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">bool DLB&lt;T&gt;::removebypos_DLB(int pos)</span><br><span class="line">&#123;</span><br><span class="line">    //如果表为空，或者删除的位置非法，则返回false</span><br><span class="line">    if (sl == 0 || (pos &lt;= 0 || pos &gt; sl))</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //表不为空，且删除的位置合法</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //创建一个指针，用来存储后面我们找到pos-1的位置的节点。里面先暂时存储第0个位置的节点，也就是头结点的位置。</span><br><span class="line">        Node&lt;T&gt; *jd = head;</span><br><span class="line">        //找到第pos-1的位置的节点，把这个节点的位置存储到jd。如果pos-1=0，就不用找，因为jd已经存储第0个节点的位置。</span><br><span class="line">        for (int i = 1; i &lt; pos; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            jd = jd-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //创建一个指针，用来存储删除的节点，也就是pos位置的节点</span><br><span class="line">        Node&lt;T&gt; *nextjd = jd-&gt;next;</span><br><span class="line">        //将要删除节点的从表里踢出去</span><br><span class="line">        jd-&gt;next = nextjd-&gt;next;</span><br><span class="line"></span><br><span class="line">        //释放要删除的节点</span><br><span class="line">        delete nextjd;</span><br><span class="line">        //更新sl</span><br><span class="line">        --sl;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//返回数量函数，返回当前链表存储的元素的数量。</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">int DLB&lt;T&gt;::return_sl_DLB()</span><br><span class="line">&#123;</span><br><span class="line">    return sl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//位置查找函数，根据传入的位置，查找该位置的数据。pos是传入的位置。</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">T DLB&lt;T&gt;::findbypos_DLB(int pos)</span><br><span class="line">&#123;</span><br><span class="line">    //如果表为空，或查找的位置非法，则执行终止函数</span><br><span class="line">    if (sl == 0 || (pos &lt;= 0 || pos &gt; sl))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;操作错误&quot; &lt;&lt; endl;</span><br><span class="line">        //非正常退出程序函数</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //创建一个指针，用来存储后面我们找到pos的位置的节点。里面先暂时存储第0个位置的节点，也就是头结点的位置。</span><br><span class="line">        Node&lt;T&gt; *jd = head;</span><br><span class="line">        //找到第pos的位置的节点，把这个节点的位置存储到jd。</span><br><span class="line">        for (int i = 1; i &lt;= pos; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            jd = jd-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //返回寻找到的值</span><br><span class="line">        return jd-&gt;date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//打印函数，按顺序打印你的单链表的数据。</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">bool DLB&lt;T&gt;::print_DLP()</span><br><span class="line">&#123;</span><br><span class="line">    //查看表是否为空，为空则返回false</span><br><span class="line">    if (sl == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //表不为空，按顺序遍历表格</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //创建一个指针，用来指向表格中的节点，里面先暂时指向头结点</span><br><span class="line">        Node&lt;T&gt; *jd = head;</span><br><span class="line">        //遍历表</span><br><span class="line">        for (int i = 1; i &lt;= sl; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            jd = jd-&gt;next;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; &quot;:&quot; &lt;&lt; jd-&gt;date &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//链表的释放函数，在链表结束后，用来释放你的链表。</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">DLB&lt;T&gt;::~DLB()</span><br><span class="line">&#123;</span><br><span class="line">    //创建一个指针，用来指向表格中的节点，里面先暂时指向头结点</span><br><span class="line">    Node&lt;T&gt; *jd = head;</span><br><span class="line">    //用while循环，判断jd所存储的节点地址是否为空，不为空，则找一个节点缓存当前节点的地址。然后让jd存储下一个节点的地址，最后删除当前节点</span><br><span class="line">    while (jd)</span><br><span class="line">    &#123;</span><br><span class="line">        //缓存当前的地址。</span><br><span class="line">        Node&lt;T&gt; *nextjd = jd;</span><br><span class="line">        //让jd存储下一个节点的地址</span><br><span class="line">        jd = jd-&gt;next;</span><br><span class="line">       //释放缓存的的地址</span><br><span class="line">        delete nextjd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试文件test.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;DLB.h&quot;</span><br><span class="line">#include &quot;DLB.cpp&quot;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    DLB&lt;int&gt; a;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= 10; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a.insert_DLB(i, i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;sl==&quot; &lt;&lt; a.return_sl_DLB() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;第五个为&quot; &lt;&lt; a.findbypos_DLB(5) &lt;&lt; endl;</span><br><span class="line">    a.print_DLP();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="企业链表"><a href="#企业链表" class="headerlink" title="企业链表"></a>企业链表</h2><h3 id="企业链表的基础知识"><a href="#企业链表的基础知识" class="headerlink" title="企业链表的基础知识"></a>企业链表的基础知识</h3><p>企业链表的理解</p>
<blockquote>
<p>[[企业链表构建思路.mp4#t&#x3D;05:58.605,10:48]]<br>要想理解企业链表，首先得知道结构体的地址相关知识。假如定义一个结构体，里面有数据a和数据b。那么当你获得这个结构体的数据a的地址，就可以获得这个整个结构体对象的地址。（对象a的首地址和整个结构体对象首地址是一样的，只不过两个数据的地址的类型，即地址长度不一样）</p>
<p>然后可以知道企业链表和单链表之间的区别，普通的单链表的一个数据结点由两部分a和b组成，部分a存储下一个结点的地址（整个结点的地址），而b部分存储数据内容。<br>企业链表，的一个数据结点也两部分a和b组成，但是a本身也是一个节点，a存储下一个数据结点的里的a节点的地址，而不是像单链表一样存储着整个数据节点的地址，然后b部分依然是只存储数据内容，对比单链表，企业链表a只是存储整个结点中a节点的地址<br>这么做的好处在于企业链表的指针域和数据域是可以分开写的。<br>我们可以先把指针节点像普通数据节点一样一样，串连成指针链表。之后我们要把什么数据以链表的形式组织起来，那么就只需要我们把这个类型的数据，挂在已经串联起来的指针节点下面即可。</p>
</blockquote>
<p>内核链表和企业链表的区别</p>
<blockquote>
<p>[[企业链表构建思路.mp4#t&#x3D;10:52.580]]</p>
</blockquote>
<h3 id="企业链表的实现"><a href="#企业链表的实现" class="headerlink" title="企业链表的实现"></a>企业链表的实现</h3><p>接口文件QYLB.h</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">//企业链表小结点，用来串连数据结点</span><br><span class="line">struct Xjd</span><br><span class="line">&#123;</span><br><span class="line">    // next，用来存储下一个数据结点里的小结点的地址。</span><br><span class="line">    Xjd *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class QYLB</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    //企业链表的头结点</span><br><span class="line">    Xjd head;</span><br><span class="line"></span><br><span class="line">    //数量，表示表格的元素数量</span><br><span class="line">    int sl;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    //链表初始化函数</span><br><span class="line">    QYLB();</span><br><span class="line"></span><br><span class="line">    //插入函数，指定表格的位置，插入你的数值。pos是你指定的位置，value是你要插入的值。插入成功返回true，否则返回false；</span><br><span class="line">    bool insert_QYLB(int pos, Xjd *data);</span><br><span class="line"></span><br><span class="line">    //位置删除函数，根据传入的位置，在顺序表中删除该位置的值。pos是传入的位置。成功则返回true，否则返回false</span><br><span class="line">    bool removebypos_QYLB(int pos);</span><br><span class="line"></span><br><span class="line">    //值查找函数，根据传入的数据节点的小结点，查找该数据的位置,查到返回该数值位置，找不到返回0。data是传入的数据节点的小结点。compare是bool型函数指针，需要用户自定义比较数据节点的函数，然后把该函数地址通过函数指针传入进来，我们就可以依靠函数指针调用用户自定义比较数据节点的函数。</span><br><span class="line">    int findbyvalue_QYLB(Xjd *data, bool (*compare)(Xjd *p1, Xjd *p2));</span><br><span class="line"></span><br><span class="line">    //打印函数，按顺序打印你的单链表的数据，print为bool型函数指针，因为该链表的函数操作都是处理小结点的，无法处理数据节点，所以需要用户自定义操作数据节点的函数，然后把该函数地址通过函数指针传入进来，我们就可以依靠函数指针调用用户自定义的函数。</span><br><span class="line">    bool print_QYLB(bool (*prin)(Xjd *));</span><br><span class="line"></span><br><span class="line">    //返回数量函数，返回当前链表存储的元素的数量。</span><br><span class="line">    int return_sl_QYLB();</span><br><span class="line"></span><br><span class="line">    //链表析函数，在对象结束后，释放你的链表</span><br><span class="line">    ~QYLB();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实现文件QYLB.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;QYLB.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line">//链表初始化函数</span><br><span class="line"></span><br><span class="line">QYLB::QYLB()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //将头结点指向后继的指针为null</span><br><span class="line">    head.next = NULL;</span><br><span class="line"></span><br><span class="line">    //初始化变量sl</span><br><span class="line">    sl = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//插入函数，指定表格的位置，插入你的数值。pos是你指定的位置，date是你要插入数据节点的小结点地址。插入成功返回true，否则返回false；</span><br><span class="line">bool QYLB::insert_QYLB(int pos, Xjd *data)</span><br><span class="line">&#123;</span><br><span class="line">    //插入的位置非法则返回空。且我们设定当链表元素数量为n的时候，我们可以把值插入到n+1的位置里。</span><br><span class="line">    if (pos &lt;= 0 || pos &gt; sl + 1)</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    //插入位置合法，则进行插入</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        //创建一个小结点。里面先暂时存储第0个小节点（也就是头结点）的地址。后面我们可以用这个结点来找第pos-1位置小结点地址。</span><br><span class="line">        Xjd *xjd = &amp;head;</span><br><span class="line">        //循环找到第pos-1位置的小结点地址。在下面循环里，i为多少，小结点就是第i个小结点地址。</span><br><span class="line">        for (int i = 1; i &lt; pos; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            xjd = xjd-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //把要插入链表里小结点，存储原pos位置的小结点地址。</span><br><span class="line">        data-&gt;next = xjd-&gt;next;</span><br><span class="line">        //让pos-1位置的小结点存储，要插入的小结点的地址。</span><br><span class="line">        xjd-&gt;next = data;</span><br><span class="line"></span><br><span class="line">        //更新sl</span><br><span class="line">        ++sl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//位置删除函数，根据传入的位置，在顺序表中删除该位置的值。pos是传入的位置。成功则返回true，否则返回false</span><br><span class="line">bool QYLB::removebypos_QYLB(int pos)</span><br><span class="line">&#123;</span><br><span class="line">    //如果表为空，或者删除的位置非法，则返回false</span><br><span class="line">    if (sl == 0 || (pos &lt;= 0 || pos &gt; sl))</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //表不为空，且删除的位置合法</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //创建一个小结点。用来指向表格中的小结点，里面先暂时指向头结点地址</span><br><span class="line">        Xjd *xjd = &amp;head;</span><br><span class="line"></span><br><span class="line">        //找到第pos-1的位置的小节点，把这个小结点的位置存储到xjd。如果pos-1=0，就不用找，因为xjd已经存储第0个小节点的位置。</span><br><span class="line">        for (int i = 1; i &lt; pos; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            //让小结点指向下一个小结点地址。</span><br><span class="line">            xjd = xjd-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //直接把pos-1位置的小结点存储原pos+1位置小结点地址,因为数据节点不是动态申请的，所以不需要对pos位置的数据节点delete掉</span><br><span class="line">        xjd-&gt;next = xjd-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">        //更新sl</span><br><span class="line">        --sl;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//值查找函数，根据传入的数据节点的小结点，查找该数据的位置,查到返回该数值位置，找不到返回0。data是传入的数据节点的小结点。compare是bool型函数指针，需要用户自定义比较数据节点的函数，然后把该函数地址通过函数指针传入进来，我们就可以依靠函数指针调用用户自定义比较数据节点的函数。</span><br><span class="line">int QYLB::findbyvalue_QYLB(Xjd *data, bool (*compare)(Xjd *p1, Xjd *p2))</span><br><span class="line">&#123;</span><br><span class="line">    //如果表为空，或查找的位置非法，则执行终止函数</span><br><span class="line">    if (sl == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;链表为空&quot; &lt;&lt; endl;</span><br><span class="line">        //非正常退出程序函数</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //列表不为空</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //创建一个小结点指针，用来指向表格中的小结点，里面先暂时指向头结点。</span><br><span class="line">        Xjd *xjd = &amp;head;</span><br><span class="line">        //循环，找到第pos位置的小结点</span><br><span class="line">        for (int i = 1; i &lt;= sl; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            xjd = xjd-&gt;next;</span><br><span class="line">            if (compare(xjd, data))</span><br><span class="line">            &#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//打印函数，按顺序打印你的单链表的数据，print为bool型函数指针，因为该链表的函数操作都是处理小结点的，无法处理数据节点，所以需要用户自定义操作数据节点的函数，然后把该函数地址通过函数指针传入进来，我们就可以依靠函数指针调用用户自定义的函数。</span><br><span class="line">bool QYLB::print_QYLB(bool (*prin)(Xjd *))</span><br><span class="line">&#123;</span><br><span class="line">    //查看表是否为空，为空则返回false</span><br><span class="line">    if (sl == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //表不为空，按顺序遍历表格</span><br><span class="line">    else</span><br><span class="line">    &#123; //创建一个小结点。用来指向表格中的小结点，里面先暂时指向头结点地址</span><br><span class="line"></span><br><span class="line">        Xjd *xjd = &amp;head;</span><br><span class="line">        //循环遍所有的小结点</span><br><span class="line">        for (int i = 1; i &lt;= sl; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            //让小结点指向下一个小结点地址。</span><br><span class="line">            xjd = xjd-&gt;next;</span><br><span class="line">            //调用传入的用户自定义的函数，通过小结点，来打印存储小结点的数据节点的数据。</span><br><span class="line">            prin(xjd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//返回数量函数，返回当前链表存储的元素的数量。</span><br><span class="line">int QYLB::return_sl_QYLB()</span><br><span class="line">&#123;</span><br><span class="line">    return sl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//链表析函数，一般是用在对象结束后，释放我们申请的动态内存，因为企业链表没有动态申请内存，所以析构函数不用写。</span><br><span class="line">QYLB::~QYLB()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试文件Test.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;QYLB.h&quot;</span><br><span class="line">#include &quot;QYLB.cpp&quot;</span><br><span class="line">using namespace std;</span><br><span class="line">//创建数据节点</span><br><span class="line">struct Data</span><br><span class="line">&#123;</span><br><span class="line">    Xjd xjd;</span><br><span class="line">    int data;</span><br><span class="line">&#125;;</span><br><span class="line">//用户自定义的函数，可以通过小结点地址，来找到存储小结点的数据节点，并且打印存储的数据。</span><br><span class="line">bool prin(Xjd *xjd)</span><br><span class="line">&#123;</span><br><span class="line">    Data *p = (Data *)xjd;</span><br><span class="line">    cout &lt;&lt; p-&gt;data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//用户自定义的函数，可以通过两个小结点地址，来对比两个小结点的对应数据节点存储的数据是否一样，一样返回true，否则返回false。</span><br><span class="line">bool compare(Xjd *p1, Xjd *p2)</span><br><span class="line">&#123;</span><br><span class="line">    Data *p3 = (Data *)p1;</span><br><span class="line">    Data *p4 = (Data *)p2;</span><br><span class="line">    if (p3-&gt;data == p4-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //创建数据节点对象，</span><br><span class="line">    Data a[11];</span><br><span class="line">    QYLB b;</span><br><span class="line">    //用循环来对数据节点写入数据，</span><br><span class="line">    for (int i = 1; i &lt;= 10; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i].data = i;</span><br><span class="line">        //要想把数据节点像链表一样串连起来，只需要把数据节点的小结点串连起来，那么我们只需要给插入函数传进去数据节点的小结点</span><br><span class="line">        b.insert_QYLB(i, (Xjd *)&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    b.print_QYLB(prin);</span><br><span class="line">    b.removebypos_QYLB(5);</span><br><span class="line">    cout &lt;&lt; &quot;sl:&quot; &lt;&lt; b.return_sl_QYLB() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;find 6:&quot; &lt;&lt; b.findbyvalue_QYLB((Xjd *)&amp;a[6], compare) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="单向循环链表"><a href="#单向循环链表" class="headerlink" title="单向循环链表"></a>单向循环链表</h2><h3 id="单向循环链表的基础知识"><a href="#单向循环链表的基础知识" class="headerlink" title="单向循环链表的基础知识"></a>单向循环链表的基础知识</h3><p>单向循环链表的理解</p>
<blockquote>
<p>单向循环链表与单链表仅仅有尾部node指针域指向不同的差别，对于单向链表尾部node由于没有后续node，其指针域需指向NULL。而单向循环链表将尾部node的指针域指向头部node，首尾相连构成单向循环链表</p>
</blockquote>
<p>单向循环链表图示</p>
<blockquote>
<p><img src="/blog/fujian/730c32579979bb72ce1985db219c9ff2.png"></p>
</blockquote>
<p>单向循环链表数据节点的构建思路</p>
<blockquote>
<p>数据<br>变量data：用模板参数来定义的变量，用来存储各种类型数据<br>指针next：存储下个数据节点的地址</p>
</blockquote>
<p>单链表的构建思路</p>
<blockquote>
<p>[[循环链表的构建思路.mp4]]</p>
<p>数据<br>头指针head：指向头节点的指针。<br>变量Sl：表示当前表格里元素的数量</p>
</blockquote>
<h3 id="单向循环链表的实现"><a href="#单向循环链表的实现" class="headerlink" title="单向循环链表的实现"></a>单向循环链表的实现</h3><p>接口文件DXHBLB.h</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">//数据节点</span><br><span class="line">struct Sjjd</span><br><span class="line">&#123;</span><br><span class="line">    //用来存储下一个数据节点的地址</span><br><span class="line">    Sjjd&lt;T&gt; *next;</span><br><span class="line">    //存储数据</span><br><span class="line">    T data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">class DXXHLB</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    //头结点，用来存储数据</span><br><span class="line">    Sjjd&lt;T&gt; *head;</span><br><span class="line">    //数量，表示当前容器的元素数量</span><br><span class="line">    int sl;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    //链表的初始化函数，用来初始化你的链表</span><br><span class="line">    DXXHLB();</span><br><span class="line">    //插入函数，指定表格的位置，插入你的数值。pos是你指定的位置，value是你要插入的值，既你要把数据插入到第pos-1的结点的后面，如果pos为1，就是要把数据插入到头结点的后面。插入成功返回true，否则返回false；</span><br><span class="line">    bool insert_DXXHLB(int pos, T value);</span><br><span class="line"></span><br><span class="line">    //位置删除函数，根据传入的位置，在顺序表中删除该位置的值。pos是传入的位置。成功则返回true，否则返回false</span><br><span class="line">    bool removebypos_DXXHLB(int pos);</span><br><span class="line"></span><br><span class="line">    //值删除函数，根据传入的值，在顺序表中删除有该值的第一个结点。value是传入要删除的值。成功则返回true，否则返回false</span><br><span class="line">    bool removebyvalue_DXXHLB(T value);</span><br><span class="line"></span><br><span class="line">    //返回数量函数，返回当前链表存储的元素的数量。</span><br><span class="line">    int return_sl_DXXHLB();</span><br><span class="line"></span><br><span class="line">    //位置查找函数，根据传入的位置，查找该位置的数据。pos是传入的位置。</span><br><span class="line">    T findbypos_DXXHLB(int pos);</span><br><span class="line"></span><br><span class="line">    //打印函数，按顺序打印你的单链表的数据。</span><br><span class="line">    bool print_DXXHLB();</span><br><span class="line"></span><br><span class="line">    //输出约瑟夫序列函数，解决约瑟夫问题，输出约瑟夫所需要的序列</span><br><span class="line">    void prinysf_DXXHLB(int m);</span><br><span class="line">    //析构函数，释放你的链表</span><br><span class="line">    ~DXXHLB();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>实现文件DXXHLB.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;DXXHLB.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line">//链表的初始化函数，用来初始化你的链表</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">DXXHLB&lt;T&gt;::DXXHLB()</span><br><span class="line">&#123;</span><br><span class="line">    //创建一个链表的头结点。</span><br><span class="line">    head = new Sjjd&lt;T&gt;;</span><br><span class="line"></span><br><span class="line">    //将头结点的后继指针，指向自己</span><br><span class="line">    head-&gt;next = head;</span><br><span class="line"></span><br><span class="line">    //更新sl</span><br><span class="line">    sl = 0;</span><br><span class="line">&#125;</span><br><span class="line">//插入函数，指定表格的位置，插入你的数值。pos是你指定的位置，value是你要插入的值，既你要把数据插入到第pos-1的结点的后面，如果pos为1，就是要把数据插入到头结点的后面。插入成功返回true，否则返回false；</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">bool DXXHLB&lt;T&gt;::insert_DXXHLB(int pos, T value)</span><br><span class="line">&#123;</span><br><span class="line">    //插入的位置非法则返回空。且我们设定当链表元素数量为n的时候，我们可以把值插入到n+1的位置里。</span><br><span class="line">    if (pos &lt;= 0 || pos &gt; sl + 1)</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    //插入位置合法，则进行插入</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //创建新的结点，来存储传入的数据</span><br><span class="line">        Sjjd&lt;T&gt; *newnode = new Sjjd&lt;T&gt;;</span><br><span class="line">        newnode-&gt;data = value;</span><br><span class="line"></span><br><span class="line">        //创建一个指针，用来存储后面我们找到pos-1的位置的节点。里面先暂时存储第0个位置的节点，也就是头结点的位置。</span><br><span class="line">        Sjjd&lt;T&gt; *jd = head;</span><br><span class="line"></span><br><span class="line">        //找到第pos-1的位置的节点，把这个节点的位置存储到jd。如果pos-1=0，就不用找，因为jd已经存储第0个节点的位置。</span><br><span class="line">        for (int i = 1; i &lt; pos; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            jd = jd-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        //把要插入的节点插入表格里面去</span><br><span class="line">        newnode-&gt;next = jd-&gt;next;</span><br><span class="line">        jd-&gt;next = newnode;</span><br><span class="line"></span><br><span class="line">        //更新sl</span><br><span class="line">        ++sl;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//位置删除函数，根据传入的位置，在顺序表中删除该位置的值。pos是传入的位置。成功则返回true，否则返回false</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">bool DXXHLB&lt;T&gt;::removebypos_DXXHLB(int pos)</span><br><span class="line">&#123;</span><br><span class="line">    //如果表为空，或者删除的位置非法，则返回false</span><br><span class="line">    if (sl == 0 || (pos &lt;= 0 || pos &gt; sl))</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //表不为空，且删除的位置合法</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //创建一个指针，用来存储后面我们找到pos-1的位置的节点。里面先暂时存储第0个位置的节点，也就是头结点的位置。</span><br><span class="line">        Sjjd&lt;T&gt; *jd = head;</span><br><span class="line">        //找到第pos-1的位置的节点，把这个节点的位置存储到xjd。如果pos-1=0，就不用找，因为jd已经存储第0个节点的位置。</span><br><span class="line">        for (int i = 1; i &lt; pos; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            jd = jd-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        //创建一个指针，用来存储删除的节点，也就是pos位置的节点</span><br><span class="line">        Sjjd&lt;T&gt; *deletejd = new Sjjd&lt;T&gt;;</span><br><span class="line">        deletejd = jd-&gt;next;</span><br><span class="line">        //将要删除节点的从表里踢出去</span><br><span class="line">        jd-&gt;next = jd-&gt;next-&gt;next;</span><br><span class="line">        //释放要删除的节点</span><br><span class="line">        delete deletejd;</span><br><span class="line"></span><br><span class="line">        //更新sl</span><br><span class="line">        --sl;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">//值删除函数，根据传入的值，在顺序表中删除有该值的第一个结点。value是传入要删除的值。成功则返回true，否则返回false</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">bool DXXHLB&lt;T&gt;::removebyvalue_DXXHLB(T value)</span><br><span class="line">&#123;</span><br><span class="line">    //如果表为空，则返回false</span><br><span class="line">    if (sl == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //创建一个指针，用来存储后面我们遍历表的节点，当找到我们要删除的结点的时候，把jd删除。里面先暂时存储第0个位置的节点，也就是头结点。</span><br><span class="line">        Sjjd&lt;T&gt; *jd = head;</span><br><span class="line">        //创建一个指针，先让其存储当前的jd，然后jd就可以存储下一个结点的地址。也就是让lastjd作为jd的上一个结点。的这样删除jd的时候就会很方便。</span><br><span class="line">        Sjjd&lt;T&gt; *lastjd;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;= sl; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            // lastjd存储当前的jd</span><br><span class="line">            lastjd = jd;</span><br><span class="line">            // jd存储下一个结点的地址</span><br><span class="line">            jd = jd-&gt;next;</span><br><span class="line">            if (jd-&gt;data == value)</span><br><span class="line">            &#123;</span><br><span class="line">                //让lastjd结点的后继指针指向，要删除的jd结点的下一个结点。</span><br><span class="line">                lastjd-&gt;next = jd-&gt;next;</span><br><span class="line"></span><br><span class="line">                //删除jd</span><br><span class="line">                delete jd;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//返回数量函数，返回当前链表存储的元素的数量。</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">int DXXHLB&lt;T&gt;::return_sl_DXXHLB()</span><br><span class="line">&#123;</span><br><span class="line">    return sl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//位置查找函数，根据传入的位置，查找该位置的数据。pos是传入的位置。</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">T DXXHLB&lt;T&gt;::findbypos_DXXHLB(int pos)</span><br><span class="line">&#123;</span><br><span class="line">    //如果表为空，或查找的位置非法，则执行终止函数</span><br><span class="line">    if (sl == 0 || (pos &lt;= 0 || pos &gt; sl))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;操作错误&quot; &lt;&lt; endl;</span><br><span class="line">        //非正常退出程序函数</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    //查找位置合法</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //创建一个指针，用来存储后面我们找到pos的位置的节点。里面先暂时存储第0个位置的节点，也就是头结点的位置。</span><br><span class="line">        Sjjd&lt;T&gt; *jd = head;</span><br><span class="line">        //找到第pos的位置的节点，把这个节点的位置存储到jd。</span><br><span class="line">        for (int i = 1; i &lt;= pos; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            jd = jd-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        //返回寻找到的值</span><br><span class="line">        return jd-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//打印函数，按顺序打印你的单链表的数据。</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">bool DXXHLB&lt;T&gt;::print_DXXHLB()</span><br><span class="line">&#123;</span><br><span class="line">    //如果表为空，则返回false</span><br><span class="line">    if (sl == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //表不为空，按顺序遍历表格</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //创建一个指针，用来指向表格中的节点，里面先暂时指向头结点</span><br><span class="line">        Sjjd&lt;T&gt; *jd = head;</span><br><span class="line">        //遍历表</span><br><span class="line">        for (int i = 1; i &lt;= sl; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            jd = jd-&gt;next;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; &quot;:&quot; &lt;&lt; jd-&gt;data &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出约瑟夫序列函数，解决约瑟夫问题，输出约瑟夫所需要的序列</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void DXXHLB&lt;T&gt;::prinysf_DXXHLB(int m)</span><br><span class="line">&#123;</span><br><span class="line">     //创建一个指针，用来指向表格中的节点，里面先暂时指向头结点</span><br><span class="line">    Sjjd&lt;T&gt; *jd = head;</span><br><span class="line">    //index表示jd节点在表格中位置。其表示方法，是到第m个节点的时候index为m，但是下一个节点开始，index会重置为1，然后又到第m+1个节点又重置为1。头结点跳过。</span><br><span class="line">    int index = 0;</span><br><span class="line"></span><br><span class="line">    //当表格只剩下一个结点的时候会跳出循环</span><br><span class="line">    while (sl &gt; 1)</span><br><span class="line">    &#123;</span><br><span class="line">        //jd存储下一个节点的位置</span><br><span class="line">        jd = jd-&gt;next;</span><br><span class="line">        //如果jd是头结点，则跳过头结点</span><br><span class="line">        if (jd == head)</span><br><span class="line">        &#123;</span><br><span class="line">            jd = jd-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        //更新index</span><br><span class="line">        ++index;</span><br><span class="line"></span><br><span class="line">        if (index == m)</span><br><span class="line">        &#123;</span><br><span class="line">            //输出第m个结点的数据</span><br><span class="line">            cout &lt;&lt; jd-&gt;data &lt;&lt; &quot; &quot;;</span><br><span class="line"></span><br><span class="line">            //存储要删除的结点的数据</span><br><span class="line">            T deletedata = jd-&gt;data;</span><br><span class="line">            //jd存储下一个结点的地址</span><br><span class="line">            jd = jd-&gt;next;</span><br><span class="line">            //跳过头结点</span><br><span class="line">            if (jd == head)</span><br><span class="line">            &#123;</span><br><span class="line">                jd = jd-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            //用值删除函数，删除刚刚输出的结点</span><br><span class="line">            removebyvalue_DXXHLB(deletedata);</span><br><span class="line">            //更新sl和index</span><br><span class="line">            --sl;</span><br><span class="line">            index = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//输出表格剩下的一个结点</span><br><span class="line">    cout &lt;&lt; head-&gt;next-&gt;data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//析构函数，释放你的链表</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">DXXHLB&lt;T&gt;::~DXXHLB()</span><br><span class="line">&#123;</span><br><span class="line">    //创建一个指针，用来指向表格中的节点，里面先暂时指向头结点</span><br><span class="line">    Sjjd&lt;T&gt; *p = head;</span><br><span class="line">    //注意，在单向循环链表里不能用while（P）判断链表是否为空，因为单向循环链表是头尾循环相连接的。</span><br><span class="line">    //当删除到最后一个结点的时候，p会指向原来头结点地址。而头结点最开已经始释放掉了，而p却仍然存储原来存储头结点的空间地址，</span><br><span class="line">    //所以P指向的不是NULL，而是未知的，这样程序就不会中断。</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt;= sl; i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        //缓存当前的地址</span><br><span class="line">        Sjjd&lt;T&gt; *deletejd = p;</span><br><span class="line">        //让p存储下一个节点的地址,如果i==sl，说明p已经是要删除的最后一个结点了，就不需要让P存储下一个结点地址了</span><br><span class="line">        if (i != sl)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //释放缓存的的地址</span><br><span class="line">        delete deletejd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试文件Test.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;DXXHLB.h&quot;</span><br><span class="line">#include &quot;DXXHLB.cpp&quot;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    DXXHLB&lt;int&gt; a;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= 10; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a.insert_DXXHLB(i, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;sl==&quot; &lt;&lt; a.return_sl_DXXHLB() &lt;&lt; endl;</span><br><span class="line">    a.removebypos_DXXHLB(5);</span><br><span class="line">    //打印函数</span><br><span class="line">    a.print_DXXHLB();</span><br><span class="line">    cout &lt;&lt; &quot;第五个为&quot; &lt;&lt; a.findbypos_DXXHLB(5) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="栈的基础知识"><a href="#栈的基础知识" class="headerlink" title="栈的基础知识"></a>栈的基础知识</h2><p>栈的理解</p>
<blockquote>
<p>栈也是线性表的一种，只不过栈是一种特殊的，受限的线性表。栈是只能在一端进行插入或删除的线性表。允许插入、删除、出去的一端称为栈顶，另一端称为栈底，当栈中没有元素时称为空栈。</p>
</blockquote>
<p>栈的性质</p>
<blockquote>
<p>后进先出</p>
<p>不支持随机访问和遍历<br>由于栈的操作规则是只允许在栈顶进行插入和删除操作，因此对于栈而言，不支持随机访问和遍历操作。<br>如果要遍历所有元素，需要把栈内数据全部拿出访问，这样的话就会改变栈内的数据，这种行为对栈来讲是不被允许的</p>
</blockquote>
<p>栈的举例说明</p>
<blockquote>
<p><img src="/blog/fujian/51244e751696e944507dec6098cc4506.png"><br>栈中有3个元素，进栈的顺序是a、b、c，当需要出栈时其顺序为c、b、a。</p>
</blockquote>
<p>栈的主要操作</p>
<blockquote>
<p>栈有插入和删除两个主要的操作。栈的插入操作常称为入栈（压栈)，栈的删除操作常称为出栈（弹栈)。</p>
</blockquote>
<p>栈的结构</p>
<blockquote>
<p>栈是一种线性表，其逻辑结构为线性结构。栈的物理结构有两种，而根据其实现的物理结构的不同，有两种实现方式。当栈是用顺序存储结构实现，元素连续的的存储在计算机存储器中，栈就叫顺序栈。当栈是用链式存储结构，其元素不一定是连续的存储在计算机存储器中 ，这时候栈就叫链栈</p>
</blockquote>
<h2 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h2><h3 id="顺序栈的基础知识"><a href="#顺序栈的基础知识" class="headerlink" title="顺序栈的基础知识"></a>顺序栈的基础知识</h3><p>顺序栈的理解</p>
<blockquote>
<p>顺序栈是指利用顺序存储结构实现的栈，即在计算机中，会用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，同时附设指针top指示栈顶元素在顺序栈中的位置。</p>
</blockquote>
<p>顺序栈的构建思路</p>
<blockquote>
<p>数据<br>数组data：存储数据。一般是数组。一般我们构建的线性表，存储数据的数组，我们一般是把数组尾作为栈顶，数组头作为栈底。也就是只在尾进行插入、删除、取出。<br>指针top：指向栈顶元素在顺序栈中的位置。<br><img src="/blog/fujian/f682328747d37894813e7a27fc1314cd.png"></p>
<p>变量sl：用来表示栈内所存储的元素数量</p>
</blockquote>
<h3 id="顺序栈的实现"><a href="#顺序栈的实现" class="headerlink" title="顺序栈的实现"></a>顺序栈的实现</h3><p> 接口文件SXZ.h </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">template &lt;class T, int Max = 1024&gt;</span><br><span class="line">class SXZ</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    T data[Max];</span><br><span class="line">    int sl;</span><br><span class="line">    int top;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    //构造函数，初始化栈表</span><br><span class="line">    SXZ();</span><br><span class="line"></span><br><span class="line">    //入栈函数，value是传入的数据，将value压入栈</span><br><span class="line">    bool Push_SXZ(T value);</span><br><span class="line"></span><br><span class="line">    //出栈函数，将栈顶元素压出栈</span><br><span class="line">    bool Pop_SXZ();</span><br><span class="line">    //返回栈顶函数,返回栈顶的元素</span><br><span class="line">    T Return_Top_SXZ();</span><br><span class="line"></span><br><span class="line">    //返回数量函数，返回栈表存储元素数量</span><br><span class="line">    int Return_Sl_SXZ();</span><br><span class="line"></span><br><span class="line">    //判断是否为空函数，用来判断栈表是否为空，是返回true，否则返回false</span><br><span class="line">    bool Is_Empty_SXZ();</span><br><span class="line"></span><br><span class="line">    //清空函数，清空栈表的元素</span><br><span class="line">    bool Clear_SXZ();</span><br><span class="line"></span><br><span class="line">    //析构函数，释放栈表</span><br><span class="line">    ~SXZ();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实现文件SXZ.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;SXZ.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//构造函数，初始化栈表</span><br><span class="line">template &lt;class T, int Max&gt;</span><br><span class="line">SXZ&lt;T, Max&gt;::SXZ()</span><br><span class="line">&#123;</span><br><span class="line">    //更新top指针</span><br><span class="line">    top = -1;</span><br><span class="line">    //更新数量</span><br><span class="line">    sl = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//入栈函数，value是传入的数据，将value压入栈</span><br><span class="line">template &lt;class T, int Max&gt;</span><br><span class="line">bool SXZ&lt;T, Max&gt;::Push_SXZ(T value)</span><br><span class="line">&#123;</span><br><span class="line">    //当表已满，无法在进行入栈</span><br><span class="line">    if (sl == Max)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //表未满，还可以入栈</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //更新top指针</span><br><span class="line">        ++top;</span><br><span class="line">        //将数据存储进栈</span><br><span class="line">        data[top] = value;</span><br><span class="line">        //更新sl</span><br><span class="line">        ++sl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">template &lt;class T, int Max&gt;</span><br><span class="line">//出栈函数，将栈顶元素压出栈</span><br><span class="line">bool SXZ&lt;T, Max&gt;::Pop_SXZ()</span><br><span class="line">&#123;</span><br><span class="line">    //当表为空</span><br><span class="line">    if (sl == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;栈为空，无法返回栈顶&quot;;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //栈不为空</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        //直接让指向栈顶元素的指针top减一，就等于删除了栈顶元素。因为top是指向栈顶的元素，当top不在指向原来的栈顶，那个栈顶就等于被删除。在有数据入栈的话，原栈顶也会被覆盖。</span><br><span class="line">        --top;</span><br><span class="line"></span><br><span class="line">        //更新sl</span><br><span class="line">        --sl;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//返回栈顶函数,返回栈顶的元素</span><br><span class="line">template &lt;class T, int Max&gt;</span><br><span class="line">T SXZ&lt;T, Max&gt;::Return_Top_SXZ()</span><br><span class="line">&#123;</span><br><span class="line">    //当表为空</span><br><span class="line">    if (sl == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;栈为空，无法返回栈顶&quot;;</span><br><span class="line"></span><br><span class="line">        //退出函数</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    //表不为空，则取出栈顶元素</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return data[top];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//返回数量函数，返回栈表存储元素数量</span><br><span class="line">template &lt;class T, int Max&gt;</span><br><span class="line">int SXZ&lt;T, Max&gt;::Return_Sl_SXZ()</span><br><span class="line">&#123;</span><br><span class="line">    return sl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//判断是否为空函数，用来判断栈表是否为空，是返回true，否则返回false</span><br><span class="line">template &lt;class T, int Max&gt;</span><br><span class="line">bool SXZ&lt;T,Max&gt;::Is_Empty_SXZ()</span><br><span class="line">&#123;</span><br><span class="line">    if(sl==0)</span><br><span class="line">    return true;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">//清空函数，清空栈表的元素</span><br><span class="line">template &lt;class T,int Max&gt;</span><br><span class="line">bool SXZ&lt;T,Max&gt;::Clear_SXZ()</span><br><span class="line">&#123;</span><br><span class="line">    //直接把top指向-1，sl更新为0</span><br><span class="line">  sl=0;</span><br><span class="line">  top=-1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//析构函数，释放栈表</span><br><span class="line">template &lt;class T, int Max&gt;</span><br><span class="line">SXZ&lt;T,Max&gt;::~SXZ()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试文件Test.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&quot;SXZ.h&quot;</span><br><span class="line">#include&quot;SXZ.cpp&quot;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    SXZ&lt;int,20&gt; a;</span><br><span class="line">    for(int i=1;i&lt;=10;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a.Push_SXZ(i);</span><br><span class="line">    &#125;</span><br><span class="line">    a.Pop_SXZ();</span><br><span class="line">    cout&lt;&lt;&quot;栈顶元素为&quot;&lt;&lt;a.Return_Top_SXZ()&lt;&lt;endl;</span><br><span class="line">    a.Clear_SXZ();</span><br><span class="line">    cout&lt;&lt;&quot;sl:&quot;&lt;&lt;a.Return_Sl_SXZ()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h2><h3 id="链栈的基础知识"><a href="#链栈的基础知识" class="headerlink" title="链栈的基础知识"></a>链栈的基础知识</h3><p> 链栈的理解</p>
<blockquote>
<p>链栈是指利用链式存储结构实现的栈，即在计算机中，会用一组地址并不一定连续的存储单元依次存放自栈底到栈顶的数据元素，同时附设指针top指针指向栈顶元素。</p>
</blockquote>
<p>链栈的数据节点构建思路</p>
<blockquote>
<p>数据<br>变量data：存储数据<br>指针next：指向下一个数据节点的指针</p>
</blockquote>
<p> 链栈的构建思路</p>
<blockquote>
<p>链栈表的图示<br><img src="/blog/fujian/73c412dfbe9537c86a4447cb3986b066.png"></p>
<p>链栈的数据<br>头指针:指向链栈的头节点。链栈可有头节点，也可以没有头节点。如果链栈不设头节点，则也就不设头指针。<br>指针top：用来指向栈顶数据节点。在由数据结点构建的链表中，为方便操作，一般是表头作为栈顶，表尾作为栈底，如上图，与顺序栈相反。</p>
</blockquote>
<h3 id="链栈的实现"><a href="#链栈的实现" class="headerlink" title="链栈的实现"></a>链栈的实现</h3><p>接口文件LZ.h</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">struct Sjjd</span><br><span class="line">&#123;</span><br><span class="line">    Sjjd&lt;T&gt; *next;</span><br><span class="line">    T data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">class LZ</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">//指向栈顶元素的指针</span><br><span class="line">    Sjjd&lt;T&gt; *top;</span><br><span class="line">    //数量，表示当前容器的元素数量。</span><br><span class="line">    int sl;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    //构造函数，初始化栈表</span><br><span class="line">    LZ(/* args */);</span><br><span class="line"></span><br><span class="line">    //入栈函数，value是传入的数据，将value压入栈</span><br><span class="line">    bool Push_LZ(T value);</span><br><span class="line"></span><br><span class="line">    //出栈函数，将栈顶元素压出栈</span><br><span class="line">    bool Pop_LZ();</span><br><span class="line"></span><br><span class="line">    //返回栈顶函数,返回栈顶的元素</span><br><span class="line">    T Return_Top_LZ();</span><br><span class="line"></span><br><span class="line">    //判断是否为空函数，用来判断栈表是否为空，是返回true，否则返回false</span><br><span class="line">    bool Is_Empty_LZ();</span><br><span class="line">    //析构函数，释放栈表</span><br><span class="line">    ~LZ();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实现文件LZ.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;LZ.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//构造函数，初始化栈表</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">LZ&lt;T&gt;::LZ(/* args */)</span><br><span class="line">&#123;</span><br><span class="line">    // top是指向栈顶元素的指针，初始化时无入栈，因此赋null</span><br><span class="line">    top = NULL;</span><br><span class="line">    //更新sl</span><br><span class="line">    sl = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//入栈函数，value是传入的数据，将value压入栈</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">bool LZ&lt;T&gt;::Push_LZ(T value)</span><br><span class="line">&#123; //创建一个结点用来存储传入的数据value</span><br><span class="line">    Sjjd&lt;T&gt; *jd = new Sjjd&lt;T&gt;;</span><br><span class="line">    jd-&gt;data = value;</span><br><span class="line"></span><br><span class="line">    //把要入栈的数据节点，将其后继指针指向当前的栈顶元素</span><br><span class="line">    jd-&gt;next = top;</span><br><span class="line">    // top指向刚刚存入的栈顶元素</span><br><span class="line">    top = jd;</span><br><span class="line">    //更新sl</span><br><span class="line">    ++sl;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">//出栈函数，将栈顶元素压出栈</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">bool LZ&lt;T&gt;::Pop_LZ()</span><br><span class="line">&#123;</span><br><span class="line">    //栈表为空，无法出栈</span><br><span class="line">    if (sl == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //栈表不为空</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //创建一个jd，来存储栈顶元素</span><br><span class="line">        Sjjd&lt;T&gt; *jd = top;</span><br><span class="line">        //让top指针，指向下一个元素。</span><br><span class="line">        top = top-&gt;next;</span><br><span class="line">        //删除jd</span><br><span class="line">        delete jd;</span><br><span class="line"></span><br><span class="line">        //更新sl</span><br><span class="line">        --sl;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//返回栈顶函数,返回栈顶的元素</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">T LZ&lt;T&gt;::Return_Top_LZ()</span><br><span class="line">&#123;</span><br><span class="line">    //栈表为空，无法出栈</span><br><span class="line">    if (sl == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;表为空，无法返回栈顶元素&quot; &lt;&lt; endl;</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //返回栈顶数据节点存储的数据</span><br><span class="line">        return top-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//判断是否为空函数，用来判断栈表是否为空，是返回true，否则返回false</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">bool LZ&lt;T&gt;::Is_Empty_LZ()</span><br><span class="line">&#123;</span><br><span class="line">    if (sl == 0)</span><br><span class="line">        return true;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">//析构函数，释放栈表</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">LZ&lt;T&gt;::~LZ()</span><br><span class="line">&#123;</span><br><span class="line">    //创建结点jd,用来缓存栈表的元素，里面暂存栈顶元素</span><br><span class="line">    Sjjd&lt;T&gt; *jd = top;</span><br><span class="line">    while (jd)</span><br><span class="line">    &#123;</span><br><span class="line">        //创建lastjd，缓存当前要删除的结点，</span><br><span class="line">        Sjjd&lt;T&gt; *lastjd = jd;</span><br><span class="line">        // jd缓存下个结点地址</span><br><span class="line">        jd = jd-&gt;next;</span><br><span class="line"></span><br><span class="line">        //删除lastjd</span><br><span class="line">        delete lastjd;</span><br><span class="line">    &#125;</span><br><span class="line">    top = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试文件Test.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;LZ.h&quot;</span><br><span class="line">#include &quot;LZ.cpp&quot;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    LZ&lt;int&gt; a;</span><br><span class="line">    for (int i = 1; i &lt;= 10; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a.Push_LZ(i);</span><br><span class="line">    &#125;</span><br><span class="line">    a.Pop_LZ();</span><br><span class="line">    cout &lt;&lt; &quot;栈顶元素为&quot; &lt;&lt; a.Return_Top_LZ() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    if (a.Is_Empty_LZ())</span><br><span class="line">        cout &lt;&lt; &quot;表为空&quot; &lt;&lt; endl;</span><br><span class="line">    else</span><br><span class="line">        cout &lt;&lt; &quot;表不为空&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="队列的基础知识"><a href="#队列的基础知识" class="headerlink" title="队列的基础知识"></a>队列的基础知识</h2><p>队列的理解</p>
<blockquote>
<p>队列也是线性表的一种，只不过队列是一种特殊的，受限的线性表。<br>队列是一种在一端进行插人，而在另一端进行删除的线性表。允许插入的一端称为队尾，允许删除的一端称为队头。<br>队列的插入操作常称为入队，队列的删除操作常称为出队。</p>
</blockquote>
<p>队列的性质</p>
<blockquote>
<p>先进先出 ( First In First Out，FIFO)，即出队元素只能是位于队头的元素，而入队元素也只能放在队尾位置。</p>
</blockquote>
<p>队列的举例</p>
<blockquote>
<p><img src="/blog/fujian/574ecccfdb11dcf095b1550ca4af979c.png"><br>下图所示为有5个元素的队列。入队的顺序依次为a1、a2、a3、a4、a5，出队时的顺序将依然是a1、a2、a3 、a4、a5</p>
</blockquote>
<p>队列的结构</p>
<blockquote>
<p>队列是一种特殊的线性表，其逻辑结构仍为线性结构。队列的物理结构有两种，而根据其实现的物理结构的不同，有两种实现方式。当队列是用顺序存储结构实现，元素连续的的存储在计算机存储器中，队列就叫顺序队列。当队列是用链式存储结构，其元素不一定是连续的存储在计算机存储器中 ，这时候队列就叫链队</p>
</blockquote>
<h2 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h2><h3 id="顺序队列的基础知识"><a href="#顺序队列的基础知识" class="headerlink" title="顺序队列的基础知识"></a>顺序队列的基础知识</h3><p>顺序队列的理解</p>
<blockquote>
<p>顺序队列是指利用顺序存储结构实现的队列，即利用一组连续的存储单元依次存放自队头到对尾的数据元素。</p>
</blockquote>
<p>假溢出问题</p>
<blockquote>
<p>最开始队空，我们将数组下标0端设为队头，然后最开始将front（队头元素前一个位置的下标标记）,和rear（队尾下标标记都）设为-1。<br>假设入队操作时，可以先使队尾下标标记移一个位置，rear &#x3D; rear+1，然后向rear所指向的位置写入新元素;出队操作时，将数据出队后，将front往后移一个位置，即front &#x3D; front +1。操作如下图<br><img src="/blog/fujian/f3d4972827461aac38d8a64dac07492f.png"><br>从图3-7中可以看出,如果还有元素需要入队,就会出现假上溢现象。</p>
</blockquote>
<p>假溢出问题的解决</p>
<blockquote>
<p>我们将数组下标0端设为队头，然后最开始将front,和rear和设为-1。<br>入队和出队操作中front和rear不是直接加1，而是采用加1取模的方式。入队操作时<code>rear = (rear +1)% MaxSize</code>，出队操作时<code>front = ( front +1) % MaxSize</code>（maxsize为数组长度）</p>
</blockquote>
<p>歧义问题</p>
<blockquote>
<p><img src="/blog/fujian/fd9497b3c152363c2e3ebc69216bdddf.png"><br>当入队操作和出队操作采用取模的方式，那么会如上图的C和D所示，由于队列为空和为满的条件均为front &#x3D;&#x3D; rear，会产生歧义。</p>
</blockquote>
<p>歧义的解决</p>
<blockquote>
<p>方法1：浪费一个元素空间。将图上（c）所示的情况视为队满，此时的状态是队尾指针加1就会从后面赶上队头指针。在这种情况下，队满的条件是( rear + 1 ) % MaxSize &#x3D;&#x3D; front，这样就能与空队区别开。</p>
<p>方法2：设置一个辅助标志变量flag。例如，当front &#x3D;&#x3D; rear且flag &#x3D;&#x3D; false时(此时刚有元素出队列）表示队空;当front &#x3D;&#x3D; rear 且 flag &#x3D;&#x3D; true时(此时刚有元素进队列)表示队满。请读者思考仅用标志变量flag 如何判断队列状态。</p>
<p>方法3使用一个计数器记录队列中元素的个数。附设一个存储队中元素个数的变量如num当num &#x3D;&#x3D;0时表示队空，当num &#x3D;&#x3D; MaxSize时表示队满。</p>
</blockquote>
<p>顺序队列的构建思路</p>
<blockquote>
<p>数据<br>数组data：存储队列中的元素，数组头做队头或者队尾都可以（这里我们用数组头做队头，数组尾做队尾）。<br>变量sl：用来表示队内所存储的元素数量<br>整形变量front：存放队头元素前一个位置的下标,开始时为-1（当队头指针和队尾指针初始化都是-1，如果队头指针是指向队头元素的下标，那么我们写入队操作的时候，多写一些代码进行判断）。<br>整形变量rear：存放队尾元素的下标</p>
</blockquote>
<h3 id="顺序队列的实现"><a href="#顺序队列的实现" class="headerlink" title="顺序队列的实现"></a>顺序队列的实现</h3><p>接口文件SXDL.h</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">template &lt;class T, int Max = 1024&gt;</span><br><span class="line">class SXDL</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    //数组，作为队列，用来存取数据</span><br><span class="line">    T Data[Max];</span><br><span class="line">    //数量，表示当前容器的元素数量。</span><br><span class="line">    int sl;</span><br><span class="line"></span><br><span class="line">    //队头变量，存放队头元素前一个位置的下标</span><br><span class="line">    int front;</span><br><span class="line"></span><br><span class="line">    //队尾变量,存放队尾元素的下标</span><br><span class="line">    int rear;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    //初始化函数，初始化顺序队列</span><br><span class="line">    SXDL();</span><br><span class="line"></span><br><span class="line">    //入队函数，value为传入的要入队的值，将value传入队列。</span><br><span class="line">    bool Push_SXDL(T value);</span><br><span class="line"></span><br><span class="line">    //出队函数，将队头元素出队，成功返回true，失败返回false</span><br><span class="line">    bool Pop_SXDL();</span><br><span class="line"></span><br><span class="line">    //返回队头元素函数，取队头元素。</span><br><span class="line">    T Return_dt_SXDL();</span><br><span class="line"></span><br><span class="line">    //返回数量函数，返回当前队列存储的元素的数量。</span><br><span class="line">    int Return_sl_SXDL();</span><br><span class="line"></span><br><span class="line">    //是否为空函数，判断队列元素是否为空，如果为空返回true，否则返回false;</span><br><span class="line">    bool Is_Empty_SXDL();</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实现文件SXDL.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;SXDL.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line">//初始化函数，初始化顺序队列</span><br><span class="line">template &lt;class T, int Max&gt;</span><br><span class="line">SXDL&lt;T, Max&gt;::SXDL()</span><br><span class="line">&#123;</span><br><span class="line">    //初始化front和rear，最开始将front,和rear和设为-1。</span><br><span class="line">    front = rear = -1;</span><br><span class="line">    //初始化sl</span><br><span class="line">    sl=0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//入队函数，value为传入的要入队的值，将value传入队列。</span><br><span class="line">template &lt;class T, int Max&gt;</span><br><span class="line">bool SXDL&lt;T, Max&gt;::Push_SXDL(T value)</span><br><span class="line">&#123;</span><br><span class="line">    //当表已满，无法在进行入队</span><br><span class="line">    if (sl == Max)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //表未满，可以入队</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //更新队尾变量，将队尾变量指向下一个新的未存储空间，用来存储新的队尾元素</span><br><span class="line">        rear = (rear + 1) % Max;</span><br><span class="line">        //将数据存储入队</span><br><span class="line">        Data[rear] = value;</span><br><span class="line">        //更新sl</span><br><span class="line">        ++sl;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//出队函数，将队头元素出队，成功返回true，失败返回false</span><br><span class="line">template &lt;class T, int Max&gt;</span><br><span class="line">bool SXDL&lt;T, Max&gt;::Pop_SXDL()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //当队是空的，无法在进行出队</span><br><span class="line">    if (sl == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //队不是空的，可以进行出队</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //将队头变量+1，指向新的队头元素的前一个位置的下标，这样就等于删除原来的队头元素，虽然该空间仍然有存储数据，但是可以当作空的存储空间</span><br><span class="line">        front = (front + 1) % Max;</span><br><span class="line">        //更新sl</span><br><span class="line">        --sl;</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//返回队头元素函数，取队头元素。</span><br><span class="line">template &lt;class T, int Max&gt;</span><br><span class="line">T SXDL&lt;T, Max&gt;::Return_dt_SXDL()</span><br><span class="line">&#123;</span><br><span class="line">    //当队是空的，无法在取出队头</span><br><span class="line">    if (sl == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;队是空的，无法取出队头元素&quot; &lt;&lt; endl;</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    //队不是空的，可以进行取出队头</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //根据队头变量返回队头元素</span><br><span class="line">        return Data[(front + 1) % Max];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//是否为空函数，判断队列元素是否为空，如果为空返回true，否则返回false;</span><br><span class="line">template &lt;class T, int Max&gt;</span><br><span class="line">bool SXDL&lt;T, Max&gt;::Is_Empty_SXDL()</span><br><span class="line">&#123;</span><br><span class="line">    if (sl == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//返回数量函数，返回当前队列存储的元素的数量。</span><br><span class="line">template &lt;class T, int Max&gt;</span><br><span class="line">int SXDL&lt;T, Max&gt;::Return_sl_SXDL()</span><br><span class="line">&#123;</span><br><span class="line">    return sl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试文件Test.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;SXDL.h&quot;</span><br><span class="line">#include &quot;SXDL.cpp&quot;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    SXDL&lt;int, 20&gt; a;</span><br><span class="line">    for (int i = 1; i &lt;= 10; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a.Push_SXDL(i);</span><br><span class="line">    &#125;</span><br><span class="line">    a.Pop_SXDL();</span><br><span class="line">    cout &lt;&lt; &quot;队头元素为&quot; &lt;&lt; a.Return_dt_SXDL() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;sl:&quot; &lt;&lt; a.Return_sl_SXDL() &lt;&lt; endl;</span><br><span class="line">    if (a.Is_Empty_SXDL() == false)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;表不空&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="链队列"><a href="#链队列" class="headerlink" title="链队列"></a>链队列</h2><h3 id="链队列的基础知识"><a href="#链队列的基础知识" class="headerlink" title="链队列的基础知识"></a>链队列的基础知识</h3><p>链队列的理解</p>
<blockquote>
<p>链队列是指利用链式存储结构实现的队列，即用一组并不一定连续的存储单依次存放自队头到队尾的数据元素。</p>
</blockquote>
<p>链队列图示</p>
<blockquote>
<p><img src="/blog/fujian/41a8e5026c8219a2acf130970be38e7f.png"></p>
</blockquote>
<p>链队列的数据节点构建思路</p>
<blockquote>
<p>数据<br>变量data：存储数据<br>指针next：指向下一个数据节点的指针</p>
</blockquote>
<p>链队列的构建思路</p>
<blockquote>
<p>数据<br>队头指针front：指向链表头结点，（队头元素的前一个结点）<br>队尾指针rear：开始指向链表头结点，后面指向队尾结点（队尾元素）<br>变量sl：用来表示队内所存储的元素数量</p>
</blockquote>
<h3 id="链队列的实现"><a href="#链队列的实现" class="headerlink" title="链队列的实现"></a>链队列的实现</h3><p>接口文件LDL.h</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">struct Sjjd</span><br><span class="line">&#123;</span><br><span class="line">    Sjjd&lt;T&gt; *next;</span><br><span class="line">    T Data;</span><br><span class="line">&#125;;</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">class LDL</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    //队头指针，指向头结点（队头元素的前一个结点）</span><br><span class="line">    Sjjd&lt;T&gt; *front;</span><br><span class="line"></span><br><span class="line">    //队尾指针，指向尾结点（队尾元素）</span><br><span class="line">    Sjjd&lt;T&gt; *rear;</span><br><span class="line"></span><br><span class="line">    //存储队列的元素数量</span><br><span class="line">    int sl;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    //初始化函数，初始化顺序队列</span><br><span class="line">    LDL();</span><br><span class="line"></span><br><span class="line">    //入队函数，value为传入的要入队的值，将value传入队列。</span><br><span class="line">    bool Push_LDL(T value);</span><br><span class="line"></span><br><span class="line">    //出队函数，将队头元素出队，成功返回true，失败返回false</span><br><span class="line">    bool Pop_LDL();</span><br><span class="line"></span><br><span class="line">    //返回队头元素函数，取队头元素。</span><br><span class="line">    T Return_dt_LDL();</span><br><span class="line"></span><br><span class="line">    //返回数量函数，返回当前队列存储的元素的数量。</span><br><span class="line">    int Return_sl_LDL();</span><br><span class="line"></span><br><span class="line">    //是否为空函数，判断队列元素是否为空，如果为空返回true，否则返回false;</span><br><span class="line">    bool Is_Empty_LDL();</span><br><span class="line"></span><br><span class="line">    //析构函数，释放队列</span><br><span class="line">    ~LDL();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>实现文件LDL.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;LDL.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line">//初始化函数，初始化顺序队列</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">LDL&lt;T&gt;::LDL()</span><br><span class="line">&#123;</span><br><span class="line">    //创建一个空的结点，用来当头结点</span><br><span class="line">    Sjjd&lt;T&gt; *jd = new Sjjd&lt;T&gt;;</span><br><span class="line">    //队头指针和队尾指针都指向头结点</span><br><span class="line">    front = rear = jd;</span><br><span class="line"></span><br><span class="line">    //更新sl</span><br><span class="line">sl = 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//入队函数，value为传入的要入队的值，将value传入队列。</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">bool LDL&lt;T&gt;::Push_LDL(T value)</span><br><span class="line">&#123;</span><br><span class="line">    //创建一个结点来存储传入的数据</span><br><span class="line">    Sjjd&lt;T&gt; *jd = new Sjjd&lt;T&gt;;</span><br><span class="line">    jd-&gt;Data = value;</span><br><span class="line">    jd-&gt;next = NULL;</span><br><span class="line">    //队尾的后继指针，指向新创建的元素节点</span><br><span class="line">    rear-&gt;next = jd;</span><br><span class="line"></span><br><span class="line">    //队尾指针指向新的队尾元素。</span><br><span class="line">    rear = jd;</span><br><span class="line"></span><br><span class="line">    //更新sl</span><br><span class="line">    ++sl;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//出队函数，将队头元素出队，成功返回true，失败返回false</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">bool LDL&lt;T&gt;::Pop_LDL()</span><br><span class="line">&#123;</span><br><span class="line">    //当队是空的，无法在进行出队</span><br><span class="line">    if (sl == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //队不是空的时候</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //创建一个新的节点用来存储队头元素</span><br><span class="line">        Sjjd&lt;T&gt; *jd = front-&gt;next;</span><br><span class="line"></span><br><span class="line">        //头结点的后继指针，指向新的队头元素</span><br><span class="line">        front-&gt;next = jd-&gt;next;</span><br><span class="line"></span><br><span class="line">        //删除原队头元素</span><br><span class="line">        delete front;</span><br><span class="line"></span><br><span class="line">        //更新sl</span><br><span class="line">        --sl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//返回队头元素函数，取队头元素。</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">T LDL&lt;T&gt;::Return_dt_LDL()</span><br><span class="line">&#123;</span><br><span class="line">    //当队是空的，无法在进行出队</span><br><span class="line">    if (sl == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;队为空，无法获取队头元素&quot; &lt;&lt; endl;</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    //队不空的时候</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //返回队头元素</span><br><span class="line">        return front-&gt;next-&gt;Data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//返回数量函数，返回当前队列存储的元素的数量。</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">int LDL&lt;T&gt;::Return_sl_LDL()</span><br><span class="line">&#123;</span><br><span class="line">    return sl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//是否为空函数，判断队列元素是否为空，如果为空返回true，否则返回false;</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">bool LDL&lt;T&gt;::Is_Empty_LDL()</span><br><span class="line">&#123;</span><br><span class="line">    if (sl == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//析构函数，释放队列</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">LDL&lt;T&gt;::~LDL()</span><br><span class="line">&#123;</span><br><span class="line">    //创建一个节点来存储队列的所有结点，里面暂存头结点</span><br><span class="line">    Sjjd&lt;T&gt; *jd = front;</span><br><span class="line"></span><br><span class="line">    while (jd)</span><br><span class="line">    &#123;</span><br><span class="line">        //用一个新的结点，来缓存当前的结点。然后让jd去去队列下一个元素节点</span><br><span class="line">        Sjjd&lt;T&gt; *lastjd = jd;</span><br><span class="line">        //让jd去去队列下一个元素节点</span><br><span class="line">        jd = jd-&gt;next;</span><br><span class="line">        //删除缓存的节点</span><br><span class="line">        delete lastjd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试文件Test.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;LDL.h&quot;</span><br><span class="line">#include &quot;LDL.cpp&quot;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    LDL&lt;int&gt; a;</span><br><span class="line">    for (int i = 1; i &lt;= 10; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a.Push_LDL(i);</span><br><span class="line">    &#125;</span><br><span class="line">    a.Pop_LDL();</span><br><span class="line">    cout &lt;&lt; &quot;队头元素为&quot; &lt;&lt; a.Return_dt_LDL() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;sl:&quot; &lt;&lt; a.Return_sl_LDL() &lt;&lt; endl;</span><br><span class="line">    if (a.Is_Empty_LDL() == false)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;表不空&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="树的基本知识"><a href="#树的基本知识" class="headerlink" title="树的基本知识"></a>树的基本知识</h2><p>树的理解</p>
<blockquote>
<p>树是由n个节点组成的集合。n＝0就是空树，n&gt;0的时候存在一个节点作为树的根节点，其他节点可以分为m个集合，每个集合本身又可以作为一个树</p>
</blockquote>
<p>树的图示</p>
<blockquote>
<p><img src="/blog/fujian/015a1d203e258bfa63a4eec2de67445c.png"></p>
</blockquote>
<p>树的结构</p>
<blockquote>
<p>树的逻辑结构就叫树结构，其数据结构中的元素存在一对多的相互关系。树的物理结构有两种，而根据其实现的物理结构的不同，有两种实现方式。当树是用顺序存储结构实现，元素连续的的存储在计算机存储器中，树就叫顺序树。当树是用链式存储结构，其元素不一定是连续的存储在计算机存储器中 ，这时候树就叫链树</p>
</blockquote>
<p>树的特点</p>
<blockquote>
<p>树的定义具有递归性，树中还有树。<br>树可以为空，即节点个数为0。</p>
</blockquote>
<p>有序树和无序树的区别</p>
<blockquote>
<p><strong>有序树是具有明确顺序关系的树结构，子节点之间按照某种规定的顺序排列。无序树是没有明确顺序关系的树结构，子节点之间没有明确顺序关系，可以任意排列。</strong></p>
<p>举例<br><img src="/blog/fujian/d83200c01d0aa242a658ff3616016f09.png"><br>在这个二叉搜索树中，每个节点的值都满足左孩子节点小于节点自身的值，右孩子节点值大于节点自身的值。这是具有明确顺序关系的树结构。这个有序性质使得我们能够快速地找到特定值的节点，例如，如果我们要查找值为6的节点，我们可以从根节点开始比较，因为6比根节点的值大，所以我们知道要在右子树中继续查找。然后，我们在右子树中找到了值为6的节点。</p>
<p><img src="/blog/fujian/6ddf824be84ecac02eeb0a84e93d1e32.png"><br>这是普通二叉树，没有明确顺序关系的树结构。们无法根据节点的值来确定节点的位置。</p>
</blockquote>
<p>树的相关定义说明</p>
<blockquote>
<p>以下面这个树图为例<br><img src="/blog/fujian/f46941e2ce29131358d119f1e3590667.png"></p>
<p>根节点<br>上图A点就是根节点</p>
<p>叶子节点<br>下面没有分叉的节点，如上图B、C、H、I、P、Q等节点</p>
<p>节点的层次<br>结点的层次（Level）从根开始定义，根为第一层，根的孩子为第二层，以此类推</p>
<p>树的深度<br>树中所有节点里，最深层的节点第是几层，树的深度就为几层，如上图 就4层</p>
<p>节点的度<br>就是节点下面分叉多少个节点，如上图节点E，下面分叉I、J,则E节点的 度为2</p>
<p>树的度<br>树有众多节点，某个节点的度是最大的，那么这个树的度就是这个节点的度。如上图的树，度最大的节点是F节点，度为3，则这个树的度就为3</p>
<p>孩子节点、父节点、兄弟节点<br>如上图E节点下分叉许I、J这两个节点，则E就为I、J的父节点，I、J就为E的子节点。而I和J是有同一个父节点，所以I和J就是兄弟节点</p>
<p>子树<br>上图所有节点整一个就是一个大树，而在这个树里，假设E、I、J、P、Q这五个节点组成一个集合，就是这个大树的子树</p>
</blockquote>
<h2 id="二叉树的基本知识"><a href="#二叉树的基本知识" class="headerlink" title="二叉树的基本知识"></a>二叉树的基本知识</h2><p>二叉树的理解</p>
<blockquote>
<p>树的所有的节点的度不超过2的树，就是二叉树，也就是说，二叉树每个节点最多有两个孩子节点，分别为左孩子节点和右孩子节点</p>
</blockquote>
<p>二叉树的图示</p>
<blockquote>
<p><img src="/blog/fujian/03b4cb85fb8aee37289bce186840f968.png"></p>
</blockquote>
<p>二叉树的结构</p>
<blockquote>
<p>二叉树的逻辑结构，是树结构中的一对二。二叉树物理结构有两种，而根据其实现的物理结构的不同，有两种实现方式。当二叉树的物理结构是采用顺序存储结构时，元素连续的的存储在计算机存储器中，此时的二叉树就是顺序二叉树。当二叉树是用链式存储结构，其元素不一定是连续的存储在计算机存储器中 ，这时候二叉树就叫链二叉树</p>
</blockquote>
<p>满二叉树的理解</p>
<blockquote>
<p>一个二叉树，每一层的节点数都达到最大值，那么这个二叉树就是满二叉树<br><img src="/blog/fujian/7347818b44bed6761195c3f9638c36ab.png"></p>
</blockquote>
<p>完全二叉树的理解</p>
<blockquote>
<p>一棵深度为k的有n个结点的二叉树（不一定是满二叉树），对树中的结点按从上至下、从左到右的顺序进行编号（这种编号方法，也叫完全二叉树编号方法），同时也对深度为k的满二叉树用同样的标准进行编号。这个二叉树所有有编号结点，其编号与满二叉树中对应节点编号相同则这棵二叉树称为完全二叉树。<br>完全二叉树是一种特殊的二叉树，它的特点是除了最后一层外，其他层的节点都是满的，而最后一层的节点尽量靠左排列。</p>
<p><img src="/blog/fujian/ab11e14f5552e6776c6275f106137ad5.png"></p>
</blockquote>
<p>二叉树的性质</p>
<blockquote>
<p>1.非空二叉树中,第i层最多有2^(i-1)个结点,其中i≥1。</p>
<p>2.高度为h的二叉树中结点总数最多为2^(h)-1。</p>
<p>3.设某二叉树中叶子结点数为n0，度为2的结点数为n2，则n0 &#x3D;n2,+1。（设某m叉树，度为i的结点数为ni;，则n0&#x3D;n2, +2n3+ …+(m - 1 )nm +1。）</p>
<p>4.<img src="/blog/fujian/7e19aa53b44ebaa03e5870f15f08da49.png"></p>
<p>5.<img src="/blog/fujian/27faa276f541fa844041b988671ee5c1.png"><br>注意，这个性质是二叉树编号是从1开始编的。</p>
</blockquote>
<h2 id="顺序二叉树"><a href="#顺序二叉树" class="headerlink" title="顺序二叉树"></a>顺序二叉树</h2><h3 id="顺序二叉树的基本知识"><a href="#顺序二叉树的基本知识" class="headerlink" title="顺序二叉树的基本知识"></a>顺序二叉树的基本知识</h3><p>顺序二叉树的理解</p>
<blockquote>
<p>二叉树表根据不同的物理结构，有两种实现方式，当二叉树的物理结构是采用顺序存储结构时，就叫顺序二叉树。此时内存中会用地址连续的一块存储空间顺序存二叉树的元素</p>
</blockquote>
<p>顺序二叉树的在数组存储方式</p>
<blockquote>
<p>首先创建一个数组，然后将二叉树进行完全二叉树编号（从0开始编号），然后根据二叉树中的元素的编号，存到存到对应下标的数组（此时元素的标号就是数组对应的下标），这就是顺序二叉树的存储方式，如下图<br><img src="/blog/fujian/5480cb73e46a6bf51df717c1dc029594.png"><br>上为二叉树的结构图，下为二叉树应用顺序存储方式存储在数组的数组结构图</p>
</blockquote>
<p>顺序二叉树里，父节点和左孩子节点编号的关系</p>
<blockquote>
<p>注意，这个性质是二叉树编号是从0开始编的。<br>父亲节点为i，则左孩子节点为2i+1,所以左孩子节点编号都为单数。<br>若左孩子节点编号为k,则父亲节点为（k-1）&#x2F;2</p>
</blockquote>
<p>顺序二叉树里，父节点和右孩子节点编号的关系</p>
<blockquote>
<p>父亲节点为i，则右孩子节点为2i＋2,所以左孩子节点编号都为双数。<br>若右孩子节点编号为k,则父亲节点为（k-2）&#x2F;2</p>
</blockquote>
<p>顺序二叉树的局限</p>
<blockquote>
<p>对于满二叉树、完全二叉树来说，顺序存储结构的存储效率是极高的，所有的空间仅仅用来存储数据元素的值，结点之间关系的存储未占用任何空间。</p>
<p><img src="/blog/fujian/aff50e186e5e12f7d0908d221736baef.png"><br>但是，对于一般二叉树而言，如何利用完全二叉树的编码规则来存储数据呢?解决的方法是补足不存在的结点，用特殊数据标识这些替补结点，使整棵树在形式上满足完全二叉树的定义。图7-11 （a）所示的不是完全二叉树。经过增补一些虚拟结点后，图7-11 (b）所示成为完全二叉树,其顺序存储结构如图7-11 (c)所示。虽然非完全二叉树采用顺序存储结构存在部分内存空间的浪费，但是如果空间浪费不多,能得到直接存取的优点，那么也是值得的。</p>
<p><img src="/blog/fujian/60cb5751d23315480cdaeb22f39c68f4.png"><br>对于那些单分支结点较多、高度变化较大的二叉树而言，顺序存储结构是不合适的。如图7-12（a）所示的二叉树每个结点只有右子树，为其增<br>补虚拟结点后如图7-12(b)所示。为了存储4个数据元素，需要占用15个存储空间，如图7-12 (c) 所示。若二叉树的高度更大，则空间浪费现象将更加惊人。因此，对于一般二叉树通常采用下一小节介绍的链式存储结构。</p>
<p>由于顺序二叉树的局限性，我们队二叉树的存储主要采用链式存储结构，顺序存储结构了解即可</p>
</blockquote>
<h2 id="链二叉树"><a href="#链二叉树" class="headerlink" title="链二叉树"></a>链二叉树</h2><h3 id="链二叉树的基本知识"><a href="#链二叉树的基本知识" class="headerlink" title="链二叉树的基本知识"></a>链二叉树的基本知识</h3><p>链二叉树的理解</p>
<blockquote>
<p>二叉树根据不同的物理结构，有两种实现方式，当二叉树的物理结构是采用链式存储结构时，就叫链二叉树。此时内存中会用并不一定连续空间顺序存二叉树的元素</p>
</blockquote>
<p>二叉链的理解</p>
<blockquote>
<p>链二叉树的数据节点有很多种，其中一种就是每个数据节点都有一个变量存储数据，两个指针，一个指向当前节点的左孩子节点，和右孩子节点。只有两个指针的数据节点，被称为二叉链数据节点，对应的二叉树的链表就就叫二叉链</p>
</blockquote>
<p>二叉链的图示</p>
<blockquote>
<p><img src="/blog/fujian/79412fd01f82f2551f8dee1d713fb881.png"></p>
</blockquote>
<p>二叉链的数据节点的构建思路</p>
<blockquote>
<p><img src="/blog/fujian/1a20f8e0ab0e91717659f7050c46876c.png"></p>
</blockquote>
<p>二叉链的构建思路</p>
<blockquote>
<p>数据<br>指针root：指向跟节点的指针。<br>变量sl：存储表格元素数量。</p>
</blockquote>
<p>三叉链表的理解</p>
<blockquote>
<p>数据节点有一个变量存储数据，三个指针，分别指向当前节点的左孩子节点，和右孩子节点，已经当前节点的父节点。<br>有三个指针的数据节点，被称为三叉链数据节点，对应的二叉树的链表就就叫三叉链</p>
</blockquote>
<p>三叉链的图示</p>
<blockquote>
<p><img src="/blog/fujian/f215b6bd2e91845f8a63f9522c817b17.png"></p>
</blockquote>
<p>三叉链的数据节点构建思路</p>
<blockquote>
<p><img src="/blog/fujian/9db0936df0fc140806ca145c45106e58.png"></p>
</blockquote>
<p>三叉链的构建思路</p>
<blockquote>
<p>数据<br>指针root：指向跟节点的指针。<br>变量sl：存储表格元素数量。</p>
</blockquote>
<p>链表的类图</p>
<blockquote>
<p><img src="/blog/fujian/869b02b458d394fb15004ca228b66aed.png"><br><img src="/blog/fujian/af249ec9d70b3d490aec57fba3fe035d.png"></p>
</blockquote>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>二叉树遍历的理解</p>
<blockquote>
<p>指按某条搜索路线遍访每个结点且不重复(又称周游)。<br>它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。</p>
</blockquote>
<p>遍历方法</p>
<blockquote>
<p>具体实现有三种方案。（无论哪种方案牢记一种约定，对每个结点的查看都是“先左后右”）<br>分别是先序遍历（DLR）、中序遍历（LDR）、后序遍历（LRD），<br>注:“先、中、后”的意思是指访问根节点时机。<br>从递归的角度看，这三种算法是完全相同的，或者说这三种遍历算法的访问路径是相同的，只是访问结点的时机不同。</p>
</blockquote>
<p>先序遍历算法步骤</p>
<blockquote>
<p>以这个图为例<br><img src="/blog/fujian/69b91adb9e762dad4503f41428360f7c.png"><br>1若二叉树为空，则遍历结束;<br>2访问根结点;<br>3先序遍历根结点的左子树;<br>4先序遍历根结点的右子树。<br>总的来先访问根，在访问左子树，最后访问右子树（简写为DLR，D为根，L为左子树，R为右子树）<br>上图由先序遍历得到的输出序列为abdecf</p>
</blockquote>
<p>中序遍历算法算法步骤</p>
<blockquote>
<p>以这个图为例<br><img src="/blog/fujian/69b91adb9e762dad4503f41428360f7c.png"><br>1若二叉树为空，则遍历结束;<br>2中序遍历根结点的左子树;<br>3访问根结点;<br>4中序遍历根结点的右子树。<br>总的来说先左在中最后在右，LDR<br>上图输出的序列顺序为dbeafc</p>
</blockquote>
<p>后序遍历算法的步骤如下:</p>
<blockquote>
<p>以这个图为例<br><img src="/blog/fujian/69b91adb9e762dad4503f41428360f7c.png"><br>1若二叉树为空，则遍历结束;<br>2后序遍历根结点的左子树;<br>3后序遍历根结点的右子树;<br>4访问根结点。<br>总的来说先左在右最后在中，LRD<br>上图输出的序列顺序为debfca</p>
</blockquote>
<p>先序遍历的实现举例</p>
<blockquote>
<p><img src="/blog/fujian/906df9ff20391a16594facb6c2859d85.png"><br>先序遍历函数PreOrder是类里的私函数，功能是先序遍历以p为根指针的二叉树，因此也是一个递归函数。<br>我们要在main函数里使用先序遍历函数，就得先定义他的调用函数，然后在main函数里，通过使用调用函数，来调用先序遍历函数。在调用函数里，我们将二叉树的根结点指针root作为实参传入。<br>而之所以我们在main函数里得通过调用函数来使用序遍历函数，是因为root是私有数据成员，因此我们无法在main()函数中直接使用先序遍历函数，即不能直接在main函数里执行bitree.PreOrder (bitree.root)。</p>
<p>所以在使用时，我们得将先序遍历函数，也是递归函数定义为私有成员函数，另外再定义一个公有无参函数Pre Order()来作为调用函数，然后在main函数里，通过 PreOrder()函数中调用PreOrder( root)函数即可。</p>
</blockquote>
<p>层序遍历的理解</p>
<blockquote>
<p>以下图为例<br><img src="/blog/fujian/8571465716f4b2bbf9797038e7e34a55.png"><br>层序遍历则输出abcdef</p>
</blockquote>
<p>层序遍历的实现</p>
<blockquote>
<p><img src="/blog/fujian/a927d137ae9ab5224f42d9391805d25a.png"></p>
</blockquote>
<h3 id="二叉树的构造"><a href="#二叉树的构造" class="headerlink" title="二叉树的构造"></a>二叉树的构造</h3><h4 id="二叉树的构造基础知识"><a href="#二叉树的构造基础知识" class="headerlink" title="二叉树的构造基础知识"></a>二叉树的构造基础知识</h4><p>构造的方式</p>
<blockquote>
<p>根据一段序列（可能是先序序列，可能是中序序列，可能是后序列），来构造其对应二叉树。</p>
</blockquote>
<p>构造的问题</p>
<blockquote>
<p>在二叉树的遍历中，无论先序序列、中序序列、后序序列，还是层次序列，和二叉树结构都不存在一一对应的关系。因为每个结点的左、右子树都可能缺失，所以无法确定在遍历序列中的后继结点是左孩子还是右孩子，或是有其他关系的结点。</p>
<p><img src="/blog/fujian/329354b39f04fa1c5f1960d91464be33.png"><br>如图所示的5种二叉树的先序序列都是abc。</p>
</blockquote>
<h4 id="空指针标记的先序序列构造"><a href="#空指针标记的先序序列构造" class="headerlink" title="空指针标记的先序序列构造"></a>空指针标记的先序序列构造</h4><p>用空指针标记的先序序列构造二叉树的方法</p>
<blockquote>
<p>稍微调整一下遍历规则可以建立起遍历序列和二叉树结构的一一对应关系。原遍历算法步骤①规定，若二叉树为空，则遍历结束。调整后的遍历算法步骤①规定，若二叉树为空，输出字符<code>*</code>之后遍历结束。调整后的遍历结果称为带空指针标记的遍历序列。符号<code>*</code>的意义在于标识空指针，它可以是任何一种与结点数据相异的特殊数据。例如，当结点数据都是正数时，可选取负数作为特殊数据来标记空指针。如下图<br><img src="/blog/fujian/8e411db12ad7750c5a2394a9c9e3bd82.png"><br>其先序序列是<code>abdecf</code>，带空指针标记的先序序列是<code>abd * * e ** cf ***</code>。</p>
</blockquote>
<p>空指针标记的先序序列构造二叉树的实现</p>
<blockquote>
<p><img src="/blog/fujian/be77b115acf606f43680eb45b6c5ac71.png"><br><img src="/blog/fujian/3f38a802a23b9261f0a63b2b81d6cdd0.png"><br>CreateByPre其功能是根据带空指针标记的先序序列创建二叉树。<br>思想本质，可以理解为用先序遍历遍历一个空的二叉树，再遍历过程，创建数据节点，然后把对应序列的值存进去<br>由于每次调用CreateByPre()函数都需要引用向量pre 中的下一个数据, 因此将参数pre和i设成引用变量,以达到数据的共享、提高参数传递效率的目的<br>该函数为其是私函数，不可被用户所调用，因此在要写在私有域内，然后用户可以通过构造函数调用。</p>
</blockquote>
<h4 id="两个遍历序列构造"><a href="#两个遍历序列构造" class="headerlink" title="两个遍历序列构造"></a>两个遍历序列构造</h4><p>可以唯一确定二叉树的两个遍历序列</p>
<blockquote>
<p>知道二叉树树的先序遍历序列和中序遍历序列，是可以唯一确定这颗二叉树的结构。<br>知道二叉树树后序遍历序列和中序遍历序列，也可以唯一确定这颗二叉树的结构<br>知道二叉树的先序遍历序列和后序遍历序列是无法唯一确定二叉树的结构。</p>
</blockquote>
<p>举例</p>
<blockquote>
<p>设已知某二叉树的先序遍历序列是ABHFDECKG，中序遍历序列是HBDFAEKCG,，下面是通过这两个序列求出二叉树的过程<br><img src="/blog/fujian/4797ac8a80ea8c9b053a603c99661eb6.png"><br>知道一棵树的先序遍历序列（简称先序列），和中序遍历序列（简称中序列），首先可以通过先序列，得出这颗二叉树的根节点，由中序列和根节点，可以得出左子树的中序列和右子树的中序列，以及左子树的节点个数，和右子数的节点个数。<br>而先序列的遍历顺序是先输出根节点，然后以先序遍历顺序输出左子树的节点，然后以先序遍历序列顺序输出右子树的节点。那么知道在左子树的节点个数，以及右子树的节点个数，就可以得出左子树的先序列，和右子树的先序列。<br>知道左子树的先序列和中序列，可以推出左子树的根节点和左子树的左右子树的先序列和中序列，同理右子树也是。然后不断的推出子树根节点，最终推出整课二叉树的结构。</p>
<p>总结就是知道一棵树先序列和中序列，结点个数得出这颗树的根节点，和左子树的先序列、中序列，节点个数，以及右子树的先序列、中序列、节点个数。然后以此不断类推出所有子树根节点，最终推出整课二叉树的结构。</p>
</blockquote>
<p>先序遍历序列和中序遍历构造二叉树实现</p>
<blockquote>
<p><img src="/blog/fujian/4ca023b06262614c6ccbb676ecb4e196.png"><br><img src="/blog/fujian/fcc2b53ad741d3c26e7285ede8d652c4.png"><br>Pre和mid分别存储该二叉树的先序列和中序列，ipre存储当前二叉树的先序列第一个元素的下标，imid存储当前二叉树的中序的第一个元素下标。<br>n存储当前子树的先序列的元素个数。<br>Creat该函数为其是私函数，不可被用户所调用，因此在要写在私有域内，然后用户可以通过构造函数调用。</p>
</blockquote>
<h4 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h4><p>拷贝构造实现</p>
<blockquote>
<p><img src="/blog/fujian/9027fa8a7b95473e528ea764924fbb9c.png"><br><img src="/blog/fujian/f6226cfc157479b8c4b8c284f336d93a.png"><br>函数从copy是私函数，p是传入的要copy的二叉树的根节点地址<br>该函数的作用是根据传入的要copy的二叉树根节点，然后完成对整个二叉树copy，并返回创建的二叉树的根节点。</p>
<p>递归理解该函数<br>传入：要copy 的二叉树的根节点，<br>返回：你创建的二叉树的根节点<br>调用函数，传入要copy二叉树根节点，获得我们创建的二叉树根节点，以这个思维，去构建函数的递归过程，也就是函数里去进行递归调用自身，传入要copy的二叉树的左子树的根节点，获取我们创建的二叉树的左子树的根结点。传入要copy的二叉树的右子树的根节点，获取我们创建的二叉树的右子树的根结点。当我们将递归过程构建完，函数执行过程中，就会不断递归调用，不断创建的二叉树的子树的根节点，最终成功创建整课二叉树。</p>
</blockquote>
<h3 id="二叉树的高度计算"><a href="#二叉树的高度计算" class="headerlink" title="二叉树的高度计算"></a>二叉树的高度计算</h3><p>二叉树的高度计算代码实现</p>
<blockquote>
<p><img src="/blog/fujian/4e8657d02f28a3128173f2113b61ead8.png"><br>第一个函数是私有函数，作用是根据传入的树的根节点，返回这棵树的高度。<br>在计算二叉树高度的过程中，每个结点的高度都被计算了一次。设二叉树中结点数是n，则算法的时间复杂度是O(n)。</p>
<p>递归理解<br>传入:二叉树的根节点<br>返回：这颗二叉树的深度<br>调用函数，传入二叉树根节点，获得当前树深度。函数的代码里，传入左右子树的根节点，获取左右子树的深度。</p>
</blockquote>
<h3 id="计算二叉树节点数"><a href="#计算二叉树节点数" class="headerlink" title="计算二叉树节点数"></a>计算二叉树节点数</h3><p>计算二叉树节点数代码实现</p>
<blockquote>
<p><img src="/blog/fujian/1611e1a9d85241bbffc8ea7649eb5481.png"><br>在第二个函数Count()中，以私有成员变量root为参数调用重载函数，得到当前对象中二叉树的结点数。</p>
</blockquote>
<h3 id="查找二叉树节点"><a href="#查找二叉树节点" class="headerlink" title="查找二叉树节点"></a>查找二叉树节点</h3><p>查找二叉树结点代码实现</p>
<blockquote>
<p><img src="/blog/fujian/e25349f36186eccf4b8ef02da9cfbc95.png"><br>第一个查找结点函数，p是传入的二叉树根节点，e是在这个二叉树里要查找的值，返回是返回查找到的结点。</p>
<p>递归理解<br>传入：二叉树的根节点，查找的值e<br>返回：e结点地址</p>
</blockquote>
<h3 id="二叉树释放"><a href="#二叉树释放" class="headerlink" title="二叉树释放"></a>二叉树释放</h3><p>二叉树释放代码实现</p>
<blockquote>
<p><img src="/blog/fujian/34022190ffc6f0067b90255454ef35d6.png"></p>
<p>递归理解<br>传入：二叉树的根结点p<br>作用：将二叉树p释放掉</p>
</blockquote>
<h3 id="链二叉树的实现"><a href="#链二叉树的实现" class="headerlink" title="链二叉树的实现"></a>链二叉树的实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">//二叉链的数据节点</span><br><span class="line">struct Sjjd</span><br><span class="line">&#123;</span><br><span class="line">    //左孩子指针</span><br><span class="line">    Sjjd&lt;T&gt; *lchild;</span><br><span class="line">    //右孩子指针</span><br><span class="line">    Sjjd&lt;T&gt; *rchild;</span><br><span class="line">    //存储的数据</span><br><span class="line">    T data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">class ECL</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    Sjjd&lt;T&gt; *root;</span><br><span class="line">    int sl;</span><br><span class="line">    //先序创建函数，P是传入的带空指针的先序序列的引用，i是p的下标变量的引用。</span><br><span class="line">    //思想本质，用先序遍历遍历一个空的二叉树，再遍历过程把，创建数据节点，然后把对应序列的值存进去</span><br><span class="line">    //该函数被先序构造函数所调用。因为其是私函数，不可被用户所调用，因此在要写在私有域内，然后用户可以通过构造函数调用。</span><br><span class="line">    Sjjd&lt;T&gt; *creatbypre_ECL(vector&lt;T&gt; &amp;p, int &amp;i);</span><br><span class="line"></span><br><span class="line">    //先中序创建函数，Pre和mid分别存储该二叉树的先序列和中序列，ip存储当前二叉树的先序列第一个元素的下标，im存储当前二叉树的中序的第一个元素下标。n存储当前子树的先序列的元素个数。</span><br><span class="line">    //该函数可以通过一颗二叉树的先序列和中序列构建出这颗二叉树的。</span><br><span class="line">    // 该函数为其是私函数，不可被用户所调用，因此在要写在私有域内，然后用户可以通过构造函数调用。</span><br><span class="line">    //思想，就是知道一棵树先序列和中序列，得出这颗树的根节点，和左子树的先序列、中序列，左子树节点个数，以及右子树的先序列、中序列、右子树的个数。然后以此不断类推出所有子树根节点，最终推出整课二叉树的结构。</span><br><span class="line">    Sjjd&lt;T&gt; *creatbypremid_ECL(vector&lt;T&gt; &amp;pre, vector&lt;T&gt; &amp;mid, int ip, int im, int n);</span><br><span class="line"></span><br><span class="line">    // copy创造函数，p是传入的要copy的二叉树的根节点地址</span><br><span class="line">    //该函数的作用是根据传入的要copy的二叉树根节点，然后完成对整个二叉树copy，并返回创建的二叉树的根节点。</span><br><span class="line">    //传入要copy二叉树根节点，获得我们创建的二叉树根节点，以及要copy的二叉树的左右孩子节点，最终就可以以此类推，不断推出我们要创建的二叉树的子树的根节点，最终成功创建整课二叉树</span><br><span class="line">    Sjjd&lt;T&gt; *creatbycopy_ECL(Sjjd&lt;T&gt; *gjd);</span><br><span class="line"></span><br><span class="line">    //有参先序遍历输出函数,root是要遍历的二叉树的根节点</span><br><span class="line">    // root是私有数据成员，在 main()函数中不能使用，因此把该函数定为类里的私函数，另外再重载定义公有无参函数xxbl_ECL（）来供主调函数调用</span><br><span class="line">    void xxbl_ECL(Sjjd&lt;T&gt; *root);</span><br><span class="line"></span><br><span class="line">    //有参的返回深度函数，gjd是传入的根节点</span><br><span class="line">    //作用是根据传入的树的根节点，返回这棵树的高度</span><br><span class="line">    int return_sd_ECL(Sjjd&lt;T&gt; *gjd);</span><br><span class="line"></span><br><span class="line">    //查找结点函数，gjd是传入的二叉树根节点，e是在这个二叉树里要查找的值，返回是返回查找到的结点。</span><br><span class="line">    Sjjd&lt;T&gt; *find_jd_ECL(Sjjd&lt;T&gt; *gjd, T e);</span><br><span class="line"></span><br><span class="line">    //释放函数，gjd是传入进来要释放的二叉树的根节点</span><br><span class="line">    void free_ECL(Sjjd&lt;T&gt; *gjd);</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    //无参构造函数，构造空树</span><br><span class="line">    ECL();</span><br><span class="line"></span><br><span class="line">    //先序构造函数，P是存储带空指针的先序序列的一个单链表。</span><br><span class="line">    //用户得先创建一段带空指针的先序序列，然后调用先序构造函数的时候将其传进来，然后先序构造函数调用先序创建函数来构造二叉树，这里规定空指针为-1</span><br><span class="line">    ECL(vector&lt;T&gt; &amp;p);</span><br><span class="line"></span><br><span class="line">    //先中序创建函数，Pre和mid分别存储该二叉树的先序列和中序列</span><br><span class="line">    //该函数左右，通过用户传进来一颗二叉树得先序列和中序列，构建出这课二叉树</span><br><span class="line">    ECL(vector&lt;T&gt; &amp;pre, vector&lt;T&gt; &amp;mid);</span><br><span class="line"></span><br><span class="line">    //拷贝构造函数,p是传入的要copy的二叉树对象</span><br><span class="line">    //根节点传入的二叉树对象，调用copy创建函数，来创建新的二叉树</span><br><span class="line">    ECL(ECL &amp;p);</span><br><span class="line"></span><br><span class="line">    //无参的先序遍历输出函数，其作用是调用有参的先序遍历函数</span><br><span class="line">    void xxbl_ECL();</span><br><span class="line"></span><br><span class="line">    //无参的返回深度函数，起作用是调用有参的返回深度函数，求得当前树的深度</span><br><span class="line">    int return_sd_ECL();</span><br><span class="line"></span><br><span class="line">    //查找结点函数,e是查找的值</span><br><span class="line">    //调用重载函数查找该节点地址</span><br><span class="line">    Sjjd&lt;T&gt; *find_jd_ECL(T e);</span><br><span class="line"></span><br><span class="line">    //析构函数，用来调用释放函数来释放链表</span><br><span class="line">    ~ECL();</span><br><span class="line">&#125;;</span><br><span class="line">//先序创建函数，P是传入的带空指针的先序序列的引用，i是p的下标变量的引用。</span><br><span class="line">//思想本质，用先序遍历遍历一个空的二叉树，再遍历过程把，创建数据节点，然后把对应序列的值存进去</span><br><span class="line">//该函数被先序构造函数所调用。因为其是私函数，不可被用户所调用，因此在要写在私有域内，然后用户可以通过构造函数调用。</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">Sjjd&lt;T&gt; *ECL&lt;T&gt;::creatbypre_ECL(vector&lt;T&gt; &amp;p, int &amp;i)</span><br><span class="line">&#123;</span><br><span class="line">    T data = p[i];</span><br><span class="line">    i++;</span><br><span class="line">    //-1是空指针，说明该节点为空</span><br><span class="line">    if (data == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Sjjd&lt;T&gt; *jd = new Sjjd&lt;T&gt;;</span><br><span class="line">    jd-&gt;data = data;</span><br><span class="line">    //让变量i指向序列p的下一个元素</span><br><span class="line"></span><br><span class="line">    //先序遍历左边的节点，再遍历过程中创建节点。P和i两者合起来，可以当成指向左节点的指针</span><br><span class="line">    jd-&gt;lchild = creatbypre_ECL(p, i);</span><br><span class="line"></span><br><span class="line">    //创建右子树</span><br><span class="line">    jd-&gt;rchild = creatbypre_ECL(p, i);</span><br><span class="line">    return jd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//先中序创建函数，Pre和mid分别存储该二叉树的先序列和中序列，ip存储当前二叉树的先序列第一个元素的下标，im存储当前二叉树的中序的第一个元素下标。n存储当前子树的先序列的元素个数，返回值是当前树的根节点。</span><br><span class="line">//该函数可以通过一颗二叉树的先序列和中序列构建出这颗二叉树的。</span><br><span class="line">//该函数为其是私函数，不可被用户所调用，因此在要写在私有域内，然后用户可以通过构造函数调用。</span><br><span class="line">//思想，就是知道一棵树先序列和中序列，得出这颗树的根节点，和左子树的先序列、中序列，节点个数，以及右子树的先序列、中序列、节点个数。然后以此不断类推出所有子树根节点，最终推出整课二叉树的结构。</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">Sjjd&lt;T&gt; *ECL&lt;T&gt;::creatbypremid_ECL(vector&lt;T&gt; &amp;pre, vector&lt;T&gt; &amp;mid, int ip, int im, int n)</span><br><span class="line">&#123;</span><br><span class="line">    //当树的结点数为0时，说明该树无根节点，则返回NULL</span><br><span class="line">    if (n == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    //由先序列，得出当前树的根节点的值，创建数据节点，将其存储起来</span><br><span class="line">    Sjjd&lt;T&gt; *jd = new Sjjd&lt;T&gt;;</span><br><span class="line">    jd-&gt;data = pre[ip];</span><br><span class="line"></span><br><span class="line">    //通过对比根节点在中序列得位置，得出左右子树的个数</span><br><span class="line">    int i = 0;</span><br><span class="line">    for (; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (pre[ip] == mid[im + i])</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //由左子树的先序列，中序列，左子树的个数，得出左子树的根节点，也就是当前树的左孩子结点吗，不断的以此类推，递归求出所有子树的根节点，最终构建出整课二叉树</span><br><span class="line">    jd-&gt;lchild = creatbypremid_ECL(pre, mid, ip + 1, im, i);</span><br><span class="line">    //同理求出右子树的根节点，也就是当前树的右孩子节点</span><br><span class="line">    jd-&gt;rchild = creatbypremid_ECL(pre, mid, ip + i + 1, im + i + 1, n - i - 1);</span><br><span class="line"></span><br><span class="line">    //返回当前子树的根节点。</span><br><span class="line">    return jd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// copy创造函数，p是传入的要copy的二叉树的根节点地址</span><br><span class="line">//该函数的作用是根据传入的要copy的二叉树根节点，然后完成对整个二叉树copy，并返回创建的二叉树的根节点。</span><br><span class="line">//传入要copy二叉树根节点，获得我们创建的二叉树根节点，以及要copy的二叉树的左右孩子节点，最终就可以以此类推，不断推出我们要创建的二叉树的子树的根节点，最终成功创建整课二叉树</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">Sjjd&lt;T&gt; *ECL&lt;T&gt;::creatbycopy_ECL(Sjjd&lt;T&gt; *gjd)</span><br><span class="line">&#123;</span><br><span class="line">    if (gjd == NULL)</span><br><span class="line">        return NULL;</span><br><span class="line">    //根据传入的树的根节点，创建出新的二叉树的根节点</span><br><span class="line">    Sjjd&lt;T&gt; *jd = new Sjjd&lt;T&gt;;</span><br><span class="line">    jd-&gt;data = gjd-&gt;data;</span><br><span class="line"></span><br><span class="line">    //通过传入的树的根节点，获得这棵树的左右子树的根节点，这样我们就可以创建出我们当前树的左右子树的根节点</span><br><span class="line">    jd-&gt;lchild = creatbycopy_ECL(gjd-&gt;lchild);</span><br><span class="line">    jd-&gt;rchild = creatbycopy_ECL(gjd-&gt;rchild);</span><br><span class="line">    return jd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//无参构造函数，构造空树</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">ECL&lt;T&gt;::ECL()</span><br><span class="line">&#123;</span><br><span class="line">    root = NULL;</span><br><span class="line">&#125;</span><br><span class="line">//先序构造函数，P是存储带空指针的先序序列的一个单链表。</span><br><span class="line">//用户得先创建一段带空指针的先序序列，然后调用先序构造函数的时候将其传进来，然后先序构造函数调用先序创建函数来构造二叉树，这里规定空指针为-1</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">ECL&lt;T&gt;::ECL(vector&lt;T&gt; &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">    //遍历i存储先序序列p的下标，最开始存储第一个元素的下标</span><br><span class="line">    int i = 0;</span><br><span class="line">    //调用先序创建函数来创建二叉树</span><br><span class="line">    root = creatbypre_ECL(p, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//先中序构造函数，Pre和mid分别存储该二叉树的先序列和中序列</span><br><span class="line">//该函数作用，通过用户传进来一颗二叉树得先序列和中序列，然后调用先中序创建函数，构建出这课二叉树，并将其返回的根节点地址赋值给root。</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">ECL&lt;T&gt;::ECL(vector&lt;T&gt; &amp;pre, vector&lt;T&gt; &amp;mid)</span><br><span class="line">&#123;</span><br><span class="line">    int n = pre.size();</span><br><span class="line">    root = creatbypremid_ECL(pre, mid, 0, 0, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//拷贝构造函数,p是传入的要copy的二叉树对象</span><br><span class="line">//根节点传入的二叉树对象，调用copy创建函数，来创建新的二叉树</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">ECL&lt;T&gt;::ECL(ECL &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">    root = creatbycopy_ECL(p.root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//有参先序遍历输出函数,root是要遍历的二叉树的根节点</span><br><span class="line">// root是私有数据成员，在 main()函数中不能使用，因此把该函数定为类里的私函数，另外再重载定义公有无参函数xxbl_ECL（）来供主调函数调用</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void ECL&lt;T&gt;::xxbl_ECL(Sjjd&lt;T&gt; *root)</span><br><span class="line">&#123;</span><br><span class="line">    //树的根节点为空，说明该节点不存在</span><br><span class="line">    if (root == NULL)</span><br><span class="line">        return;</span><br><span class="line">    //根节点不为空</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //输出当前树的根节点</span><br><span class="line">        cout &lt;&lt; root-&gt;data &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        //先序遍历该节点的左子树</span><br><span class="line">        xxbl_ECL(root-&gt;lchild);</span><br><span class="line">        //先序遍历该节点的右子树</span><br><span class="line">        xxbl_ECL(root-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//无参的先序遍历输出函数，其作用是调用有参的先序遍历函数</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void ECL&lt;T&gt;::xxbl_ECL()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    xxbl_ECL(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//有参的返回深度函数，gjd是传入的根节点</span><br><span class="line">//作用是根据传入的树的根节点，返回这棵树的高度</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">int ECL&lt;T&gt;::return_sd_ECL(Sjjd&lt;T&gt; *gjd)</span><br><span class="line">&#123;</span><br><span class="line">    //当树是空的就没有条件</span><br><span class="line">    if (gjd == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //根据这个根节点左右子树的根节点，我们可以获得左右子树的深度</span><br><span class="line">    int zzssd = return_sd_ECL(gjd-&gt;lchild);</span><br><span class="line">    int yzssd = return_sd_ECL(gjd-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    //在获得左右子树的深度的情况下，就可以返回当前树的深度，那就是最大的左右子树的深度，加本身节点。</span><br><span class="line">    if (zzssd &gt; yzssd)</span><br><span class="line">    &#123;</span><br><span class="line">        return zzssd + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return yzssd + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//无参的返回深度函数，起作用是调用有参的返回深度函数，求得当前树的深度</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">int ECL&lt;T&gt;::return_sd_ECL()</span><br><span class="line">&#123;</span><br><span class="line">    return return_sd_ECL(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//查找结点函数，gjd是传入的二叉树根节点，e是在这个二叉树里要查找的值，返回是返回查找到的结点。</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">Sjjd&lt;T&gt; *ECL&lt;T&gt;::find_jd_ECL(Sjjd&lt;T&gt; *gjd, T e)</span><br><span class="line">&#123;</span><br><span class="line">    //根节点为空，说明当前树没有该值</span><br><span class="line">    if (gjd == NULL)</span><br><span class="line">        return NULL;</span><br><span class="line">    //找到该值，返回该值的根结点</span><br><span class="line">    if (gjd-&gt;data == e)</span><br><span class="line">        return gjd;</span><br><span class="line"></span><br><span class="line">    //在左子树查找是否有该根节点,有的话就返回查找的结点</span><br><span class="line">    Sjjd&lt;T&gt; *p = find_jd_ECL(gjd-&gt;lchild, e);</span><br><span class="line">    if (p != NULL)</span><br><span class="line">        return p;</span><br><span class="line">    else</span><br><span class="line">        return find_jd_ECL(gjd-&gt;rchild, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//查找结点函数,e是查找的值</span><br><span class="line">//调用重载函数查找该节点地址</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">Sjjd&lt;T&gt; *ECL&lt;T&gt;::find_jd_ECL(T e)</span><br><span class="line">&#123;</span><br><span class="line">    return find_jd_ECL(root, e);</span><br><span class="line">&#125;</span><br><span class="line">//释放函数，p是传入进来要释放的二叉树的根基的</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void ECL&lt;T&gt;::free_ECL(Sjjd&lt;T&gt; *gjd)</span><br><span class="line">&#123;</span><br><span class="line">    //当前树的根节点为空，则不用再释放</span><br><span class="line">    if (gjd == NULL)</span><br><span class="line">        return;</span><br><span class="line">    //释放左右子树的根节点</span><br><span class="line">    free_ECL(gjd-&gt;lchild);</span><br><span class="line">    free_ECL(gjd-&gt;rchild);</span><br><span class="line">    delete gjd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//析构函数，用来调用释放函数来释放链表</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">ECL&lt;T&gt;::~ECL()</span><br><span class="line">&#123;</span><br><span class="line">    free_ECL(root);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //测试的带空指针的先序序列为1，2，3，-1，-1，4，-1，-1，5，6，-1，-1，-1</span><br><span class="line">    vector&lt;int&gt; a;</span><br><span class="line">    a.push_back(1);</span><br><span class="line">    a.push_back(2);</span><br><span class="line">    a.push_back(3);</span><br><span class="line">    a.push_back(-1);</span><br><span class="line">    a.push_back(-1);</span><br><span class="line">    a.push_back(4);</span><br><span class="line">    a.push_back(-1);</span><br><span class="line">    a.push_back(-1);</span><br><span class="line">    a.push_back(5);</span><br><span class="line">    a.push_back(6);</span><br><span class="line">    a.push_back(-1);</span><br><span class="line">    a.push_back(-1);</span><br><span class="line">    a.push_back(-1);</span><br><span class="line">    ECL&lt;int&gt; b(a);</span><br><span class="line"></span><br><span class="line">    //测试先中序构造二叉树,先序序列为123456，中序列为324165,</span><br><span class="line">    vector&lt;int&gt; pre;</span><br><span class="line">    vector&lt;int&gt; mid;</span><br><span class="line">    pre.push_back(1);</span><br><span class="line">    pre.push_back(2);</span><br><span class="line">    pre.push_back(3);</span><br><span class="line">    pre.push_back(4);</span><br><span class="line">    pre.push_back(5);</span><br><span class="line">    pre.push_back(6);</span><br><span class="line"></span><br><span class="line">    mid.push_back(3);</span><br><span class="line">    mid.push_back(2);</span><br><span class="line">    mid.push_back(4);</span><br><span class="line">    mid.push_back(1);</span><br><span class="line">    mid.push_back(6);</span><br><span class="line">    mid.push_back(5);</span><br><span class="line"></span><br><span class="line">    ECL&lt;int&gt; c(pre, mid);</span><br><span class="line">    //测试copy构造函数 c2 copy c.</span><br><span class="line">    ECL&lt;int&gt; c2(c);</span><br><span class="line">    c2.xxbl_ECL();</span><br><span class="line">    //测试查找结点的函数</span><br><span class="line">    Sjjd&lt;int&gt; *jd = c2.find_jd_ECL(2);</span><br><span class="line">    cout &lt;&lt; jd-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="huffman树"><a href="#huffman树" class="headerlink" title="huffman树"></a>huffman树</h2><h3 id="huffman树的基础知识"><a href="#huffman树的基础知识" class="headerlink" title="huffman树的基础知识"></a>huffman树的基础知识</h3><p>信息编码的理解</p>
<blockquote>
<p>信息编码的方法可分为定长编码和不定长编码两大类。</p>
<p>定长编码是指在编码系统中，每个符号的代码长度相等。例如，在常用的 ASCII码中，每个符号的编码都是一个字节。</p>
<p>不定长编码每个符号的长度不一定相等，其基本思想是根据各种符号出现的频率来编码，使经常出现的符号的编码较短，不常出现的符号的编码较长。由于使用不定长编码的目的是使信息经过编码后的编码文件长度尽可能短，因此也称为统计编码。相比定长编码，不定长编码不仅节省磁盘空间,还能提高传递和运算速度。</p>
</blockquote>
<p>平均码长的理解</p>
<blockquote>
<p>设某编码系统中有n个符号，每个符号的码长分别是L1,L2，…，Ln，各自出现的频率分别是F1,F2，…，Fn，则</p>
<p><img src="/blog/fujian/c0922b428673787c88352ef0752c2b37.png"></p>
</blockquote>
<p>定长编码和不定长编码的举例</p>
<blockquote>
<p>假设某信息系统中有4种符号，分别记作A、B、C、D，它们各自出现的统计频率是5% 、2%、45%、48%。</p>
<p>若采用定长编码方式，则每个符号的编码需要2位，如A是00，B是01,C是10，D是11，平均码长是2。</p>
<p>若采用不定长编码方式，假设A是000，B是001,C是01,D是1，则平均码长&#x3D;3×5% +3×2% +2×45% +1×48% &#x3D;0.15+0.06+0.9+0.48 &#x3D; 1.59。显然，在这种情形下,不定长编码的平均码长更短。 相同的信息，平均码长越短，所消耗的资源越少，因此在这个情况下，不定长编码的效率要优于定长编码。</p>
</blockquote>
<p>不定长编码可能出现的问题</p>
<blockquote>
<p>但是，由于不定长编码的码长不固定，因此在识别编码串时，存在各符号的码串相互混淆的可能。例如，上述不定长编码中，若将D的编码改为0，则编码串“000”的意义既可以是一个符号A，也可以是3个符号D。因此，必须为不定长编码增加如下约束条件:在同一编码系统中，任何符号的编码不能是另一符号编码的前缀。满足此条件的编码也被称为前缀编码.。</p>
</blockquote>
<p>二叉树的带权路径长度的理解</p>
<blockquote>
<p>在二叉树结构中，设有n个叶子结点，每个叶子结点有一个权值，记作 Wi。 (1≤i≤n)，从根结点到各个叶子结点的路径长度记作Li，则该二叉树的带权路径长度（Weighted Path Length,WPL)<br><img src="/blog/fujian/cf93c99005b7070753ab0147ecfcae5f.png"></p>
</blockquote>
<p>huffman树的理解</p>
<blockquote>
<p>huffman树是一种特殊的二叉树，他也被称为最优树。<br>Huffman 树是在叶子结点集合确定的前提下，所有可能的二叉树形态中，树的带权路径长度最小的二叉树。</p>
</blockquote>
<p>huffman树的举例</p>
<blockquote>
<p>例如,已知4个叶子结点的权值分别是2、4、5、7,<br>假设这四个叶子结点只能构造出下面图中3种形态的二叉树。<br><img src="/blog/fujian/3af3bc7243e774b942b54d1ae24ddb45.png"></p>
<p>其中，图a所示的二叉树的WPL&#x3D;46，图b所示的二叉树的WPL &#x3D;36，图c所示的二叉树的WPL &#x3D; 35。<br>那么图c就是是在叶子结点集和确定的前提，所有可能的二叉树形态中树的带权路径长度最小的二叉树，也就是说图c就是huffman树</p>
</blockquote>
<p>huffman编码</p>
<blockquote>
<p>当Huffman树进行huffman编码时，叶子结点可以看成是需要编码的符号。此时从根结点开始，将每个结点的左分支记作0，右分支记作1，那么每个叶子结点的路径都可以用一个0&#x2F;1串的编码来表示，也就是说，每一个叶子结点都可以用0&#x2F;1串的编码来表示，这种编码称作Huffman编码。<br>在Huffman编码下，可以理解为，每一个叶子结点就是需要编码的符号。每个叶子结点的权值，就是需要编码的符号的频率。每一个叶子结点可以用他的路径（一个0&#x2F;1串的编码）来表示，也就是说叶子结点的路径相当于符号的编码，叶子结点的路径长度，就是编码长度。 那么此时Huffman树的带权路径长度，就是这个编码系统的平均码长。</p>
</blockquote>
<p>不能将普通结点作为需要编码的符号的原因。</p>
<blockquote>
<p>将huffman树叶子结点进行huffman编码，而不将huffman树的普通结点进行huffman编码的原因是，叶子结点的路径不会是另一个叶子结点的路径的前缀，而普通结点的路径，可能会是其他结点的前缀，这样编码就不属于前缀编码，在识别编码时就可能会出现混淆。</p>
</blockquote>
<p>使用huffman树进行编码的原因</p>
<blockquote>
<p>Huffman树的带权路径长度最小，因此使用Huffman树进行huffman编码的平均码长也是最小。一些压缩&#x2F;解压缩软件就是基于Huffman编码实现的。</p>
</blockquote>
<h3 id="huffman树的构造"><a href="#huffman树的构造" class="headerlink" title="huffman树的构造"></a>huffman树的构造</h3><p>huffman树的构造算法</p>
<blockquote>
<p><img src="/blog/fujian/05ade85e78e79d4fba77655a90bd1bee.png"></p>
</blockquote>
<p>huffman树的构造算法举例说明</p>
<blockquote>
<p>假设某信息系统中有5种符号，分别记作A、B、C、D、E，它们各自出现的统计频率是6%、14%、53%、15%、12%。</p>
<p>Huffman树的构造过程如下图</p>
<p><img src="/blog/fujian/8d7e2993f90eee5dba469d6f32000078.png"><br><img src="/blog/fujian/bfa6256cdfbe75b1ca2561e92e6cbc77.png"><br><img src="/blog/fujian/6a1eaf41a520029515f6efcfdac684a9.png"><br>e所示的是最终建成的Huffman树，f是从e中读出的Huffman编码。</p>
</blockquote>
<h1 id="数据结构问题"><a href="#数据结构问题" class="headerlink" title="数据结构问题"></a>数据结构问题</h1><h2 id="约瑟夫问题"><a href="#约瑟夫问题" class="headerlink" title="约瑟夫问题"></a>约瑟夫问题</h2><p>约瑟夫问题描述</p>
<blockquote>
<p>n个人围成一个圆圈，首先第1个人从1开始一个人一个人顺时针报数，报到第m 个人，令其出列。然后再从下一个人开始从1顺时针报数，报到第m 个人，再令其出列，如此下去，求出列顺序。</p>
</blockquote>
<p>约瑟夫问题举例</p>
<blockquote>
<p>N&#x3D;8<br>M&#x3D;3<br><img src="/blog/fujian/75f0981080db486f2bafeaef1bce55a5.png"><br>最终数出来的约瑟夫序列为3 6 1 5 2 8 4 7 </p>
</blockquote>
<p>实现文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">//在单向循环链表里插入该函数</span><br><span class="line">//输出约瑟夫序列函数，解决约瑟夫问题，输出约瑟夫所需要的序列</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void DXXHLB&lt;T&gt;::prinysf_DXXHLB(int m)</span><br><span class="line">&#123;</span><br><span class="line">     //创建一个指针，用来指向表格中的节点，里面先暂时指向头结点</span><br><span class="line">    Sjjd&lt;T&gt; *jd = head;</span><br><span class="line">    //index表示jd节点在表格中位置。其表示方法，是到第m个节点的时候index为m，但是下一个节点开始，index会重置为1，然后又到第m+1个节点又重置为1。头结点跳过。</span><br><span class="line">    int index = 0;</span><br><span class="line"></span><br><span class="line">    //当表格只剩下一个结点的时候会跳出循环</span><br><span class="line">    while (sl &gt; 1)</span><br><span class="line">    &#123;</span><br><span class="line">        //jd存储下一个节点的位置</span><br><span class="line">        jd = jd-&gt;next;</span><br><span class="line">        //如果jd是头结点，则跳过头结点</span><br><span class="line">        if (jd == head)</span><br><span class="line">        &#123;</span><br><span class="line">            jd = jd-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        //更新index</span><br><span class="line">        ++index;</span><br><span class="line"></span><br><span class="line">        if (index == m)</span><br><span class="line">        &#123;</span><br><span class="line">            //输出第m个结点的数据</span><br><span class="line">            cout &lt;&lt; jd-&gt;data &lt;&lt; &quot; &quot;;</span><br><span class="line"></span><br><span class="line">            //存储要删除的结点的数据</span><br><span class="line">            T deletedata = jd-&gt;data;</span><br><span class="line">            //jd存储下一个结点的地址</span><br><span class="line">            jd = jd-&gt;next;</span><br><span class="line">            //跳过头结点</span><br><span class="line">            if (jd == head)</span><br><span class="line">            &#123;</span><br><span class="line">                jd = jd-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            //用值删除函数，删除刚刚输出的结点</span><br><span class="line">            removebyvalue_DXXHLB(deletedata);</span><br><span class="line">            //更新sl和index</span><br><span class="line">            --sl;</span><br><span class="line">            index = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//输出表格剩下的一个结点</span><br><span class="line">    cout &lt;&lt; head-&gt;next-&gt;data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试文件Yef.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;DXXHLB.h&quot;</span><br><span class="line">#include &quot;DXXHLB.cpp&quot;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    DXXHLB&lt;int&gt; a;</span><br><span class="line">    int m, n;</span><br><span class="line">    cout &lt;&lt; &quot;n:&quot;;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; &quot;m:&quot;;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a.insert_DXXHLB(i, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    a.prinysf_DXXHLB(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://xingwumo.github.io/blog">wumo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://xingwumo.github.io/blog/2023/07/01/B4.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">http://xingwumo.github.io/blog/2023/07/01/B4.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://xingwumo.github.io/blog" target="_blank">wumo学习分享仓库</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/blog/fujian/a4765ed9990a10e5015c6931b31b06f2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://fastly.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blog/2023/07/01/B5.C++STL/" title="B5.C++STL"><img class="cover" src="/blog/fujian/4f7e72f6ec78d0bf231e6368530d04f2.jpg" onerror="onerror=null;src='/blog/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">B5.C++STL</div></div></a></div><div class="next-post pull-right"><a href="/blog/2023/07/01/B7.OBSidian%E4%B8%8EHEXO%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%96%B9%E6%A1%88/" title="B7.OBSidian与HEXO的博客搭建方案"><img class="cover" src="/blog/fujian/f29e80ed140a6f314281b4f2556197f0.png" onerror="onerror=null;src='/blog/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">B7.OBSidian与HEXO的博客搭建方案</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/blog/img/favicon.png" onerror="this.onerror=null;this.src='/blog/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">wumo</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">数据结构的基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E7%9B%B8%E5%85%B3%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text">数据结构的理解和相关定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">数据结构中的物理结构和逻辑结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">数据结构的常用函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">2.</span> <span class="toc-text">线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">2.1.</span> <span class="toc-text">线性表的基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="toc-number">2.2.</span> <span class="toc-text">顺序表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">2.2.1.</span> <span class="toc-text">顺序表的基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.2.</span> <span class="toc-text">顺序表的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">2.3.</span> <span class="toc-text">单链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">2.3.1.</span> <span class="toc-text">单链表的基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.2.</span> <span class="toc-text">单链表的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%81%E4%B8%9A%E9%93%BE%E8%A1%A8"><span class="toc-number">2.4.</span> <span class="toc-text">企业链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%81%E4%B8%9A%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">2.4.1.</span> <span class="toc-text">企业链表的基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%81%E4%B8%9A%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.4.2.</span> <span class="toc-text">企业链表的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">2.5.</span> <span class="toc-text">单向循环链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">2.5.1.</span> <span class="toc-text">单向循环链表的基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.5.2.</span> <span class="toc-text">单向循环链表的实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">3.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">3.1.</span> <span class="toc-text">栈的基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%A0%88"><span class="toc-number">3.2.</span> <span class="toc-text">顺序栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">3.2.1.</span> <span class="toc-text">顺序栈的基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.2.</span> <span class="toc-text">顺序栈的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E6%A0%88"><span class="toc-number">3.3.</span> <span class="toc-text">链栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%A0%88%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">3.3.1.</span> <span class="toc-text">链栈的基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.3.2.</span> <span class="toc-text">链栈的实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">4.</span> <span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">4.1.</span> <span class="toc-text">队列的基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97"><span class="toc-number">4.2.</span> <span class="toc-text">顺序队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">4.2.1.</span> <span class="toc-text">顺序队列的基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.2.</span> <span class="toc-text">顺序队列的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E9%98%9F%E5%88%97"><span class="toc-number">4.3.</span> <span class="toc-text">链队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">4.3.1.</span> <span class="toc-text">链队列的基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.3.2.</span> <span class="toc-text">链队列的实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">5.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-number">5.1.</span> <span class="toc-text">树的基本知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-number">5.2.</span> <span class="toc-text">二叉树的基本知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.3.</span> <span class="toc-text">顺序二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-number">5.3.1.</span> <span class="toc-text">顺序二叉树的基本知识</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.4.</span> <span class="toc-text">链二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-number">5.4.1.</span> <span class="toc-text">链二叉树的基本知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">5.4.2.</span> <span class="toc-text">二叉树的遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">5.4.3.</span> <span class="toc-text">二叉树的构造</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">5.4.3.1.</span> <span class="toc-text">二叉树的构造基础知识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88%E6%A0%87%E8%AE%B0%E7%9A%84%E5%85%88%E5%BA%8F%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0"><span class="toc-number">5.4.3.2.</span> <span class="toc-text">空指针标记的先序序列构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0"><span class="toc-number">5.4.3.3.</span> <span class="toc-text">两个遍历序列构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0"><span class="toc-number">5.4.3.4.</span> <span class="toc-text">拷贝构造</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6%E8%AE%A1%E7%AE%97"><span class="toc-number">5.4.4.</span> <span class="toc-text">二叉树的高度计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E6%95%B0"><span class="toc-number">5.4.5.</span> <span class="toc-text">计算二叉树节点数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9"><span class="toc-number">5.4.6.</span> <span class="toc-text">查找二叉树节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%87%8A%E6%94%BE"><span class="toc-number">5.4.7.</span> <span class="toc-text">二叉树释放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.4.8.</span> <span class="toc-text">链二叉树的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#huffman%E6%A0%91"><span class="toc-number">5.5.</span> <span class="toc-text">huffman树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#huffman%E6%A0%91%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">5.5.1.</span> <span class="toc-text">huffman树的基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#huffman%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">5.5.2.</span> <span class="toc-text">huffman树的构造</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%97%AE%E9%A2%98"><span class="toc-number">6.</span> <span class="toc-text">数据结构问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98"><span class="toc-number">6.1.</span> <span class="toc-text">约瑟夫问题</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/2024/01/02/%E7%A7%92%E9%80%9F5CM%E6%96%87%E6%A1%88%201/" title="秒速5CM文案 1">秒速5CM文案 1</a><time datetime="2024-01-01T16:00:00.000Z" title="发表于 2024-01-02 00:00:00">2024-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/07/23/B1.C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="B1.C++基础知识"><img src="/blog/fujian/7f6aba31b4c37b3ff37eeec6dea1eb08.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="B1.C++基础知识"/></a><div class="content"><a class="title" href="/blog/2023/07/23/B1.C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="B1.C++基础知识">B1.C++基础知识</a><time datetime="2023-07-22T16:00:00.000Z" title="发表于 2023-07-23 00:00:00">2023-07-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/07/02/GamePlay%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6%E6%9E%84%E6%88%90/" title="GamePlay基础框架构成"><img src="/blog/fujian/c9e4acd4daeeff67236a5f9bfa0e57e6.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="GamePlay基础框架构成"/></a><div class="content"><a class="title" href="/blog/2023/07/02/GamePlay%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6%E6%9E%84%E6%88%90/" title="GamePlay基础框架构成">GamePlay基础框架构成</a><time datetime="2023-07-01T16:00:00.000Z" title="发表于 2023-07-02 00:00:00">2023-07-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/07/01/B1.Markdown%E7%9A%84%E5%B8%B8%E7%94%A8%E8%AF%AD%E8%A8%80%E8%A7%84%E5%88%99/" title="B1.Markdown的常用语言规则"><img src="/blog/fujian/86f423ffed4a9a1c33ff8db747ba24b2.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="B1.Markdown的常用语言规则"/></a><div class="content"><a class="title" href="/blog/2023/07/01/B1.Markdown%E7%9A%84%E5%B8%B8%E7%94%A8%E8%AF%AD%E8%A8%80%E8%A7%84%E5%88%99/" title="B1.Markdown的常用语言规则">B1.Markdown的常用语言规则</a><time datetime="2023-06-30T16:00:00.000Z" title="发表于 2023-07-01 00:00:00">2023-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/07/01/B1.Git%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="B1.Git基础知识"><img src="/blog/fujian/b9a047b5abbc54c9f035ccdaab4e02e0.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="B1.Git基础知识"/></a><div class="content"><a class="title" href="/blog/2023/07/01/B1.Git%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="B1.Git基础知识">B1.Git基础知识</a><time datetime="2023-06-30T16:00:00.000Z" title="发表于 2023-07-01 00:00:00">2023-07-01</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/blog/fujian/a4765ed9990a10e5015c6931b31b06f2.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By wumo</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/blog/js/utils.js"></script><script src="/blog/js/main.js"></script><script src="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>